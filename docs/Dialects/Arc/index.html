<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'arc' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/Arc/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'arc' Dialect</h1><p>Canonical representation of state transfer in a circuit
This is the <code>arc</code> dialect, useful for representing state transfer functions
in a circuit.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#arcalloc_memory-circtarcallocmemoryop><code>arc.alloc_memory</code> (circt::arc::AllocMemoryOp)</a></li><li><a href=#arcalloc_state-circtarcallocstateop><code>arc.alloc_state</code> (circt::arc::AllocStateOp)</a></li><li><a href=#arcalloc_storage-circtarcallocstorageop><code>arc.alloc_storage</code> (circt::arc::AllocStorageOp)</a></li><li><a href=#arccall-circtarccallop><code>arc.call</code> (circt::arc::CallOp)</a></li><li><a href=#arcclock_domain-circtarcclockdomainop><code>arc.clock_domain</code> (circt::arc::ClockDomainOp)</a></li><li><a href=#arcclock_tree-circtarcclocktreeop><code>arc.clock_tree</code> (circt::arc::ClockTreeOp)</a></li><li><a href=#arcdefine-circtarcdefineop><code>arc.define</code> (circt::arc::DefineOp)</a></li><li><a href=#arclut-circtarclutop><code>arc.lut</code> (circt::arc::LutOp)</a></li><li><a href=#arcmemory-circtarcmemoryop><code>arc.memory</code> (circt::arc::MemoryOp)</a></li><li><a href=#arcmemory_read-circtarcmemoryreadop><code>arc.memory_read</code> (circt::arc::MemoryReadOp)</a></li><li><a href=#arcmemory_read_port-circtarcmemoryreadportop><code>arc.memory_read_port</code> (circt::arc::MemoryReadPortOp)</a></li><li><a href=#arcmemory_write-circtarcmemorywriteop><code>arc.memory_write</code> (circt::arc::MemoryWriteOp)</a></li><li><a href=#arcmemory_write_port-circtarcmemorywriteportop><code>arc.memory_write_port</code> (circt::arc::MemoryWritePortOp)</a></li><li><a href=#arcmodel-circtarcmodelop><code>arc.model</code> (circt::arc::ModelOp)</a></li><li><a href=#arcoutput-circtarcoutputop><code>arc.output</code> (circt::arc::OutputOp)</a></li><li><a href=#arcpassthrough-circtarcpassthroughop><code>arc.passthrough</code> (circt::arc::PassThroughOp)</a></li><li><a href=#arcroot_input-circtarcrootinputop><code>arc.root_input</code> (circt::arc::RootInputOp)</a></li><li><a href=#arcroot_output-circtarcrootoutputop><code>arc.root_output</code> (circt::arc::RootOutputOp)</a></li><li><a href=#arcsimemit-circtarcsimemitvalueop><code>arc.sim.emit</code> (circt::arc::SimEmitValueOp)</a></li><li><a href=#arcsimget_port-circtarcsimgetportop><code>arc.sim.get_port</code> (circt::arc::SimGetPortOp)</a></li><li><a href=#arcsiminstantiate-circtarcsiminstantiateop><code>arc.sim.instantiate</code> (circt::arc::SimInstantiateOp)</a></li><li><a href=#arcsimset_input-circtarcsimsetinputop><code>arc.sim.set_input</code> (circt::arc::SimSetInputOp)</a></li><li><a href=#arcsimstep-circtarcsimstepop><code>arc.sim.step</code> (circt::arc::SimStepOp)</a></li><li><a href=#arcstate-circtarcstateop><code>arc.state</code> (circt::arc::StateOp)</a></li><li><a href=#arcstate_read-circtarcstatereadop><code>arc.state_read</code> (circt::arc::StateReadOp)</a></li><li><a href=#arcstate_write-circtarcstatewriteop><code>arc.state_write</code> (circt::arc::StateWriteOp)</a></li><li><a href=#arcstorageget-circtarcstoragegetop><code>arc.storage.get</code> (circt::arc::StorageGetOp)</a></li><li><a href=#arctap-circtarctapop><code>arc.tap</code> (circt::arc::TapOp)</a></li><li><a href=#arcvectorize-circtarcvectorizeop><code>arc.vectorize</code> (circt::arc::VectorizeOp)</a></li><li><a href=#arcvectorizereturn-circtarcvectorizereturnop><code>arc.vectorize.return</code> (circt::arc::VectorizeReturnOp)</a></li><li><a href=#arczero_count-circtarczerocountop><code>arc.zero_count</code> (circt::arc::ZeroCountOp)</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#memorytype>MemoryType</a></li><li><a href=#simmodelinstancetype>SimModelInstanceType</a></li><li><a href=#statetype>StateType</a></li><li><a href=#storagetype>StorageType</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><h3 id=arcalloc_memory-circtarcallocmemoryop><code>arc.alloc_memory</code> (circt::arc::AllocMemoryOp)&nbsp;<a class=headline-hash href=#arcalloc_memory-circtarcallocmemoryop>¶</a></h3><p><em>Allocate a memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.alloc_memory` $storage attr-dict `:` functional-type($storage, $memory)
</code></pre><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>storage</code></td><td></td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td></td></tr></tbody></table><h3 id=arcalloc_state-circtarcallocstateop><code>arc.alloc_state</code> (circt::arc::AllocStateOp)&nbsp;<a class=headline-hash href=#arcalloc_state-circtarcallocstateop>¶</a></h3><p><em>Allocate internal state</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.alloc_state` $storage (`tap` $tap^)? attr-dict `:` functional-type($storage, $state)
</code></pre><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tap</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>storage</code></td><td></td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>state</code></td><td></td></tr></tbody></table><h3 id=arcalloc_storage-circtarcallocstorageop><code>arc.alloc_storage</code> (circt::arc::AllocStorageOp)&nbsp;<a class=headline-hash href=#arcalloc_storage-circtarcallocstorageop>¶</a></h3><p><em>Allocate contiguous storage space from a larger storage space</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.alloc_storage` $input (`[` $offset^ `]`)? attr-dict `:` functional-type($input, $output)
</code></pre><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td></td></tr></tbody></table><h3 id=arccall-circtarccallop><code>arc.call</code> (circt::arc::CallOp)&nbsp;<a class=headline-hash href=#arccall-circtarccallop>¶</a></h3><p><em>Calls an arc</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.call` $arc `(` $inputs `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>MemRefsNormalizable</code></p><p>Interfaces: <code>CallOpInterface</code>, <code>ClockedOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>arc</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=arcclock_domain-circtarcclockdomainop><code>arc.clock_domain</code> (circt::arc::ClockDomainOp)&nbsp;<a class=headline-hash href=#arcclock_domain-circtarcclockdomainop>¶</a></h3><p><em>A clock domain</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.clock_domain` ` ` `(` $inputs `)` `clock` $clock attr-dict `:`
              functional-type($inputs, results) $body
</code></pre><p>Traits: <code>IsolatedFromAbove</code>, <code>RecursiveMemoryEffects</code>, <code>SingleBlockImplicitTerminator&lt;arc::OutputOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>RegionKindInterface</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr><tr><td style=text-align:center><code>clock</code></td><td>A type for clock-carrying wires</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=arcclock_tree-circtarcclocktreeop><code>arc.clock_tree</code> (circt::arc::ClockTreeOp)&nbsp;<a class=headline-hash href=#arcclock_tree-circtarcclocktreeop>¶</a></h3><p><em>A clock tree</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.clock_tree` $clock attr-dict-with-keyword $body
</code></pre><p>Traits: <code>NoRegionArguments</code>, <code>NoTerminator</code></p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=arcdefine-circtarcdefineop><code>arc.define</code> (circt::arc::DefineOp)&nbsp;<a class=headline-hash href=#arcdefine-circtarcdefineop>¶</a></h3><p><em>State transfer arc definition</em></p><p>Traits: <code>HasParent&lt;mlir::ModuleOp></code>, <code>IsolatedFromAbove</code>, <code>SingleBlockImplicitTerminator&lt;arc::OutputOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>CallableOpInterface</code>, <code>FunctionOpInterface</code>, <code>RegionKindInterface</code>, <code>Symbol</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h3 id=arclut-circtarclutop><code>arc.lut</code> (circt::arc::LutOp)&nbsp;<a class=headline-hash href=#arclut-circtarclutop>¶</a></h3><p><em>A lookup-table.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.lut` `(` $inputs `)` `:` functional-type($inputs, $output)
              attr-dict-with-keyword $body
</code></pre><p>Represents a lookup-table as one operation. The operations that map the
lookup/input values to the corresponding table-entry are collected inside
the body of this operation.
Note that the operation is marked to be isolated from above to guarantee
that all input values have to be passed as an operand. This allows for
simpler analyses and canonicalizations of the LUT as well as lowering.
Only combinational operations are allowed inside the LUT, i.e., no
side-effects, state, time delays, etc.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>IsolatedFromAbove</code>, <code>SingleBlockImplicitTerminator&lt;arc::OutputOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless integer</td></tr></tbody></table><h3 id=arcmemory-circtarcmemoryop><code>arc.memory</code> (circt::arc::MemoryOp)&nbsp;<a class=headline-hash href=#arcmemory-circtarcmemoryop>¶</a></h3><p><em>Memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.memory` type($memory) attr-dict
</code></pre><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td></td></tr></tbody></table><h3 id=arcmemory_read-circtarcmemoryreadop><code>arc.memory_read</code> (circt::arc::MemoryReadOp)&nbsp;<a class=headline-hash href=#arcmemory_read-circtarcmemoryreadop>¶</a></h3><p><em>Read word from memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.memory_read` $memory `[` $address `]` attr-dict `:` type($memory)
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code>, <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td></td></tr><tr><td style=text-align:center><code>address</code></td><td>integer</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>integer</td></tr></tbody></table><h3 id=arcmemory_read_port-circtarcmemoryreadportop><code>arc.memory_read_port</code> (circt::arc::MemoryReadPortOp)&nbsp;<a class=headline-hash href=#arcmemory_read_port-circtarcmemoryreadportop>¶</a></h3><p><em>Read port from a memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.memory_read_port` $memory `[` $address `]` attr-dict `:` type($memory)
</code></pre><p>Represents a combinatorial memory read port. No memory read side-effect
trait is necessary because at the stage of the Arc lowering where this
operation is legal to be present, it is guaranteed that all reads from the
same address produce the same output. This is because all writes are
reordered to happen at the end of the cycle in LegalizeStateUpdates (or
alternatively produce the necessary temporaries).</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td></td></tr><tr><td style=text-align:center><code>address</code></td><td>integer</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>integer</td></tr></tbody></table><h3 id=arcmemory_write-circtarcmemorywriteop><code>arc.memory_write</code> (circt::arc::MemoryWriteOp)&nbsp;<a class=headline-hash href=#arcmemory_write-circtarcmemorywriteop>¶</a></h3><p><em>Write word to memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.memory_write` $memory `[` $address `]` `,` $data (`if` $enable^)?
              attr-dict `:` type($memory)
</code></pre><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td></td></tr><tr><td style=text-align:center><code>address</code></td><td>integer</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>data</code></td><td>integer</td></tr></tbody></table><h3 id=arcmemory_write_port-circtarcmemorywriteportop><code>arc.memory_write_port</code> (circt::arc::MemoryWritePortOp)&nbsp;<a class=headline-hash href=#arcmemory_write_port-circtarcmemorywriteportop>¶</a></h3><p><em>Write port to a memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.memory_write_port` $memory `,` $arc  `(` $inputs `)` (`clock` $clock^)?  (`enable` $enable^)?
              (`mask` $mask^)? `latency` $latency attr-dict `:`
              type($memory) `,` type($inputs)
</code></pre><p>Traits: <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>CallOpInterface</code>, <code>ClockedOpInterface</code>, <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>arc</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>enable</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>mask</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>latency</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td></td></tr><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr><tr><td style=text-align:center><code>clock</code></td><td>A type for clock-carrying wires</td></tr></tbody></table><h3 id=arcmodel-circtarcmodelop><code>arc.model</code> (circt::arc::ModelOp)&nbsp;<a class=headline-hash href=#arcmodel-circtarcmodelop>¶</a></h3><p><em>A model with stratified clocks</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.model` $sym_name `io` $io attr-dict-with-keyword $body
</code></pre><p>A model with stratified clocks. The <code>io</code> optional attribute
specifies the I/O of the module associated to this model.</p><p>Traits: <code>IsolatedFromAbove</code>, <code>NoTerminator</code></p><p>Interfaces: <code>RegionKindInterface</code>, <code>Symbol</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>io</code></td><td>::mlir::TypeAttr</td><td>type attribute of a module</td></tr></table><h3 id=arcoutput-circtarcoutputop><code>arc.output</code> (circt::arc::OutputOp)&nbsp;<a class=headline-hash href=#arcoutput-circtarcoutputop>¶</a></h3><p><em>Arc terminator</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.output` attr-dict ($outputs^ `:` qualified(type($outputs)))?
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;DefineOp, LutOp, ClockDomainOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=arcpassthrough-circtarcpassthroughop><code>arc.passthrough</code> (circt::arc::PassThroughOp)&nbsp;<a class=headline-hash href=#arcpassthrough-circtarcpassthroughop>¶</a></h3><p><em>Clock-less logic that is on the pass-through path</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.passthrough` attr-dict-with-keyword $body
</code></pre><p>Traits: <code>NoRegionArguments</code>, <code>NoTerminator</code></p><h3 id=arcroot_input-circtarcrootinputop><code>arc.root_input</code> (circt::arc::RootInputOp)&nbsp;<a class=headline-hash href=#arcroot_input-circtarcrootinputop>¶</a></h3><p><em>A root input</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.root_input` $name `,` $storage attr-dict `:` functional-type($storage, $state)
</code></pre><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>storage</code></td><td></td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>state</code></td><td></td></tr></tbody></table><h3 id=arcroot_output-circtarcrootoutputop><code>arc.root_output</code> (circt::arc::RootOutputOp)&nbsp;<a class=headline-hash href=#arcroot_output-circtarcrootoutputop>¶</a></h3><p><em>A root output</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.root_output` $name `,` $storage attr-dict `:` functional-type($storage, $state)
</code></pre><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>storage</code></td><td></td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>state</code></td><td></td></tr></tbody></table><h3 id=arcsimemit-circtarcsimemitvalueop><code>arc.sim.emit</code> (circt::arc::SimEmitValueOp)&nbsp;<a class=headline-hash href=#arcsimemit-circtarcsimemitvalueop>¶</a></h3><p><em>Sends a value to the simulation driver</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.sim.emit` $valueName `,` $value attr-dict `:` type($value)
</code></pre><p>Sends a named value to the simulation driver. This is notably useful
for printing values during simulation.</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>valueName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h3 id=arcsimget_port-circtarcsimgetportop><code>arc.sim.get_port</code> (circt::arc::SimGetPortOp)&nbsp;<a class=headline-hash href=#arcsimget_port-circtarcsimgetportop>¶</a></h3><p><em>Gets the value of a port of the model instance</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.sim.get_port` $instance `,` $port attr-dict
              `:` type($value) `,` qualified(type($instance))
</code></pre><p>Gets the value of the given port in a specific instance of a model. The
provided port must be of the type of the expected value.</p><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>port</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>instance</code></td><td></td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h3 id=arcsiminstantiate-circtarcsiminstantiateop><code>arc.sim.instantiate</code> (circt::arc::SimInstantiateOp)&nbsp;<a class=headline-hash href=#arcsiminstantiate-circtarcsiminstantiateop>¶</a></h3><p><em>Instantiates an Arc model for simulation</em></p><p>Creates an instance of an Arc model in scope, in order to simulate it.
The model can be used from within the associated region, modelling its
lifetime.</p><p>Traits: <code>NoTerminator</code></p><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</code></p><h3 id=arcsimset_input-circtarcsimsetinputop><code>arc.sim.set_input</code> (circt::arc::SimSetInputOp)&nbsp;<a class=headline-hash href=#arcsimset_input-circtarcsimsetinputop>¶</a></h3><p><em>Sets the value of an input of the model instance</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.sim.set_input` $instance `,` $input `=` $value attr-dict
              `:` type($value) `,` qualified(type($instance))
</code></pre><p>Sets the value of an input port in a specific instance of a model. The
provided input port must be of input type on the model and its type must
match the type of the value operand.</p><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>input</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>instance</code></td><td></td></tr><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h3 id=arcsimstep-circtarcsimstepop><code>arc.sim.step</code> (circt::arc::SimStepOp)&nbsp;<a class=headline-hash href=#arcsimstep-circtarcsimstepop>¶</a></h3><p><em>Evaluates one step of the simulation for the provided model instance</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.sim.step` $instance attr-dict `:` qualified(type($instance))
</code></pre><p>Evaluates one step of the simulation for the provided model instance,
updating ports accordingly.</p><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource, MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>instance</code></td><td></td></tr></tbody></table><h3 id=arcstate-circtarcstateop><code>arc.state</code> (circt::arc::StateOp)&nbsp;<a class=headline-hash href=#arcstate-circtarcstateop>¶</a></h3><p><em>State transfer arc</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.state` $arc `(` $inputs `)` (`clock` $clock^)? (`enable` $enable^)?
              (`reset` $reset^)? `latency` $latency attr-dict
              `:` functional-type($inputs, results)
</code></pre><p>Traits: <code>AttrSizedOperandSegments</code>, <code>MemRefsNormalizable</code></p><p>Interfaces: <code>CallOpInterface</code>, <code>ClockedOpInterface</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>arc</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>latency</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>reset</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=arcstate_read-circtarcstatereadop><code>arc.state_read</code> (circt::arc::StateReadOp)&nbsp;<a class=headline-hash href=#arcstate_read-circtarcstatereadop>¶</a></h3><p><em>Get a state&rsquo;s current value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.state_read` $state attr-dict `:` type($state)
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code>, <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>state</code></td><td></td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h3 id=arcstate_write-circtarcstatewriteop><code>arc.state_write</code> (circt::arc::StateWriteOp)&nbsp;<a class=headline-hash href=#arcstate_write-circtarcstatewriteop>¶</a></h3><p><em>Update a state&rsquo;s value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.state_write` $state `=` $value (`if` $condition^)? attr-dict `:` type($state)
</code></pre><p>Changes the value of a state. This operation is treated as a deferred
assignment by most transformation passes, which allows them to change the
order of <code>arc.state_read</code> and <code>arc.state_write</code> ops on the same state
without affecting the correctness of the model. The reads are always assumed
to produce the current value of the state and writes to be deferred until
all operations in the model have been executed for the current time step.</p><p>The only exceptions to this are the state update legalization pass, which
inserts the necessary temporary variables such that writes can be performed
immediately without affecting correctness. This allows later lowering passes
to treat <code>arc.state_write</code> as an immediate assignment (without defering).</p><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>state</code></td><td></td></tr><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr><tr><td style=text-align:center><code>condition</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=arcstorageget-circtarcstoragegetop><code>arc.storage.get</code> (circt::arc::StorageGetOp)&nbsp;<a class=headline-hash href=#arcstorageget-circtarcstoragegetop>¶</a></h3><p><em>Access an allocated state, memory, or storage slice</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.storage.get` $storage `[` $offset `]` attr-dict
              `:` qualified(type($storage)) `-&gt;` type($result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>storage</code></td><td></td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>or or</td></tr></tbody></table><h3 id=arctap-circtarctapop><code>arc.tap</code> (circt::arc::TapOp)&nbsp;<a class=headline-hash href=#arctap-circtarctapop>¶</a></h3><p><em>A tracker op to observe a value under a given name</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.tap` $value attr-dict `:` type($value)
</code></pre><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>signless integer</td></tr></tbody></table><h3 id=arcvectorize-circtarcvectorizeop><code>arc.vectorize</code> (circt::arc::VectorizeOp)&nbsp;<a class=headline-hash href=#arcvectorize-circtarcvectorizeop>¶</a></h3><p><em>Isolated subgraph of operations to be vectorized</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.vectorize` $inputs attr-dict `:` functional-type($inputs, $results) $body
</code></pre><p>This operation represents a vectorized computation DAG. It places a
convenient boundary between the subgraph to be vectorized and the
surrounding non-vectorizable parts of the original graph.</p><p>This allows us to split the vectorization transformations into multiple
parts/passes:</p><ul><li>Finding an initial set of operations to be vectorized</li><li>Optimizing this set by pulling in more operations into the nested block,
splitting it such that the vector width does not exceed a given limit,
applying a cost model and potentially reverting the decision to
vectorize this subgraph (e.g., because not enough ops could be pulled
in)</li><li>Performing the actual vectorization by lowering this operation. This
operation allows to perform the lowering of the boundary and the body
separately and either via 1D <code>vector</code> types for SIMD vectorization or
plain integers for manual vectorization within a scalar register.</li></ul><p>For each block argument of the nested block, there is a list of operands
that represent the elements of the vector. If the boundary is already
vectorized each list will only contain a single SSA value of either vector
type or an integer representing the concatenation of all original operands
of that vector.
Only integer types can be vectorized, no arrays or structs are allowed.</p><p>Example:</p><p>Given the following two AND operations in the IR</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> arith<span class=p>.</span>and <span class=nv>%in0</span><span class=p>,</span> <span class=nv>%in1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span>and <span class=nv>%in2</span><span class=p>,</span> <span class=nv>%in2</span> <span class=p>:</span> <span class=k>i1</span>
</span></span></code></pre></div><p>they could be vectorized by putting one such AND operation in the body block
of the <code>arc.vectorize</code> operation and forwarding the operands accordingly.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span><span class=p>:</span><span class=nl>2 =</span> arc<span class=p>.</span><span class=kt>vector</span>ize <span class=p>(</span><span class=nv>%in0</span><span class=p>,</span> <span class=nv>%in1</span><span class=p>),</span> <span class=p>(</span><span class=nv>%in2</span><span class=p>,</span> <span class=nv>%in2</span><span class=p>)</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>i1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span>and <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  arc<span class=p>.</span>output <span class=nv>%1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In a next step, the boundary could be lowered/vectorized. This can happen
in terms of integers for vectorization within scalar registers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> comb<span class=p>.</span>concat <span class=nv>%in0</span><span class=p>,</span> <span class=nv>%in1</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> comb<span class=p>.</span>replicate <span class=nv>%in2</span> <span class=p>:</span> <span class=p>(</span><span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i2</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> arc<span class=p>.</span><span class=kt>vector</span>ize <span class=p>(</span><span class=nv>%0</span><span class=p>),</span> <span class=p>(</span><span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i2</span><span class=p>,</span> <span class=k>i2</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>i1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span>and <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  arc<span class=p>.</span>output <span class=nv>%1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> comb<span class=p>.</span>extract <span class=nv>%2</span> from <span class=m>1</span> <span class=p>:</span> <span class=p>(</span><span class=k>i2</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> comb<span class=p>.</span>extract <span class=nv>%2</span> from <span class=m>0</span> <span class=p>:</span> <span class=p>(</span><span class=k>i2</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>
</span></span></code></pre></div><p>Or via <code>vector</code> types for SIMD vectorization:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%cst</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> dense<span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>insert <span class=nv>%in0</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=k>i1</span> into <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>insert <span class=nv>%in1</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=k>i1</span> into <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>broadcast <span class=nv>%in2</span> <span class=p>:</span> <span class=k>i1</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> arc<span class=p>.</span><span class=kt>vector</span>ize <span class=p>(</span><span class=nv>%1</span><span class=p>),</span> <span class=p>(</span><span class=nv>%2</span><span class=p>)</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>i1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span>and <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  arc<span class=p>.</span>output <span class=nv>%1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>extract <span class=nv>%2</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>extract <span class=nv>%2</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Alternatively, the body could be vectorized first. Again, as integers</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span><span class=p>:</span><span class=nl>2 =</span> arc<span class=p>.</span><span class=kt>vector</span>ize <span class=p>(</span><span class=nv>%in0</span><span class=p>,</span> <span class=nv>%in1</span><span class=p>),</span> <span class=p>(</span><span class=nv>%in2</span><span class=p>,</span> <span class=nv>%in2</span><span class=p>)</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i2</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>i2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span>and <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>i2</span>
</span></span><span class=line><span class=cl>  arc<span class=p>.</span>output <span class=nv>%1</span> <span class=p>:</span> <span class=k>i2</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>or SIMD vectors.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span><span class=p>:</span><span class=nl>2 =</span> arc<span class=p>.</span><span class=kt>vector</span>ize <span class=p>(</span><span class=nv>%in0</span><span class=p>,</span> <span class=nv>%in1</span><span class=p>),</span> <span class=p>(</span><span class=nv>%in2</span><span class=p>,</span> <span class=nv>%in3</span><span class=p>)</span> <span class=p>:</span> 
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;):</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span>and <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  arc<span class=p>.</span>output <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Once both sides are lowered, the <code>arc.vectorize</code> op simply becomes a
passthrough for the operands and can be removed by inlining the nested
block. The integer based vectorization would then look like the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> comb<span class=p>.</span>concat <span class=nv>%in0</span><span class=p>,</span> <span class=nv>%in1</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> comb<span class=p>.</span>replicate <span class=nv>%in2</span> <span class=p>:</span> <span class=p>(</span><span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i2</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> arith<span class=p>.</span>and <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i2</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> comb<span class=p>.</span>extract <span class=nv>%2</span> from <span class=m>1</span> <span class=p>:</span> <span class=p>(</span><span class=k>i2</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> comb<span class=p>.</span>extract <span class=nv>%2</span> from <span class=m>0</span> <span class=p>:</span> <span class=p>(</span><span class=k>i2</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>
</span></span></code></pre></div><p>The SIMD vector based lowering would result in the following IR:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%cst</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> dense<span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>insert <span class=nv>%in0</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=k>i1</span> into <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>insert <span class=nv>%in1</span><span class=p>,</span> <span class=nv>%0</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=k>i1</span> into <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>broadcast <span class=nv>%in2</span> <span class=p>:</span> <span class=k>i1</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> arith<span class=p>.</span>and <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>extract <span class=nv>%3</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>extract <span class=nv>%3</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>IsolatedFromAbove</code>, <code>RecursiveMemoryEffects</code></p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inputOperandSegments</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr></table><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of signless integer or vector of signless integer values of ranks 1</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of signless integer or vector of signless integer values of ranks 1</td></tr></tbody></table><h3 id=arcvectorizereturn-circtarcvectorizereturnop><code>arc.vectorize.return</code> (circt::arc::VectorizeReturnOp)&nbsp;<a class=headline-hash href=#arcvectorizereturn-circtarcvectorizereturnop>¶</a></h3><p><em>Arc.vectorized terminator</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.vectorize.return` operands attr-dict `:` qualified(type(operands))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;VectorizeOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>signless integer or vector of signless integer values of ranks 1</td></tr></tbody></table><h3 id=arczero_count-circtarczerocountop><code>arc.zero_count</code> (circt::arc::ZeroCountOp)&nbsp;<a class=headline-hash href=#arczero_count-circtarczerocountop>¶</a></h3><p><em>Leading/trailing zero count operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arc.zero_count` $predicate $input attr-dict `:` type($input)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>circt::arc::ZeroCountPredicateAttr</td><td>arc.zero_count predicate</td></tr></table><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless integer</td></tr></tbody></table><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><h3 id=memorytype>MemoryType&nbsp;<a class=headline-hash href=#memorytype>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>!arc.memory&lt;
  unsigned,   # numWords
  ::mlir::IntegerType,   # wordType
  ::mlir::IntegerType   # addressType
&gt;
</code></pre><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>numWords</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>wordType</td><td style=text-align:center><code>::mlir::IntegerType</code></td><td></td></tr><tr><td style=text-align:center>addressType</td><td style=text-align:center><code>::mlir::IntegerType</code></td><td></td></tr></tbody></table><h3 id=simmodelinstancetype>SimModelInstanceType&nbsp;<a class=headline-hash href=#simmodelinstancetype>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>!arc.sim.instance&lt;
  mlir::FlatSymbolRefAttr   # model
&gt;
</code></pre><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>model</td><td style=text-align:center><code>mlir::FlatSymbolRefAttr</code></td><td></td></tr></tbody></table><h3 id=statetype>StateType&nbsp;<a class=headline-hash href=#statetype>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>!arc.state&lt;
  ::mlir::Type   # type
&gt;
</code></pre><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=storagetype>StorageType&nbsp;<a class=headline-hash href=#storagetype>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>!arc.storage&lt;
  unsigned   # size
&gt;
</code></pre><h4 id=parameters-3>Parameters:&nbsp;<a class=headline-hash href=#parameters-3>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>size</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/ESIAppID/ title><i class="fas fa-arrow-left" aria-hidden=true></i> Prev -</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/Calyx/ title="'calyx' Dialect">Next - 'calyx' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li class=active><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>