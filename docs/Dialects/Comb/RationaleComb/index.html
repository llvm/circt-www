<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>`comb` Dialect Rationale - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>`comb` Dialect Rationale</h1><p>This document describes various design points of the Comb dialect, a common
dialect that is typically used in conjunction with the <code>hw</code> and <code>sv</code> dialects.
Please see the
<a href=RationaleHW.md><code>hw</code> Dialect Rationale</a> for high level insight
on how these work together. This follows in the spirit of
other
<a href=https://mlir.llvm.org/docs/Rationale/>MLIR Rationale docs</a>.</p><ul><li><a href=#comb-dialect-rationale><code>comb</code> Dialect Rationale</a><ul><li><a href=#introduction-to-the-comb-dialect>Introduction to the <code>comb</code> Dialect</a></li><li><a href=#type-system-for-comb-dialect>Type System for <code>comb</code> Dialect</a><ul><li><a href=#zero-bit-integer-width-is-not-supported>Zero-bit integer width is not supported</a></li></ul></li><li><a href=#comb-operations>Comb Operations</a><ul><li><a href=#fully-associative-operations-are-variadic>Fully associative operations are variadic</a></li><li><a href=#operators-carry-signs-instead-of-types>Operators carry signs instead of types</a></li><li><a href=#no-implicit-extensions-of-operands>No implicit extensions of operands</a></li><li><a href=#no-complement-negate-zext-sext-operators>No &ldquo;Complement&rdquo;, &ldquo;Negate&rdquo;, &ldquo;ZExt&rdquo;, &ldquo;SExt&rdquo;, Operators</a></li><li><a href=#no-multibit-mux-operations>No multibit mux operations</a></li></ul></li><li><a href=#endianness-operand-ordering-and-internal-representation>Endianness: operand ordering and internal representation</a></li><li><a href=#bitcasts>Bitcasts</a></li><li><a href=#cost-model>Cost Model</a></li></ul></li></ul><h2 id=introduction-to-the-comb-dialect>Introduction to the <code>comb</code> Dialect&nbsp;<a class=headline-hash href=#introduction-to-the-comb-dialect>¶</a></h2><p>The <code>comb</code> dialect provides a collection of operations that define a mid-level
compiler IR for combinational logic. It is <em>not</em> designed to model
SystemVerilog or any other hardware design language directly. Instead, it is
designed to be easy to analyze and transform, and be a flexible and extensible
substrate that may be extended with higher level dialects mixed into it.</p><h2 id=type-system-for-comb-dialect>Type System for <code>comb</code> Dialect&nbsp;<a class=headline-hash href=#type-system-for-comb-dialect>¶</a></h2><p>TODO: Simple integer types, eventually parametrically wide integer type
<code>hw.int&lt;width></code>. Supports type aliases. See HW rationale for more info.</p><h3 id=zero-bit-integer-width-is-not-supported>Zero-bit integer width is not supported&nbsp;<a class=headline-hash href=#zero-bit-integer-width-is-not-supported>¶</a></h3><p>Combinational operations like add and multiply work on values of signless
standard integer types, e.g. <code>i42</code>, but they do not allow zero bit inputs. This
design point is motivated by a couple of reasons:</p><ol><li><p>The semantics of some operations (e.g. <code>comb.sext</code>) do not have an obvious
definition with a zero bit input.</p></li><li><p>Zero bit operations are useless for operations that are definable, and their
presence makes the compiler more complicated.</p></li></ol><p>On the second point, consider an example like <code>comb.mux</code> which could allow zero
bit inputs and therefore produce zero bit results. Allowing that as a design
point would require us to special case this in our cost models, and we would
have that optimizes it away.</p><p>By rejecting zero bit operations, we choose to put the complexity into the
lowering passes that generate the HW dialect (e.g. LowerToHW from FIRRTL).</p><p>Note that this decision only affects the core operations in the <code>comb</code> dialect
itself - it is perfectly reasonable to define your operations and mix them into
other <code>comb</code> constructs.</p><h2 id=comb-operations>Comb Operations&nbsp;<a class=headline-hash href=#comb-operations>¶</a></h2><p>This section contains notes about design decisions relating to
operations in the <code>comb</code> dialect.</p><h3 id=fully-associative-operations-are-variadic>Fully associative operations are variadic&nbsp;<a class=headline-hash href=#fully-associative-operations-are-variadic>¶</a></h3><p>TODO: describe why add/xor/or are variadic</p><h3 id=operators-carry-signs-instead-of-types>Operators carry signs instead of types&nbsp;<a class=headline-hash href=#operators-carry-signs-instead-of-types>¶</a></h3><p>TODO: describe why we have divu/divs but not addu/adds, and not sint vs uint.</p><h3 id=no-implicit-extensions-of-operands>No implicit extensions of operands&nbsp;<a class=headline-hash href=#no-implicit-extensions-of-operands>¶</a></h3><p>Verilog and many other HDL&rsquo;s allow operators like <code>+</code> to work with
mixed size operands, and some have complicated contextual rules about how wide
the result is (e.g. adding two 12 bit integers gives you a 13 bit result).</p><p>While this is convenient for source programmers, this makes the job of compiler
analysis and optimization extremely challenging: peephole optimizations and
dataflow transformations need to reason about these pervasively. Because the
<code>comb</code> dialect is designed as a &ldquo;mid-level&rdquo; dialect focused on optimization,
it doesn&rsquo;t allow implicit extensions: for example, <code>comb.add</code> takes the same
width inputs and returns the same width result.</p><p>There is room in the future for other points in the design space: for example,
it might be useful to add an <code>sv.add</code> operation that allows mixed operands to
get better separation of concerns in the Verilog printer if we wanted really
fancy extension elision. So far, very simple techniques have been enough to get
reasonable output.</p><h3 id=no-complement-negate-zext-sext-operators>No &ldquo;Complement&rdquo;, &ldquo;Negate&rdquo;, &ldquo;ZExt&rdquo;, &ldquo;SExt&rdquo;, Operators&nbsp;<a class=headline-hash href=#no-complement-negate-zext-sext-operators>¶</a></h3><p>We choose to omit several operators that you might expect, in order to make the
IR more regular, easy to transform, and have fewer canonical forms.</p><ul><li><p>No <code>~x</code> complement or <code>-x</code> negation operator: instead use <code>comb.xor(x, -1)</code>.
or <code>comb.sub(0, x)</code> respectively. These avoid having to duplicate many folds
between <code>xor</code> and <code>sub</code>.</p></li><li><p>No zero extension operator to add high zero bits. This is strictly redundant
with <code>concat(zero, value)</code>.</p></li><li><p>No sign extension operator to add high sign bits. <code>sext(x)</code> is strictly
redundant with <code>concat(replicate(extract(x, highbit)), x)</code>.</p></li></ul><p>The absence of these operations doesn&rsquo;t affect the expressive ability of the IR,
and ExportVerilog will notice these and generate the compact Verilog syntax
e.g. a complement or negate when needed.</p><h3 id=no-multibit-mux-operations>No multibit mux operations&nbsp;<a class=headline-hash href=#no-multibit-mux-operations>¶</a></h3><p>The comb dialect in CIRCT doesn&rsquo;t have a first-class multibit mux. Instead we
prefer to use two array operations to represent this. For example, consider
a 3-bit condition:</p><pre tabindex=0><code> hw.module @multibit_mux(%a: i32, %b: i32, %c: i32, %idx: i3) -&gt; (%out: i32) {
   %x_i32 = sv.constantX : i32
   %tmpArray = hw.array_create %a, %b, %x_i32, %b, %c, %x_i32 : i32
   %result   = hw.array_get %tmpArray[%idx] : !hw.array&lt;6xi32&gt;
   hw.output %result: i32
 }
</code></pre><p>This gets lowered into (something like) this Verilog:</p><pre tabindex=0><code>module multibit_mux(
  input  [31:0] a, b, c,
  input  [2:0]  idx,
  output [31:0] out);

  wire [5:0][31:0] _T = {{a}, {b}, {32&#39;bx}, {b}, {c}, {32&#39;bx}};
  assign out = _T[idx];
endmodule
</code></pre><p>In this example, the last X element could be dropped and generate
equivalent code.</p><p>We believe that synthesis tools handle the correctly and generate efficient
netlists. For those that don&rsquo;t (e.g. Yosys), we have a <code>disallowPackedArrays</code>
LoweringOption that legalizes away multi-dimensional arrays as part of lowering.</p><p>While we could use the same approach for single-bit muxes, we choose to have a
single bit <code>comb.mux</code> operation for a few reasons:</p><ul><li>This is extremely common in hardware, and using 2x the memory to represent
the IR would be wasteful.</li><li>This are many peephole and other optimizations that apply to it.</li></ul><p>We discussed these design points at length in an
<a href="https://docs.google.com/document/d/1fOSRdyZR2w75D87yU2Ma9h2-_lEPL4NxvhJGJd-s5pk/edit#heading=h.ygmlwiic5e1y">August 11, 2021 design
meeting</a>, and
discussed the tradeoffs of adding support for a single-operation mux. Such a
move has some advantages and disadvantages:</p><ol><li>It is another operation that many transformations would need to be aware of,
e.g. Verilog emission would have to handle it, and peephole optimizations
would have to be aware of <code>array_get</code> and <code>comb.mux</code>.</li><li>We don&rsquo;t have any known analyses or optimizations that are difficult to
implement with the current representation.</li></ol><p>We agreed that we&rsquo;d revisit in the future if there were a specific reason to
add it. Until then we represent the <code>array_create</code>/<code>array_get</code> pattern for
frontends that want to generate this.</p><h2 id=endianness-operand-ordering-and-internal-representation>Endianness: operand ordering and internal representation&nbsp;<a class=headline-hash href=#endianness-operand-ordering-and-internal-representation>¶</a></h2><p>Certain operations require ordering to be defined (i.e. <code>comb.concat</code>,
<code>hw.array_concat</code>, and <code>hw.array_create</code>). There are two places where this
is relevant: in the MLIR assembly and in the MLIR C++ model.</p><p>In MLIR assembly, operands are always listed MSB to LSB (big endian style):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%msb</span> <span class=p>=</span> comb<span class=p>.</span><span class=kt>constant</span> <span class=m>0xEF</span> <span class=p>:</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl><span class=nv>%mid</span> <span class=p>=</span> comb<span class=p>.</span><span class=kt>constant</span> <span class=m>0x7</span> <span class=p>:</span> <span class=k>i4</span>
</span></span><span class=line><span class=cl><span class=nv>%lsb</span> <span class=p>=</span> comb<span class=p>.</span><span class=kt>constant</span> <span class=m>0xA018</span> <span class=p>:</span> <span class=k>i16</span>
</span></span><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> comb<span class=p>.</span>concat <span class=nv>%msb</span><span class=p>,</span> <span class=nv>%mid</span><span class=p>,</span> <span class=nv>%lsb</span> <span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i4</span><span class=p>,</span> <span class=k>i16</span>
</span></span><span class=line><span class=cl><span class=c>// %result is 0xEF7A018
</span></span></span></code></pre></div><p><strong>Note</strong>: Integers are always written in left-to-right lexical order. Operand
ordering for <code>concat.concat</code> was chosen to be consistent with simply abutting
them in lexical order.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> comb<span class=p>.</span><span class=kt>constant</span> <span class=m>0x1</span> <span class=p>:</span> <span class=k>i4</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> comb<span class=p>.</span><span class=kt>constant</span> <span class=m>0x2</span> <span class=p>:</span> <span class=k>i4</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> comb<span class=p>.</span><span class=kt>constant</span> <span class=m>0x3</span> <span class=p>:</span> <span class=k>i4</span>
</span></span><span class=line><span class=cl><span class=nv>%arr123</span> <span class=p>=</span> hw<span class=p>.</span>array_create <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=k>i4</span>
</span></span><span class=line><span class=cl><span class=c>// %arr123[0] = 0x3
</span></span></span><span class=line><span class=cl><span class=c>// %arr123[1] = 0x2
</span></span></span><span class=line><span class=cl><span class=c>// %arr123[2] = 0x1
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>%arr456</span> <span class=p>=</span> <span class=p>...</span> <span class=c>// {0x4, 0x5, 0x6}
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%arr78</span>  <span class=p>=</span> <span class=p>...</span> <span class=c>// {0x7, 0x8}
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%arr</span> <span class=p>=</span> comb<span class=p>.</span>array_concat <span class=nv>%arr123</span><span class=p>,</span> <span class=nv>%arr456</span><span class=p>,</span> <span class=nv>%arr78</span> <span class=p>:</span> <span class=p>!</span>hw<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3 x</span> <span class=k>i4</span><span class=p>&gt;,</span> <span class=p>!</span>hw<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3 x</span> <span class=k>i4</span><span class=p>&gt;,</span> <span class=p>!</span>hw<span class=p>.</span>array<span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i4</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// %arr[0] = 0x8
</span></span></span><span class=line><span class=cl><span class=c>// %arr[1] = 0x7
</span></span></span><span class=line><span class=cl><span class=c>// %arr[2] = 0x6
</span></span></span><span class=line><span class=cl><span class=c>// %arr[3] = 0x5
</span></span></span><span class=line><span class=cl><span class=c>// %arr[4] = 0x4
</span></span></span><span class=line><span class=cl><span class=c>// %arr[5] = 0x3
</span></span></span><span class=line><span class=cl><span class=c>// %arr[6] = 0x2
</span></span></span><span class=line><span class=cl><span class=c>// %arr[7] = 0x1
</span></span></span></code></pre></div><p><strong>Note</strong>: This ordering scheme is unintuitive for anyone expecting C
array-like ordering. In C, arrays are laid out with index 0 as the least
significant value and the first element (lexically) in the array literal. In
the CIRCT <em>model</em> (assembly and C++ of the operation creating the array), it
is the opposite &ndash; the most significant value is on the left (e.g. the first
operand is the most significant). The indexing semantics at runtime, however,
differ in that the element zero is the least significant (which is lexically
on the right).</p><p>In the CIRCT C++ model, lists of values are in lexical order. That is, index
zero of a list is the leftmost operand in assembly, which is the most
significant value.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>ConcatOp</span> <span class=n>result</span> <span class=o>=</span> <span class=n>builder</span><span class=p>.</span><span class=n>create</span><span class=o>&lt;</span><span class=n>ConcatOp</span><span class=o>&gt;</span><span class=p>(...,</span> <span class=p>{</span><span class=n>msb</span><span class=p>,</span> <span class=n>lsb</span><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=c1>// Is equivalent to the above integer concatenation example.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ArrayConcatOp</span> <span class=n>arr</span> <span class=o>=</span> <span class=n>builder</span><span class=p>.</span><span class=n>create</span><span class=o>&lt;</span><span class=n>ArrayConcatOp</span><span class=o>&gt;</span><span class=p>(...,</span> <span class=p>{</span><span class=n>arr123</span><span class=p>,</span> <span class=n>arr456</span><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=c1>// Is equivalent to the above array example.
</span></span></span></code></pre></div><p><strong>Array slicing and indexing</strong> (<code>array_get</code>) operations both have indexes as
operands. These indexes are the <em>runtime</em> index, <strong>not</strong> the index in the
operand list which created the array upon which the op is running.</p><h2 id=bitcasts>Bitcasts&nbsp;<a class=headline-hash href=#bitcasts>¶</a></h2><p>The bitcast operation represents a bitwise reinterpretation (cast) of a value.
This always synthesizes away in hardware, though it may or may not be
syntactically represented in lowering or export language. Since bitcasting
requires information on the bitwise layout of the types on which it operates,
we discuss that here. All of the types are <em>packed</em>, meaning there is never
padding or alignment.</p><ul><li><strong>Integer bit vectors</strong>: MLIR&rsquo;s <code>IntegerType</code> with <code>Signless</code> semantics are
used to represent bit vectors. They are never padded or aligned.</li><li><strong>Arrays</strong>: The HW dialect defines a custom <code>ArrayType</code>. The in-hardware
layout matches C &ndash; the high index of array starts at the MSB. Array&rsquo;s 0th
element&rsquo;s LSB located at array LSB.</li><li><strong>Structs</strong>: The HW dialect defines a custom <code>StructType</code>. The in-hardware
layout matches C &ndash; the first listed member&rsquo;s MSB corresponds to the struct&rsquo;s
MSB. The last member in the list shares its LSB with the struct.</li><li><strong>Unions</strong>: The HW dialect&rsquo;s <code>UnionType</code> could contain the data of any of the
member types so its layout is defined to be equivalent to the union of members
type bitcast layout. In cases where the member types have different bit widths,
all members start at the 0th bit and are padded up to the width of the widest
member. The value with which they are padded is undefined.</li></ul><p><strong>Example figure</strong></p><pre tabindex=0><code>15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 
-------------------------------------------------
| MSB                                       LSB | 16 bit integer vector
-------------------------------------------------
                         | MSB              LSB | 8 bit integer vector
-------------------------------------------------
| MSB      [1]       LSB | MSB     [0]      LSB | 2 element array of 8 bit integer vectors
-------------------------------------------------

      13 12 11 10  9  8  7  6  5  4  3  2  1  0 
                            ---------------------
                            | MSB           LSB | 7 bit integer vector
      -------------------------------------------
      | MSB     [1]     LSB | MSB    [0]    LSB | 2 element array of 7 bit integer vectors
      -------------------------------------------
      | MSB a LSB | MSB b[1] LSB | MSB b[0] LSB | struct
      -------------------------------------------  a: 4 bit integral
                                                   b: 2 element array of 5 bit integer vectors
</code></pre><h2 id=cost-model>Cost Model&nbsp;<a class=headline-hash href=#cost-model>¶</a></h2><p>As a very general mid-level IR, it is important to define the principles that
canonicalizations and other general purpose transformations should optimize for.
There are often many different ways to represent a piece of logic in the IR, and
things will work better together if we keep the compiler consistent.</p><p>First, unlike something like LLVM IR, keep in mind that the HW dialect is a
model of hardware &ndash; each operation generally corresponds to an instance of
hardware, it is not an &ldquo;instruction&rdquo; that is executed by an imperative CPU.
As such, the primary concerns are area and latency (and size of generated
Verilog), not &ldquo;number of operations executed&rdquo;. As such, here are important
concerns that general purpose
transformations should consider, ordered from most important to least important.</p><p><strong>Simple transformations are always profitable</strong></p><p>Many simple transformations are always a good thing, this includes:</p><ol><li>Constant folding.</li><li>Simple strength reduction (e.g. divide to shift).</li><li>Common subexpression elimination.</li></ol><p>These generally reduce the size of the IR in memory, can reduce the area of a
synthesized design, and often unblock secondary transformations.</p><p><strong>Reducing widths of non-trivial operations is always profitable</strong></p><p>It is always a good idea to reduce the width of non-trivial operands like add,
multiply, shift, divide, <code>and</code>, <code>or</code> (etc) since it produces less hardware and
enables other simplifications.</p><p>That said, it is a bad idea to <em>duplicate</em> operations to reduce widths: for
example, it is better to have one large multiply with many users than to clone
it because one user only needs some of the output bits.</p><p>It is also beneficial to reduce widths, even if it adds truncations or
extensions in the IR (because they are &ldquo;just wires&rdquo;). However, there are limits:
any and-by-constant could be lowered to a concat of each bit principle,
e.g. it is legal to turn <code>and(x, 9)</code> into <code>concat(x[3], 00, x[0])</code>. Doing so is
considered unprofitable though, because it bloats the IR (and generated
Verilog).</p><p><strong>Don&rsquo;t get overly tricky with divide and remainder</strong></p><p>Divide operations (particularly those with non-constant divisors) generate a lot
of hardware, and can have long latencies. As such, it is a generally bad idea
to do anything to an individual instance of a divide that can increase its
latency (e.g. merging a narrow divide with a wider divide and using a subset of
the result bits).</p><p><strong>Constants and moving bits around is free</strong></p><p>The following are considered &ldquo;free&rdquo; for area and latency concerns:</p><ol><li><code>hw.constant</code></li><li>concatenation (including zero/sign extension idioms) and truncation</li><li><code>comb.and</code> and <code>comb.or</code> with a constant.</li><li>Other similar operations that do not synthesize into hardware.</li></ol><p>All things being equal it is good to reduce the number of instances of these (to
reduce IR size and increase canonical form) but it is ok to introduce more of
these to improve on other metrics above.</p><p><strong>Ordering Concat and Extract</strong></p><p>The<code>concat(extract(..))</code> form is preferred over the <code>extract(concat(..))</code> form,
because</p><ul><li><code>extract</code> gets &ldquo;closer&rdquo; to underlying <code>add/sub/xor/op</code> operations, giving way
optimizations like narrowing.</li><li>the form gives a more accurate view of the values that are being depended on.</li><li>redundant extract operations can be removed from the concat argument lists,
e.g.:
<code>cat(extract(a), b, c, extract(d))</code></li></ul><p>Both forms perform similarly on hardware, since they are simply bit-copies.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/Comb/ title="'comb' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'comb' Dialect</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/ESI/ title="'esi' Dialect">Next - 'esi' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark opened">-</span></a><ul class=sub-menu><li class=active><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li></ul></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/>PyCDE</a></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>