<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>'comb' Dialect on CIRCT</title><link>https://circt.llvm.org/docs/Dialects/Comb/</link><description>Recent content in 'comb' Dialect on CIRCT</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Jan 1970 00:00:00 +0000</lastBuildDate><atom:link href="https://circt.llvm.org/docs/Dialects/Comb/index.xml" rel="self" type="application/rss+xml"/><item><title>`comb` Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/</guid><description>This document describes various design points of the Comb dialect, a common dialect that is typically used in conjunction with the hw and sv dialects. Please see the hw Dialect Rationale for high level insight on how these work together. This follows in the spirit of other MLIR Rationale docs.
comb Dialect Rationale Introduction to the comb Dialect Type System for comb Dialect Zero-bit integer width is not supported Comb Operations Fully associative operations are variadic Operators carry signs instead of types No implicit extensions of operands No &amp;ldquo;Complement&amp;rdquo;, &amp;ldquo;Negate&amp;rdquo;, &amp;ldquo;ZExt&amp;rdquo;, &amp;ldquo;SExt&amp;rdquo;, Operators No multibit mux operations Endianness: operand ordering and internal representation Bitcasts Cost Model Introduction to the comb Dialect The comb dialect provides a collection of operations that define a mid-level compiler IR for combinational logic.</description></item></channel></rss>