<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Debug Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/Debug/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>Debug Dialect</h1><p>This dialect provides operations and types to interleave debug information (DI)
with other parts of the IR.</p><p><nav id=TableOfContents><ul><li><a href=#rationale>Rationale</a><ul><li><a href=#representations>Representations</a></li></ul></li><li><a href=#representing-source-language-constructs>Representing Source Language Constructs</a></li><li><a href=#tracking-inlined-modules>Tracking Inlined Modules</a></li><li><a href=#types>Types</a><ul><li><a href=#overview>Overview</a></li><li><a href=#arraytype>ArrayType</a></li><li><a href=#scopetype>ScopeType</a></li><li><a href=#structtype>StructType</a></li></ul></li><li><a href=#operations>Operations</a><ul><li><a href=#dbgarray-circtdebugarrayop><code>dbg.array</code> (circt::debug::ArrayOp)</a></li><li><a href=#dbgscope-circtdebugscopeop><code>dbg.scope</code> (circt::debug::ScopeOp)</a></li><li><a href=#dbgstruct-circtdebugstructop><code>dbg.struct</code> (circt::debug::StructOp)</a></li><li><a href=#dbgvariable-circtdebugvariableop><code>dbg.variable</code> (circt::debug::VariableOp)</a></li></ul></li></ul></nav><h2 id=rationale>Rationale&nbsp;<a class=headline-hash href=#rationale>¶</a></h2><p>The main goal of the debug dialect is to provide a mechanism to track the
correspondence between values, types, and hierarchy of a source language and the
IR being compiled and transformed. This allows simulators, synthesizers, and
other debugging tools to reconstruct a source language view into the processed
hardware and allow for easier debugging by humans.</p><p>Debug information in CIRCT follows these principles:</p><ul><li><p><strong>It is best effort:</strong> DI is meant as a tool to aid humans in their debugging
effort, not a contractual obligation to retain all source language semantics
through the compilation pipeline. We preserve information as well as possible
and reasonable, but accept the fact that certain optimizations may cause
information to be discarded.</p></li><li><p><strong>It affects the output:</strong> Enabling the tracking of DI is expected to block
certain optimizations. We undertake an effort to minimize the impact of DI on
the output quality, size, simulation speed, or synthesis results, but accept
the fact that preserving visibility and observability of source language
constructs may prevent certain optimizations from running.</p></li></ul><h3 id=representations>Representations&nbsp;<a class=headline-hash href=#representations>¶</a></h3><p>There are two mechanisms in MLIR that lend themselves to conveying debug
information:</p><ul><li><p><strong>Attributes</strong> attached to existing operations. This is similar to LLVM&rsquo;s
approach of tracking DI in the operation&rsquo;s metadata. Translated to MLIR, an
operation&rsquo;s location would be an obvious choice to do this tracking, since
locations are well-preserved by passes and difficult to accidentally drop.
MLIR currently does not support custom location attributes, which would
require DI attributes to be attached to a <code>FusedLoc</code> as metadata.</p></li><li><p><strong>Operations</strong> interleaved with the rest of the IR. This makes DI a
first-class citizen, but also causes debug information to potentially intefere
with optimizations. For example, debug dialect ops introduce additional uses
of values that might have otherwise been deleted by DCE. However, there may be
alternative ways to dealing with such situations. For example, Verilog
emission may simply ignore operations that are only used by debug ops,
therefore achieving the same effect as DCE would have.</p></li></ul><p>The debug dialect uses <em>operations</em> to represent debug info. This decision was
based on discussions with various people in the LLVM and MLIR community, where
DI was commonly quoted as one of LLVM&rsquo;s weak points, with its living in metadata
space making it more of a second-class citizen rather than a first-class
concern. Since we want to represent source language types and constructs as
accurately as possible, and we want to track if values are type-lowered,
constant-folded, outlined, or adjusted in some other way, using operations seems
like a natural choice. MLIR ops already have all the machinery needed to refer
to values in the IR, and many passes will already do the right thing with them.</p><h2 id=representing-source-language-constructs>Representing Source Language Constructs&nbsp;<a class=headline-hash href=#representing-source-language-constructs>¶</a></h2><p>The <code>dbg.variable</code> op is the key mechanism to establish a mapping between
high-level source language values and low-level values in the IR that are
transformed by the compiler. Consider the following source language pseudocode:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plain data-lang=plain><span class=line><span class=cl>struct Req {
</span></span><span class=line><span class=cl>  data: i42,
</span></span><span class=line><span class=cl>  valid: i1,
</span></span><span class=line><span class=cl>  ready: &amp;i1,
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>struct Resp {
</span></span><span class=line><span class=cl>  result: i42,
</span></span><span class=line><span class=cl>  done: i1,
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>module Foo {
</span></span><span class=line><span class=cl>  parameter Depth: uint;
</span></span><span class=line><span class=cl>  const Width: uint = 2**Depth;
</span></span><span class=line><span class=cl>  input req: Req;
</span></span><span class=line><span class=cl>  output resps: Resp[2];
</span></span><span class=line><span class=cl>  let x = req;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>A frontend for this language could generate the following debug variables as
part of the body of module <code>Foo</code>, in order to track the structs, arrays,
parameters, constants, and local bindings present in the source language:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>hw<span class=p>.</span>module <span class=nf>@Foo_Width12</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  in <span class=nv>%req_data</span><span class=p>:</span> <span class=k>i42</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  in <span class=nv>%req_valid</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  out req_ready<span class=p>:</span> <span class=k>i1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  out resps0_result<span class=p>:</span> <span class=k>i42</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  out resps0_done<span class=p>:</span> <span class=k>i1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  out resps1_result<span class=p>:</span> <span class=k>i42</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  out resps1_done<span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// %req_ready = ...
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// %resps0_result = ...
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// %resps0_done = ...
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// %resps1_result = ...
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// %resps1_done = ...
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl>  <span class=c>// parameter Depth
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%c12_i32</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>12</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  dbg<span class=p>.</span>variable <span class=s>&#34;Depth&#34;</span><span class=p>,</span> <span class=nv>%c12_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// const Width
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%c4096_i32</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>4096</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  dbg<span class=p>.</span>variable <span class=s>&#34;Width&#34;</span><span class=p>,</span> <span class=nv>%c4096_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// input req: Req
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%0</span> <span class=p>=</span> dbg<span class=p>.</span>struct <span class=p>{</span><span class=s>&#34;data&#34;</span><span class=p>:</span> <span class=nv>%req_data</span><span class=p>,</span> <span class=s>&#34;valid&#34;</span><span class=p>:</span> <span class=nv>%req_valid</span><span class=p>,</span> <span class=s>&#34;ready&#34;</span><span class=p>:</span> <span class=nv>%req_ready</span><span class=p>}</span> <span class=p>:</span> <span class=k>i42</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  dbg<span class=p>.</span>variable <span class=s>&#34;req&#34;</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>dbg<span class=p>.</span>struct
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// output resps: Resp[2]
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%1</span> <span class=p>=</span> dbg<span class=p>.</span>struct <span class=p>{</span><span class=s>&#34;result&#34;</span><span class=p>:</span> <span class=nv>%resps0_result</span><span class=p>,</span> <span class=s>&#34;done&#34;</span><span class=p>:</span> <span class=nv>%resps0_done</span><span class=p>}</span> <span class=p>:</span> <span class=k>i42</span><span class=p>,</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  <span class=nv>%2</span> <span class=p>=</span> dbg<span class=p>.</span>struct <span class=p>{</span><span class=s>&#34;result&#34;</span><span class=p>:</span> <span class=nv>%resps1_result</span><span class=p>,</span> <span class=s>&#34;done&#34;</span><span class=p>:</span> <span class=nv>%resps1_done</span><span class=p>}</span> <span class=p>:</span> <span class=k>i42</span><span class=p>,</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  <span class=nv>%3</span> <span class=p>=</span> dbg<span class=p>.</span>array <span class=p>[</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>dbg<span class=p>.</span>struct<span class=p>,</span> <span class=p>!</span>dbg<span class=p>.</span>struct
</span></span><span class=line><span class=cl>  dbg<span class=p>.</span>variable <span class=s>&#34;resps&#34;</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=p>!</span>dbg<span class=p>.</span>array
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// let x = req
</span></span></span><span class=line><span class=cl><span class=c></span>  dbg<span class=p>.</span>variable <span class=s>&#34;x&#34;</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>dbg<span class=p>.</span>struct
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  hw<span class=p>.</span>output <span class=nv>%req_ready</span><span class=p>,</span> <span class=nv>%resps0_result</span><span class=p>,</span> <span class=nv>%resps0_done</span><span class=p>,</span> <span class=nv>%resps1_result</span><span class=p>,</span> <span class=nv>%resps1_done</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i42</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i42</span><span class=p>,</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Despite the fact that the <code>Req</code> and <code>Resp</code> structs, and <code>Resp[2]</code> array were
unrolled and lowered into separate scalar values in the IR, and the <code>ready: &i1</code>
input of <code>Req</code> having been turned into a <code>ready: i1</code> output, the <code>dbg.variable</code>
op accurately tracks how the original source language values can be
reconstructed. Note also how monomorphization has turned the <code>Depth</code> parameter
and <code>Width</code> into constants in the IR, but the corresponding <code>dbg.variable</code> ops
still expose the constant values under the name <code>Depth</code> and <code>Width</code> in the debug
info.</p><h2 id=tracking-inlined-modules>Tracking Inlined Modules&nbsp;<a class=headline-hash href=#tracking-inlined-modules>¶</a></h2><p>The <code>dbg.scope</code> op can be used to track debug information about inlined modules.
By default, operations such as <code>hw.module</code> in conjunction with <code>hw.instance</code>
introduce an implicit module scope. All debug operations within a module are
added to that implicit scope, unless they have an explicit <code>scope</code> operand. This
explicit scope operand can be used to group the DI of an inlined module.
Consider the following modules:</p><pre tabindex=0><code>hw.module @Foo(in %a: i42) {
  dbg.variable &#34;a&#34;, %a : i42
  hw.instance &#34;bar&#34; @Bar(x: %a: i42)
}
hw.module @Bar(in %x: i42) {
  dbg.variable &#34;x&#34;, %x : i42
  %0 = comb.mul %x, %x : i42
  dbg.variable &#34;squared&#34;, %0 : i42
}
</code></pre><p>If we inline module <code>Bar</code>, we can introduce a <code>dbg.scope</code> operation to represent
the original instance, and group all debug variables in <code>Bar</code> under this
explicit scope:</p><pre tabindex=0><code>hw.module @Foo(in %a: i42) {
  dbg.variable &#34;a&#34;, %a : i42
  %0 = dbg.scope &#34;bar&#34;, &#34;Bar&#34;
  dbg.variable &#34;x&#34;, %a scope %0 : i42
  %1 = comb.mul %a, %a : i42
  dbg.variable &#34;squared&#34;, %1 scope %0 : i42
}
</code></pre><p>Despite the fact that the instance op no longer exists, the explicit <code>dbg.scope</code>
op models the additional levle of hierarchy that used to exist in the input.</p><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><h3 id=overview>Overview&nbsp;<a class=headline-hash href=#overview>¶</a></h3><p>The debug dialect does not precisely track the type of struct and array
aggregate values. Aggregates simply return the type <code>!dbg.struct</code> and
<code>!dbg.array</code>, respectively.</p><p>Extracting and emitting the debug information of a piece of IR involves looking
through debug ops to find actually emitted values that can be used to
reconstruct the source language values. Therefore the actual structure of the
debug ops is important, but their return type is not instrumental. The
distinction between struct and array types is an arbitrary choice that can be
changed easily, either by collapsing them into one aggregate type, or by more
precisely listing field/element types and array dimensions if the need arises.</p><h3 id=arraytype>ArrayType&nbsp;<a class=headline-hash href=#arraytype>¶</a></h3><p>debug array aggregate</p><p>Syntax: <code>!dbg.array</code></p><p>The result of a <code>dbg.array</code> operation.</p><h3 id=scopetype>ScopeType&nbsp;<a class=headline-hash href=#scopetype>¶</a></h3><p>debug scope</p><p>Syntax: <code>!dbg.scope</code></p><p>The result of a <code>dbg.scope</code> operation.</p><h3 id=structtype>StructType&nbsp;<a class=headline-hash href=#structtype>¶</a></h3><p>debug struct aggregate</p><p>Syntax: <code>!dbg.struct</code></p><p>The result of a <code>dbg.struct</code> operation.</p><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><h3 id=dbgarray-circtdebugarrayop><code>dbg.array</code> (circt::debug::ArrayOp)&nbsp;<a class=headline-hash href=#dbgarray-circtdebugarrayop>¶</a></h3><p><em>Aggregate values into an array</em></p><p>Creates an array aggregate from a list of values. The first operand is
placed at array index 0. The last operand is placed at the highest array
index. The <code>dbg.array</code> operation allows for array-like source language
values to be captured in the debug info. This includes arrays, or in the
case of SystemVerilog, packed and unpacked arrays, lists, sequences, queues,
FIFOs, channels, and vectors.</p><p>See the rationale for examples and details.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>elements</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>debug array aggregate</td></tr></tbody></table><h3 id=dbgscope-circtdebugscopeop><code>dbg.scope</code> (circt::debug::ScopeOp)&nbsp;<a class=headline-hash href=#dbgscope-circtdebugscopeop>¶</a></h3><p><em>Define a scope for debug values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `dbg.scope` $instanceName `,` $moduleName (`scope` $scope^)? attr-dict
</code></pre><p>Creates an additional level of hierarchy in the DI, a &ldquo;scope&rdquo;, which can be
used to group variables and other scopes.</p><p>Operations such as <code>hw.module</code> introduce an implicit scope. All debug
operations within a module are added to that implicit scope, unless they
have an explicit <code>scope</code> operand. Providing an explicit scope can be used to
represent inlined modules.</p><p>Scopes in DI do not necessarily have to correspond to levels of a module
hierarchy. They can also be used to model things like control flow scopes,
call stacks, and other source-language concepts.</p><p>The <code>scope</code> operand of any debug dialect operation must be defined locally
by a <code>dbg.scope</code> operation. It cannot be a block argument. (This is intended
as a temporary restriction, to be lifted in the future.)</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>instanceName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>moduleName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>scope</code></td><td>debug scope</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>debug scope</td></tr></tbody></table><h3 id=dbgstruct-circtdebugstructop><code>dbg.struct</code> (circt::debug::StructOp)&nbsp;<a class=headline-hash href=#dbgstruct-circtdebugstructop>¶</a></h3><p><em>Aggregate values into a struct</em></p><p>Creates a struct aggregate from a list of names and values. The <code>dbg.struct</code>
operation allows for struct-like source language values to be captured in
the debug info. This includes structs, unions, bidirectional bundles,
interfaces, classes, and other similar structures.</p><p>See the rationale for examples and details.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>names</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fields</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>debug struct aggregate</td></tr></tbody></table><h3 id=dbgvariable-circtdebugvariableop><code>dbg.variable</code> (circt::debug::VariableOp)&nbsp;<a class=headline-hash href=#dbgvariable-circtdebugvariableop>¶</a></h3><p><em>A named value to be captured in debug info</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `dbg.variable` $name `,` $value (`scope` $scope^)? attr-dict `:` type($value)
</code></pre><p>Marks a value to be tracked in DI under the given name. The <code>dbg.variable</code>
operation is useful to represent named values in a source language. For
example, ports, constants, parameters, variables, nodes, or name aliases can
all be represented as a variable. In combination with <code>dbg.array</code> and
<code>dbg.struct</code>, complex aggregate source language values can be described and
reconstituted from individual IR values. The <code>dbg.variable</code> operation acts
as a tracker that follows the evolution of its assigned value throughout the
compiler&rsquo;s pass pipelines. The debug info analysis uses this op to populate
a module&rsquo;s scope with named source language values, and to establish how
these source language values can be reconstituted from the actual IR values
present at the end of compilation.</p><p>See the rationale for examples and details. See the <code>dbg.scope</code> operation
for additional details on how to use the <code>scope</code> operand.</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr><tr><td style=text-align:center><code>scope</code></td><td>debug scope</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/Verif/ title="'verif' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'verif' Dialect</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/Interop/ title="Interop Dialect">Next - Interop Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li class=active><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>