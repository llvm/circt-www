<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'esi' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/ESI/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'esi' Dialect</h1><p>The Elastic Silicon Interconnect dialect aims to aid in accelerator system construction.</p><p><nav id=TableOfContents><ul><li><a href=#application-channels>Application channels</a><ul><li><a href=#channelbundletype>ChannelBundleType</a></li><li><a href=#channeltype>ChannelType</a></li><li><a href=#clocktype>ClockType</a></li><li><a href=#listtype>ListType</a></li><li><a href=#windowtype>WindowType</a></li><li><a href=#firmemtype>FirMemType</a></li><li><a href=#hlmemtype>HLMemType</a></li><li><a href=#windowfieldtype>WindowFieldType</a></li><li><a href=#windowframetype>WindowFrameType</a></li><li><a href=#listtype-1>ListType</a></li><li><a href=#esibuffer-circtesichannelbufferop><code>esi.buffer</code> (::circt::esi::ChannelBufferOp)</a></li><li><a href=#esicosimfrom_host-circtesicosimfromhostendpointop><code>esi.cosim.from_host</code> (::circt::esi::CosimFromHostEndpointOp)</a></li><li><a href=#esicosimto_host-circtesicosimtohostendpointop><code>esi.cosim.to_host</code> (::circt::esi::CosimToHostEndpointOp)</a></li><li><a href=#esinull-circtesinullsourceop><code>esi.null</code> (::circt::esi::NullSourceOp)</a></li><li><a href=#esibundlepack-circtesipackbundleop><code>esi.bundle.pack</code> (::circt::esi::PackBundleOp)</a></li><li><a href=#esistage-circtesipipelinestageop><code>esi.stage</code> (::circt::esi::PipelineStageOp)</a></li><li><a href=#esibundleunpack-circtesiunpackbundleop><code>esi.bundle.unpack</code> (::circt::esi::UnpackBundleOp)</a></li><li><a href=#esiunwrapfifo-circtesiunwrapfifoop><code>esi.unwrap.fifo</code> (::circt::esi::UnwrapFIFOOp)</a></li><li><a href=#esiunwrapiface-circtesiunwrapsvinterfaceop><code>esi.unwrap.iface</code> (::circt::esi::UnwrapSVInterfaceOp)</a></li><li><a href=#esiunwrapvr-circtesiunwrapvalidreadyop><code>esi.unwrap.vr</code> (::circt::esi::UnwrapValidReadyOp)</a></li><li><a href=#esiwindowunwrap-circtesiunwrapwindow><code>esi.window.unwrap</code> (::circt::esi::UnwrapWindow)</a></li><li><a href=#esiwrapfifo-circtesiwrapfifoop><code>esi.wrap.fifo</code> (::circt::esi::WrapFIFOOp)</a></li><li><a href=#esiwrapiface-circtesiwrapsvinterfaceop><code>esi.wrap.iface</code> (::circt::esi::WrapSVInterfaceOp)</a></li><li><a href=#esiwrapvr-circtesiwrapvalidreadyop><code>esi.wrap.vr</code> (::circt::esi::WrapValidReadyOp)</a></li><li><a href=#esiwindowwrap-circtesiwrapwindow><code>esi.window.wrap</code> (::circt::esi::WrapWindow)</a></li></ul></li><li><a href=#services>Services</a><ul><li><a href=#esimanifesthier_node-circtesiappidhiernodeop><code>esi.manifest.hier_node</code> (::circt::esi::AppIDHierNodeOp)</a></li><li><a href=#esimanifesthier_root-circtesiappidhierrootop><code>esi.manifest.hier_root</code> (::circt::esi::AppIDHierRootOp)</a></li><li><a href=#esibuffer-circtesichannelbufferop-1><code>esi.buffer</code> (::circt::esi::ChannelBufferOp)</a></li><li><a href=#esimanifestcompressed-circtesicompressedmanifestop><code>esi.manifest.compressed</code> (::circt::esi::CompressedManifestOp)</a></li><li><a href=#esicosimfrom_host-circtesicosimfromhostendpointop-1><code>esi.cosim.from_host</code> (::circt::esi::CosimFromHostEndpointOp)</a></li><li><a href=#esicosimto_host-circtesicosimtohostendpointop-1><code>esi.cosim.to_host</code> (::circt::esi::CosimToHostEndpointOp)</a></li><li><a href=#esiservicedecl-circtesicustomservicedeclop><code>esi.service.decl</code> (::circt::esi::CustomServiceDeclOp)</a></li><li><a href=#esinull-circtesinullsourceop-1><code>esi.null</code> (::circt::esi::NullSourceOp)</a></li><li><a href=#esibundlepack-circtesipackbundleop-1><code>esi.bundle.pack</code> (::circt::esi::PackBundleOp)</a></li><li><a href=#esistage-circtesipipelinestageop-1><code>esi.stage</code> (::circt::esi::PipelineStageOp)</a></li><li><a href=#esiservicereq-circtesirequestconnectionop><code>esi.service.req</code> (::circt::esi::RequestConnectionOp)</a></li><li><a href=#esiserviceport-circtesiservicedeclportop><code>esi.service.port</code> (::circt::esi::ServiceDeclPortOp)</a></li><li><a href=#esimanifestimpl_conn-circtesiserviceimplclientrecordop><code>esi.manifest.impl_conn</code> (::circt::esi::ServiceImplClientRecordOp)</a></li><li><a href=#esimanifestservice_impl-circtesiserviceimplrecordop><code>esi.manifest.service_impl</code> (::circt::esi::ServiceImplRecordOp)</a></li><li><a href=#esiserviceimpl_reqreq-circtesiserviceimplementconnreqop><code>esi.service.impl_req.req</code> (::circt::esi::ServiceImplementConnReqOp)</a></li><li><a href=#esiserviceimpl_req-circtesiserviceimplementreqop><code>esi.service.impl_req</code> (::circt::esi::ServiceImplementReqOp)</a></li><li><a href=#esiserviceinstance-circtesiserviceinstanceop><code>esi.service.instance</code> (::circt::esi::ServiceInstanceOp)</a></li><li><a href=#esimanifestreq-circtesiservicerequestrecordop><code>esi.manifest.req</code> (::circt::esi::ServiceRequestRecordOp)</a></li><li><a href=#esimanifestsym-circtesisymbolmetadataop><code>esi.manifest.sym</code> (::circt::esi::SymbolMetadataOp)</a></li><li><a href=#esibundleunpack-circtesiunpackbundleop-1><code>esi.bundle.unpack</code> (::circt::esi::UnpackBundleOp)</a></li><li><a href=#esiunwrapfifo-circtesiunwrapfifoop-1><code>esi.unwrap.fifo</code> (::circt::esi::UnwrapFIFOOp)</a></li><li><a href=#esiunwrapiface-circtesiunwrapsvinterfaceop-1><code>esi.unwrap.iface</code> (::circt::esi::UnwrapSVInterfaceOp)</a></li><li><a href=#esiunwrapvr-circtesiunwrapvalidreadyop-1><code>esi.unwrap.vr</code> (::circt::esi::UnwrapValidReadyOp)</a></li><li><a href=#esiwindowunwrap-circtesiunwrapwindow-1><code>esi.window.unwrap</code> (::circt::esi::UnwrapWindow)</a></li><li><a href=#esiwrapfifo-circtesiwrapfifoop-1><code>esi.wrap.fifo</code> (::circt::esi::WrapFIFOOp)</a></li><li><a href=#esiwrapiface-circtesiwrapsvinterfaceop-1><code>esi.wrap.iface</code> (::circt::esi::WrapSVInterfaceOp)</a></li><li><a href=#esiwrapvr-circtesiwrapvalidreadyop-1><code>esi.wrap.vr</code> (::circt::esi::WrapValidReadyOp)</a></li><li><a href=#esiwindowwrap-circtesiwrapwindow-1><code>esi.window.wrap</code> (::circt::esi::WrapWindow)</a></li><li><a href=#esimanifesthier_node-circtesiappidhiernodeop-1><code>esi.manifest.hier_node</code> (::circt::esi::AppIDHierNodeOp)</a></li><li><a href=#esimanifesthier_root-circtesiappidhierrootop-1><code>esi.manifest.hier_root</code> (::circt::esi::AppIDHierRootOp)</a></li><li><a href=#esibuffer-circtesichannelbufferop-2><code>esi.buffer</code> (::circt::esi::ChannelBufferOp)</a></li><li><a href=#esimanifestcompressed-circtesicompressedmanifestop-1><code>esi.manifest.compressed</code> (::circt::esi::CompressedManifestOp)</a></li><li><a href=#esicosimfrom_host-circtesicosimfromhostendpointop-2><code>esi.cosim.from_host</code> (::circt::esi::CosimFromHostEndpointOp)</a></li><li><a href=#esicosimto_host-circtesicosimtohostendpointop-2><code>esi.cosim.to_host</code> (::circt::esi::CosimToHostEndpointOp)</a></li><li><a href=#esiservicedecl-circtesicustomservicedeclop-1><code>esi.service.decl</code> (::circt::esi::CustomServiceDeclOp)</a></li><li><a href=#esiservicestdfunc-circtesifuncservicedeclop><code>esi.service.std.func</code> (::circt::esi::FuncServiceDeclOp)</a></li><li><a href=#esiservicestdmmio-circtesimmioservicedeclop><code>esi.service.std.mmio</code> (::circt::esi::MMIOServiceDeclOp)</a></li><li><a href=#esinull-circtesinullsourceop-2><code>esi.null</code> (::circt::esi::NullSourceOp)</a></li><li><a href=#esibundlepack-circtesipackbundleop-2><code>esi.bundle.pack</code> (::circt::esi::PackBundleOp)</a></li><li><a href=#esistage-circtesipipelinestageop-2><code>esi.stage</code> (::circt::esi::PipelineStageOp)</a></li><li><a href=#esimemram-circtesirandomaccessmemorydeclop><code>esi.mem.ram</code> (::circt::esi::RandomAccessMemoryDeclOp)</a></li><li><a href=#esiservicereq-circtesirequestconnectionop-1><code>esi.service.req</code> (::circt::esi::RequestConnectionOp)</a></li><li><a href=#esiserviceport-circtesiservicedeclportop-1><code>esi.service.port</code> (::circt::esi::ServiceDeclPortOp)</a></li><li><a href=#esimanifestimpl_conn-circtesiserviceimplclientrecordop-1><code>esi.manifest.impl_conn</code> (::circt::esi::ServiceImplClientRecordOp)</a></li><li><a href=#esimanifestservice_impl-circtesiserviceimplrecordop-1><code>esi.manifest.service_impl</code> (::circt::esi::ServiceImplRecordOp)</a></li><li><a href=#esiserviceimpl_reqreq-circtesiserviceimplementconnreqop-1><code>esi.service.impl_req.req</code> (::circt::esi::ServiceImplementConnReqOp)</a></li><li><a href=#esiserviceimpl_req-circtesiserviceimplementreqop-1><code>esi.service.impl_req</code> (::circt::esi::ServiceImplementReqOp)</a></li><li><a href=#esiserviceinstance-circtesiserviceinstanceop-1><code>esi.service.instance</code> (::circt::esi::ServiceInstanceOp)</a></li><li><a href=#esimanifestreq-circtesiservicerequestrecordop-1><code>esi.manifest.req</code> (::circt::esi::ServiceRequestRecordOp)</a></li><li><a href=#esimanifestsym-circtesisymbolmetadataop-1><code>esi.manifest.sym</code> (::circt::esi::SymbolMetadataOp)</a></li><li><a href=#esibundleunpack-circtesiunpackbundleop-2><code>esi.bundle.unpack</code> (::circt::esi::UnpackBundleOp)</a></li><li><a href=#esiunwrapfifo-circtesiunwrapfifoop-2><code>esi.unwrap.fifo</code> (::circt::esi::UnwrapFIFOOp)</a></li><li><a href=#esiunwrapiface-circtesiunwrapsvinterfaceop-2><code>esi.unwrap.iface</code> (::circt::esi::UnwrapSVInterfaceOp)</a></li><li><a href=#esiunwrapvr-circtesiunwrapvalidreadyop-2><code>esi.unwrap.vr</code> (::circt::esi::UnwrapValidReadyOp)</a></li><li><a href=#esiwindowunwrap-circtesiunwrapwindow-2><code>esi.window.unwrap</code> (::circt::esi::UnwrapWindow)</a></li><li><a href=#esiwrapfifo-circtesiwrapfifoop-2><code>esi.wrap.fifo</code> (::circt::esi::WrapFIFOOp)</a></li><li><a href=#esiwrapiface-circtesiwrapsvinterfaceop-2><code>esi.wrap.iface</code> (::circt::esi::WrapSVInterfaceOp)</a></li><li><a href=#esiwrapvr-circtesiwrapvalidreadyop-2><code>esi.wrap.vr</code> (::circt::esi::WrapValidReadyOp)</a></li><li><a href=#esiwindowwrap-circtesiwrapwindow-2><code>esi.window.wrap</code> (::circt::esi::WrapWindow)</a></li></ul></li><li><a href=#structural>Structural</a><ul><li><a href=#esipure_moduleinput-circtesiesipuremoduleinputop><code>esi.pure_module.input</code> (::circt::esi::ESIPureModuleInputOp)</a></li><li><a href=#esipure_module-circtesiesipuremoduleop><code>esi.pure_module</code> (::circt::esi::ESIPureModuleOp)</a></li><li><a href=#esipure_moduleoutput-circtesiesipuremoduleoutputop><code>esi.pure_module.output</code> (::circt::esi::ESIPureModuleOutputOp)</a></li><li><a href=#esipure_moduleparam-circtesiesipuremoduleparamop><code>esi.pure_module.param</code> (::circt::esi::ESIPureModuleParamOp)</a></li></ul></li><li><a href=#interfaces>Interfaces</a></li><li><a href=#channelopinterface-channelopinterface>ChannelOpInterface (<code>ChannelOpInterface</code>)</a><ul><li><a href=#methods>Methods:</a></li></ul></li><li><a href=#hasappid-hasappidopinterface>HasAppID (<code>HasAppIDOpInterface</code>)</a><ul><li><a href=#methods-1>Methods:</a></li></ul></li><li><a href=#ismanifestdata-ismanifestdata>IsManifestData (<code>IsManifestData</code>)</a><ul><li><a href=#methods-2>Methods:</a></li></ul></li><li><a href=#servicedeclopinterface-servicedeclopinterface>ServiceDeclOpInterface (<code>ServiceDeclOpInterface</code>)</a><ul><li><a href=#methods-3>Methods:</a></li></ul></li></ul></nav><h2 id=application-channels>Application channels</h2><p>The main component of ESI are point-to-point, typed channels that allow
designers to connect modules to each other and software, then communicate by
sending messages. Channels largely abstract away the details of message
communication from the designer, though the designer can declaratively specify
how to implement the channel.</p><p>Messages have types: ints, structs, arrays, unions, and variable-length lists.
The width of a channel is not necessarily the same width as the message. ESI
“windows” can be used to break up a message into a series of “frames”. IP blocks
can emit / absorb “windowed” messages or full-sized messages, which can be
automatically broken up to save wire area at the cost of bandwidth.</p><p>Any channel which is exposed to the host will have a platform-agnostic software
API constructed for it based on the type of the channel. The software
application merely has to connect to the accelerator then invoke a method to
send or receive messages from the accelerator system.</p><h3 id=channelbundletype>ChannelBundleType</h3><p>a bundle of channels</p><p>Syntax:</p><pre tabindex=0><code>!esi.bundle&lt;
  ::llvm::ArrayRef&lt;BundledChannel&gt;,   # channels
  ::mlir::UnitAttr   # resettable
&gt;
</code></pre><p>A channel bundle (sometimes referred to as just &ldquo;bundle&rdquo;) is a set of
channels of associated signals, along with per-channel names and directions.
The prototypical example for a bundle is a request-response channel pair.</p><p>The direction terminology is a bit confusing. Let us designate the module
which is outputting the bundle as the &ldquo;sender&rdquo; module and a module which has
a bundle as an input as the &ldquo;receiver&rdquo;. The directions &ldquo;from&rdquo; and &ldquo;to&rdquo; are
from the senders perspective. So, the &ldquo;to&rdquo; direction means that channel is
transmitting messages from the sender to the receiver. Then, &ldquo;from&rdquo; means
that the sender is getting messages from the receiver (typically responses).</p><p>When requesting a bundle from a service, the service is always considered
the sender; so, &ldquo;to&rdquo; means the service is sending messages to the client and
&ldquo;from&rdquo; means the service is receiving messages from the client.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>channels</td><td style=text-align:center><code>::llvm::ArrayRef&lt;BundledChannel></code></td><td></td></tr><tr><td style=text-align:center>resettable</td><td style=text-align:center><code>::mlir::UnitAttr</code></td><td>boolean flag</td></tr></tbody></table><h3 id=channeltype>ChannelType</h3><p>An ESI-compatible channel port</p><p>Syntax:</p><pre tabindex=0><code>!esi.channel&lt;
  Type,   # inner
  ::circt::esi::ChannelSignaling   # signaling
&gt;
</code></pre><p>An ESI port kind which models a latency-insensitive, unidirectional,
point-to-point data stream. Channels are typed (like all of ESI). Said
type can be any MLIR type, but must be lowered to something a backend
knows how to output (i.e. something emitVerilog knows about).</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>hw<span class=p>.</span>module<span class=p>.</span>extern <span class=nf>@Sender</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=nv>%x</span><span class=p>:</span> <span class=p>!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>hw<span class=p>.</span>module <span class=nf>@Reciever</span><span class=p>(</span><span class=nv>%a</span><span class=p>:</span> <span class=p>!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span>hw<span class=p>.</span>array<span class=p>&lt;</span><span class=m>5x</span><span class=k>i16</span><span class=p>&gt;&gt;)</span> <span class=p>{</span> <span class=p>}</span>
</span></span></code></pre></div><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>inner</td><td style=text-align:center><code>Type</code></td><td></td></tr><tr><td style=text-align:center>signaling</td><td style=text-align:center><code>::circt::esi::ChannelSignaling</code></td><td></td></tr></tbody></table><h3 id=clocktype>ClockType</h3><p>A type for clock-carrying wires</p><p>Syntax: <code>!seq.clock</code></p><p>The <code>!seq.clock</code> type represents signals which can be used to drive the
clock input of sequential operations.</p><h3 id=listtype>ListType</h3><p>a runtime-variably sized list</p><p>Syntax:</p><pre tabindex=0><code>!esi.list&lt;
  Type   # elementType
&gt;
</code></pre><p>In software, a chunk of memory with runtime-specified length. In hardware, a
stream of runtime-specified amount of data transmitted over many cycles in
compile-time specified specified windows (chunks).</p><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=windowtype>WindowType</h3><p>a data window</p><p>Syntax:</p><pre tabindex=0><code>!esi.window&lt;
  StringAttr,   # name
  mlir::Type,   # into
  ::llvm::ArrayRef&lt;WindowFrameType&gt;   # frames
&gt;
</code></pre><p>A &lsquo;data window&rsquo; allows designers to break up large messages into multiple
frames (aka phits) spread across multiple cycles. Windows are specified in
terms of a mapping of struct fields to frames. The width of a window is the
maximum frame size + the union tag (log2(#frames)).</p><p>A data window does NOT imply an ESI channel.</p><p>Current restrictions:</p><ul><li>A field may only appear once.</li><li>Fields may only be re-ordered (wrt the original message) within a frame.</li><li>Array fields whose array length is not evenly divisible by &rsquo;numItems&rsquo; will
have an implicit frame inserted directly after containing the leftover array
items.</li><li>Array fields with an array length MUST be in their own frame.</li></ul><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>StringAttr</code></td><td></td></tr><tr><td style=text-align:center>into</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>frames</td><td style=text-align:center><code>::llvm::ArrayRef&lt;WindowFrameType></code></td><td></td></tr></tbody></table><h3 id=firmemtype>FirMemType</h3><p>A FIRRTL-flavored memory</p><p>Syntax:</p><pre tabindex=0><code>!seq.firmem&lt;
  uint64_t,   # depth
  uint32_t,   # width
  std::optional&lt;uint32_t&gt;   # maskWidth
&gt;
</code></pre><p>The <code>!seq.firmem</code> type represents a FIRRTL-flavored memory declared by a
<code>seq.firmem</code> operation. It captures the parameters of the memory that are
relevant to the read, write, and read-write ports, such as width and depth.</p><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>depth</td><td style=text-align:center><code>uint64_t</code></td><td></td></tr><tr><td style=text-align:center>width</td><td style=text-align:center><code>uint32_t</code></td><td></td></tr><tr><td style=text-align:center>maskWidth</td><td style=text-align:center><code>std::optional&lt;uint32_t></code></td><td></td></tr></tbody></table><h3 id=hlmemtype>HLMemType</h3><p>Multi-dimensional memory type</p><p>Syntax:</p><pre tabindex=0><code>hlmem-type ::== `hlmem` `&lt;` dim-list element-type `&gt;`
</code></pre><p>The HLMemType represents the type of an addressable memory structure. The
type is inherently multidimensional. Dimensions must be known integer values.</p><p>Note: unidimensional memories are represented as &lt;1x{element type}> -
&lt;{element type}> is illegal.</p><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>shape</td><td style=text-align:center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=windowfieldtype>WindowFieldType</h3><p>a field-in-frame specifier</p><p>Syntax:</p><pre tabindex=0><code>!esi.window.field&lt;
  StringAttr,   # fieldName
  uint64_t   # numItems
&gt;
</code></pre><p>Specify that a field should appear within the enclosing frame.</p><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>fieldName</td><td style=text-align:center><code>StringAttr</code></td><td></td></tr><tr><td style=text-align:center>numItems</td><td style=text-align:center><code>uint64_t</code></td><td># of items in arrays or lists</td></tr></tbody></table><h3 id=windowframetype>WindowFrameType</h3><p>Declare a data window frame</p><p>Syntax:</p><pre tabindex=0><code>!esi.window.frame&lt;
  StringAttr,   # name
  ::llvm::ArrayRef&lt;WindowFieldType&gt;   # members
&gt;
</code></pre><p>A named list of fields which should appear in a given frame.</p><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>StringAttr</code></td><td></td></tr><tr><td style=text-align:center>members</td><td style=text-align:center><code>::llvm::ArrayRef&lt;WindowFieldType></code></td><td></td></tr></tbody></table><h3 id=listtype-1>ListType</h3><p>a runtime-variably sized list</p><p>Syntax:</p><pre tabindex=0><code>!esi.list&lt;
  Type   # elementType
&gt;
</code></pre><p>In software, a chunk of memory with runtime-specified length. In hardware, a
stream of runtime-specified amount of data transmitted over many cycles in
compile-time specified specified windows (chunks).</p><h4 id=parameters-8>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=esibuffer-circtesichannelbufferop><code>esi.buffer</code> (::circt::esi::ChannelBufferOp)</h3><p><em>Control options for an ESI channel.</em></p><p>A channel buffer (<code>buffer</code>) is essentially a set of options on a channel.
It always adds at least one cycle of latency (pipeline stage) to the
channel, but this is configurable.</p><p>This operation is inserted on an ESI dataflow edge. It must exist
previous to SystemVerilog emission but can be added in a lowering pass.</p><p>A <code>stages</code> attribute may be provided to specify a specific number of cycles
(pipeline stages) to use on this channel. Must be greater than 0.</p><p>A <code>name</code> attribute may be provided to assigned a name to a buffered
connection.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%esiChan</span> <span class=p>=</span> hw<span class=p>.</span>instance <span class=s>&#34;sender&#34;</span> <span class=nf>@Sender</span> <span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl><span class=c>// Allow automatic selection of options.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%bufferedChan</span> <span class=p>=</span> esi<span class=p>.</span>buffer <span class=nv>%esiChan</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>hw<span class=p>.</span>instance <span class=s>&#34;recv&#34;</span> <span class=nf>@Reciever</span> <span class=p>(</span><span class=nv>%bufferedChan</span><span class=p>)</span> <span class=p>:</span> <span class=p>(!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Alternatively, specify the number of stages.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%fourStageBufferedChan</span> <span class=p>=</span> esi<span class=p>.</span>buffer <span class=nv>%esiChan</span> <span class=p>{</span> <span class=nl>stages =</span> <span class=m>4</span> <span class=p>}</span> <span class=p>:</span> <span class=k>i1</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ChannelOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>stages</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 1</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>input</code></td><td>an ESI channel</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esicosimfrom_host-circtesicosimfromhostendpointop><code>esi.cosim.from_host</code> (::circt::esi::CosimFromHostEndpointOp)</h3><p><em>Co-simulation endpoint receiving data from the host</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.cosim.from_host` $clk `,` $rst `,` $id attr-dict `:` qualified(type($fromHost))
</code></pre><p>A co-simulation endpoint is a connection from the simulation to some
outside process, usually a software application responsible for driving
the simulation (driver).</p><p>It is uni-directional, in this case receiving data from the host for the
simulation.</p><p>NOTE: $id MUST be unique across all endpoints at simulation runtime.</p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fromHost</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esicosimto_host-circtesicosimtohostendpointop><code>esi.cosim.to_host</code> (::circt::esi::CosimToHostEndpointOp)</h3><p><em>Co-simulation endpoint sending data to the host.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.cosim.to_host` $clk `,` $rst `,` $toHost`,` $id attr-dict `:` qualified(type($toHost))
</code></pre><p>A co-simulation endpoint is a connection from the simulation to some
outside process, usually a software application responsible for driving
the simulation (driver).</p><p>It is uni-directional, in this case sending data from the simulation to the
host.</p><p>NOTE: $id MUST be unique across all endpoints at simulation runtime.</p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>toHost</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esinull-circtesinullsourceop><code>esi.null</code> (::circt::esi::NullSourceOp)</h3><p><em>An op which never produces messages.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.null` attr-dict `:` qualified(type($out))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esibundlepack-circtesipackbundleop><code>esi.bundle.pack</code> (::circt::esi::PackBundleOp)</h3><p><em>Pack channels into a bundle</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.bundle.pack` $toChannels attr-dict `:` custom&lt;UnPackBundleType&gt;(
              type($toChannels), type($fromChannels), type($bundle))
</code></pre><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>toChannels</code></td><td>variadic of an ESI channel</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>bundle</code></td><td>a bundle of channels</td></tr><tr><td style=text-align:center><code>fromChannels</code></td><td>variadic of an ESI channel</td></tr></tbody></table><h3 id=esistage-circtesipipelinestageop><code>esi.stage</code> (::circt::esi::PipelineStageOp)</h3><p><em>An elastic buffer stage.</em></p><p>An individual elastic pipeline register. Generally lowered to from a
ChannelBuffer (&lsquo;buffer&rsquo;), though can be inserted anywhere to add an
additional pipeline stage. Adding individually could be useful for
late-pass latency balancing.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ChannelOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>input</code></td><td>an ESI channel</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esibundleunpack-circtesiunpackbundleop><code>esi.bundle.unpack</code> (::circt::esi::UnpackBundleOp)</h3><p><em>Unpack channels from a bundle</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.bundle.unpack` $fromChannels `from` $bundle attr-dict `:` custom&lt;UnPackBundleType&gt;(
              type($toChannels), type($fromChannels), type($bundle))
</code></pre><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>bundle</code></td><td>a bundle of channels</td></tr><tr><td style=text-align:center><code>fromChannels</code></td><td>variadic of an ESI channel</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>toChannels</code></td><td>variadic of an ESI channel</td></tr></tbody></table><h3 id=esiunwrapfifo-circtesiunwrapfifoop><code>esi.unwrap.fifo</code> (::circt::esi::UnwrapFIFOOp)</h3><p><em>Unwrap a value from an ESI port into a FIFO interface</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.unwrap.fifo` $chanInput `,` $rden attr-dict `:` qualified(type($chanInput))
</code></pre><p>Interfaces: <code>ChannelOpInterface</code>, <code>InferTypeOpInterface</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanInput</code></td><td>an ESI channel</td></tr><tr><td style=text-align:center><code>rden</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr><tr><td style=text-align:center><code>empty</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiunwrapiface-circtesiunwrapsvinterfaceop><code>esi.unwrap.iface</code> (::circt::esi::UnwrapSVInterfaceOp)</h3><p><em>Unwrap an SV interface from an ESI port</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.unwrap.iface` $chanInput `into` $interfaceSource attr-dict `:` `(` qualified(type($chanInput)) `,` qualified(type($interfaceSource)) `)`
</code></pre><p>Unwrap an ESI channel into a SystemVerilog interface containing valid,
ready, and data signals.</p><p>Interfaces: <code>ChannelOpInterface</code></p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanInput</code></td><td>an ESI channel</td></tr><tr><td style=text-align:center><code>interfaceSource</code></td><td>sv.interface</td></tr></tbody></table><h3 id=esiunwrapvr-circtesiunwrapvalidreadyop><code>esi.unwrap.vr</code> (::circt::esi::UnwrapValidReadyOp)</h3><p><em>Unwrap a value from an ESI port</em></p><p>Unwrapping a value allows operations on the contained value. Unwrap the
channel along with a ready signal that you generate. Result is the data
along with a valid signal.</p><p>Interfaces: <code>ChannelOpInterface</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanInput</code></td><td>an ESI channel</td></tr><tr><td style=text-align:center><code>ready</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rawOutput</code></td><td>any type</td></tr><tr><td style=text-align:center><code>valid</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiwindowunwrap-circtesiunwrapwindow><code>esi.window.unwrap</code> (::circt::esi::UnwrapWindow)</h3><p><em>Unwrap a data window into a union</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.window.unwrap` $window attr-dict `:` qualified(type($window))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>window</code></td><td>a data window</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>frame</code></td><td>a UnionType</td></tr></tbody></table><h3 id=esiwrapfifo-circtesiwrapfifoop><code>esi.wrap.fifo</code> (::circt::esi::WrapFIFOOp)</h3><p><em>Wrap a value into an ESI port with FIFO signaling</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.wrap.fifo` $data `,` $empty attr-dict `:`
              custom&lt;WrapFIFOType&gt;(type($data), type($chanOutput))
</code></pre><p>Interfaces: <code>ChannelOpInterface</code></p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr><tr><td style=text-align:center><code>empty</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanOutput</code></td><td>an ESI channel</td></tr><tr><td style=text-align:center><code>rden</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiwrapiface-circtesiwrapsvinterfaceop><code>esi.wrap.iface</code> (::circt::esi::WrapSVInterfaceOp)</h3><p><em>Wrap an SV interface into an ESI port</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.wrap.iface` $interfaceSink attr-dict `:` qualified(type($interfaceSink)) `-&gt;` qualified(type($output))
</code></pre><p>Wrap a SystemVerilog interface into an ESI channel. Interface MUST look
like an interface produced by ESI meaning it MUST contain valid, ready,
and data signals. Any other signals will be discarded.</p><p>Interfaces: <code>ChannelOpInterface</code></p><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>interfaceSink</code></td><td>sv.interface</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esiwrapvr-circtesiwrapvalidreadyop><code>esi.wrap.vr</code> (::circt::esi::WrapValidReadyOp)</h3><p><em>Wrap a value into an ESI port</em></p><p>Wrapping a value into an ESI port type allows modules to send values down
an ESI port. Wrap data with valid bit, result is the ESI channel and the
ready signal from the other end of the channel.</p><p>Interfaces: <code>ChannelOpInterface</code></p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rawInput</code></td><td>any type</td></tr><tr><td style=text-align:center><code>valid</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanOutput</code></td><td>an ESI channel</td></tr><tr><td style=text-align:center><code>ready</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiwindowwrap-circtesiwrapwindow><code>esi.window.wrap</code> (::circt::esi::WrapWindow)</h3><p><em>Wrap a union into a data window</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.window.wrap` $frame attr-dict `:` custom&lt;InferWindowRet&gt;(type($frame), type($window))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>frame</code></td><td>a UnionType</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>window</code></td><td>a data window</td></tr></tbody></table><h2 id=services>Services</h2><p>ESI &ldquo;services&rdquo; provide device-wide connectivity and arbitration for shared
resources, which can be requested from any IP block (service &ldquo;client&rdquo;). Standard
services will include DRAM, clock/reset, statistical counter reporting, and
debug.</p><h3 id=esimanifesthier_node-circtesiappidhiernodeop><code>esi.manifest.hier_node</code> (::circt::esi::AppIDHierNodeOp)</h3><p><em>A node in the AppID hierarchy</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.manifest.hier_node` qualified($appID) `mod` $moduleRef attr-dict-with-keyword $children
</code></pre><p>Traits: <code>HasParent&lt;circt::esi::AppIDHierRootOp, circt::esi::AppIDHierNodeOp></code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>appID</code></td><td>::circt::esi::AppIDAttr</td><td>An application relevant instance identifier</td></tr><tr><td><code>moduleRef</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h3 id=esimanifesthier_root-circtesiappidhierrootop><code>esi.manifest.hier_root</code> (::circt::esi::AppIDHierRootOp)</h3><p><em>The root of an appid instance hierarchy</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.manifest.hier_root` $topModuleRef attr-dict-with-keyword $children
</code></pre><p>Traits: <code>HasParent&lt;mlir::ModuleOp></code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>topModuleRef</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h3 id=esibuffer-circtesichannelbufferop-1><code>esi.buffer</code> (::circt::esi::ChannelBufferOp)</h3><p><em>Control options for an ESI channel.</em></p><p>A channel buffer (<code>buffer</code>) is essentially a set of options on a channel.
It always adds at least one cycle of latency (pipeline stage) to the
channel, but this is configurable.</p><p>This operation is inserted on an ESI dataflow edge. It must exist
previous to SystemVerilog emission but can be added in a lowering pass.</p><p>A <code>stages</code> attribute may be provided to specify a specific number of cycles
(pipeline stages) to use on this channel. Must be greater than 0.</p><p>A <code>name</code> attribute may be provided to assigned a name to a buffered
connection.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%esiChan</span> <span class=p>=</span> hw<span class=p>.</span>instance <span class=s>&#34;sender&#34;</span> <span class=nf>@Sender</span> <span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl><span class=c>// Allow automatic selection of options.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%bufferedChan</span> <span class=p>=</span> esi<span class=p>.</span>buffer <span class=nv>%esiChan</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>hw<span class=p>.</span>instance <span class=s>&#34;recv&#34;</span> <span class=nf>@Reciever</span> <span class=p>(</span><span class=nv>%bufferedChan</span><span class=p>)</span> <span class=p>:</span> <span class=p>(!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Alternatively, specify the number of stages.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%fourStageBufferedChan</span> <span class=p>=</span> esi<span class=p>.</span>buffer <span class=nv>%esiChan</span> <span class=p>{</span> <span class=nl>stages =</span> <span class=m>4</span> <span class=p>}</span> <span class=p>:</span> <span class=k>i1</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ChannelOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>stages</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 1</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>input</code></td><td>an ESI channel</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esimanifestcompressed-circtesicompressedmanifestop><code>esi.manifest.compressed</code> (::circt::esi::CompressedManifestOp)</h3><p><em>A zlib-compressed JSON manifest</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.manifest.compressed` $compressedManifest attr-dict
</code></pre><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>compressedManifest</code></td><td>::circt::esi::BlobAttr</td><td>A binary blob</td></tr></table><h3 id=esicosimfrom_host-circtesicosimfromhostendpointop-1><code>esi.cosim.from_host</code> (::circt::esi::CosimFromHostEndpointOp)</h3><p><em>Co-simulation endpoint receiving data from the host</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.cosim.from_host` $clk `,` $rst `,` $id attr-dict `:` qualified(type($fromHost))
</code></pre><p>A co-simulation endpoint is a connection from the simulation to some
outside process, usually a software application responsible for driving
the simulation (driver).</p><p>It is uni-directional, in this case receiving data from the host for the
simulation.</p><p>NOTE: $id MUST be unique across all endpoints at simulation runtime.</p><h4 id=attributes-7>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fromHost</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esicosimto_host-circtesicosimtohostendpointop-1><code>esi.cosim.to_host</code> (::circt::esi::CosimToHostEndpointOp)</h3><p><em>Co-simulation endpoint sending data to the host.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.cosim.to_host` $clk `,` $rst `,` $toHost`,` $id attr-dict `:` qualified(type($toHost))
</code></pre><p>A co-simulation endpoint is a connection from the simulation to some
outside process, usually a software application responsible for driving
the simulation (driver).</p><p>It is uni-directional, in this case sending data from the simulation to the
host.</p><p>NOTE: $id MUST be unique across all endpoints at simulation runtime.</p><h4 id=attributes-8>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>toHost</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esiservicedecl-circtesicustomservicedeclop><code>esi.service.decl</code> (::circt::esi::CustomServiceDeclOp)</h3><p><em>An ESI service interface declaration</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.decl` $sym_name $ports attr-dict
</code></pre><p>A declaration of an ESI service interface. Defines a contract between a
service provider and its clients.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>esi<span class=p>.</span>service<span class=p>.</span>decl <span class=nf>@HostComms</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  esi<span class=p>.</span>service<span class=p>.</span>port send <span class=p>:</span> <span class=p>!</span>esi<span class=p>.</span>bundle<span class=p>&lt;[!</span>esi<span class=p>.</span>any from <span class=s>&#34;send&#34;</span><span class=p>]&gt;</span>
</span></span><span class=line><span class=cl>  esi<span class=p>.</span>service<span class=p>.</span>port recieve <span class=p>:</span> <span class=p>!</span>esi<span class=p>.</span>channel<span class=p>&lt;[</span><span class=k>i8</span> to <span class=s>&#34;recv&#34;</span><span class=p>]&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>HasParent&lt;::mlir::ModuleOp></code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>ServiceDeclOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-9>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=esinull-circtesinullsourceop-1><code>esi.null</code> (::circt::esi::NullSourceOp)</h3><p><em>An op which never produces messages.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.null` attr-dict `:` qualified(type($out))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esibundlepack-circtesipackbundleop-1><code>esi.bundle.pack</code> (::circt::esi::PackBundleOp)</h3><p><em>Pack channels into a bundle</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.bundle.pack` $toChannels attr-dict `:` custom&lt;UnPackBundleType&gt;(
              type($toChannels), type($fromChannels), type($bundle))
</code></pre><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>toChannels</code></td><td>variadic of an ESI channel</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>bundle</code></td><td>a bundle of channels</td></tr><tr><td style=text-align:center><code>fromChannels</code></td><td>variadic of an ESI channel</td></tr></tbody></table><h3 id=esistage-circtesipipelinestageop-1><code>esi.stage</code> (::circt::esi::PipelineStageOp)</h3><p><em>An elastic buffer stage.</em></p><p>An individual elastic pipeline register. Generally lowered to from a
ChannelBuffer (&lsquo;buffer&rsquo;), though can be inserted anywhere to add an
additional pipeline stage. Adding individually could be useful for
late-pass latency balancing.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ChannelOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-18>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>input</code></td><td>an ESI channel</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esiservicereq-circtesirequestconnectionop><code>esi.service.req</code> (::circt::esi::RequestConnectionOp)</h3><p><em>Request a connection to receive data</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.req` $servicePort `(` qualified($appID) `)`
              attr-dict `:` qualified(type($toClient))
</code></pre><p>Interfaces: <code>HasAppID</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-10>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>servicePort</code></td><td>::circt::hw::InnerRefAttr</td><td>Refer to a name inside a module</td></tr><tr><td><code>appID</code></td><td>::circt::esi::AppIDAttr</td><td>An application relevant instance identifier</td></tr></table><h4 id=results-18>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>toClient</code></td><td>a bundle of channels</td></tr></tbody></table><h3 id=esiserviceport-circtesiservicedeclportop><code>esi.service.port</code> (::circt::esi::ServiceDeclPortOp)</h3><p><em>An ESI service bundle being received by the client</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.port` $inner_sym  attr-dict `:` $toClientType
</code></pre><p>Traits: <code>HasParent&lt;::circt::esi::CustomServiceDeclOp></code></p><h4 id=attributes-11>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inner_sym</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>toClientType</code></td><td>::mlir::TypeAttr</td><td>type attribute of a bundle of channels</td></tr></table><h3 id=esimanifestimpl_conn-circtesiserviceimplclientrecordop><code>esi.manifest.impl_conn</code> (::circt::esi::ServiceImplClientRecordOp)</h3><p><em>Details of a service implementation client connection</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.manifest.impl_conn` $relAppIDPath `req` $servicePort `(` $bundleType `)`
              `with` $implDetails attr-dict
</code></pre><p>A record containing all the necessary details of how to connect to a client
which the parent service record is servicing.</p><p>Traits: <code>HasParent&lt;ServiceImplRecordOp></code></p><p>Interfaces: <code>IsManifestData</code></p><h4 id=attributes-12>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>relAppIDPath</code></td><td>::mlir::ArrayAttr</td><td>Array of AppIDs</td></tr><tr><td><code>servicePort</code></td><td>::circt::hw::InnerRefAttr</td><td>Refer to a name inside a module</td></tr><tr><td><code>bundleType</code></td><td>::mlir::TypeAttr</td><td>type attribute of a bundle of channels</td></tr><tr><td><code>implDetails</code></td><td>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr></table><h3 id=esimanifestservice_impl-circtesiserviceimplrecordop><code>esi.manifest.service_impl</code> (::circt::esi::ServiceImplRecordOp)</h3><p><em>Record of a service implementation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.manifest.service_impl` qualified($appID) (`svc` $service^)? (`std` $stdService^)?
              `by` $serviceImplName `with` $implDetails
              attr-dict-with-keyword custom&lt;ServiceImplRecordReqDetails&gt;($reqDetails)
</code></pre><p>A record of a service implementation. Optionally emitted by the service
implementation. Contains information necessary to connect to the service and
service clients.</p><p>Traits: <code>NoTerminator</code></p><p>Interfaces: <code>HasAppID</code>, <code>IsManifestData</code></p><h4 id=attributes-13>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>appID</code></td><td>::circt::esi::AppIDAttr</td><td>An application relevant instance identifier</td></tr><tr><td><code>service</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>stdService</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>serviceImplName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>implDetails</code></td><td>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr></table><h3 id=esiserviceimpl_reqreq-circtesiserviceimplementconnreqop><code>esi.service.impl_req.req</code> (::circt::esi::ServiceImplementConnReqOp)</h3><p><em>The canonical form of a connection request</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.impl_req.req` $servicePort `(` $relativeAppIDPath `)`
              attr-dict `:` qualified(type($toClient))
</code></pre><p>Interfaces: <code>SymbolUserOpInterface</code></p><h4 id=attributes-14>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>servicePort</code></td><td>::circt::hw::InnerRefAttr</td><td>Refer to a name inside a module</td></tr><tr><td><code>relativeAppIDPath</code></td><td>::mlir::ArrayAttr</td><td>Array of AppIDs</td></tr></table><h4 id=results-19>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>toClient</code></td><td>a bundle of channels</td></tr></tbody></table><h3 id=esiserviceimpl_req-circtesiserviceimplementreqop><code>esi.service.impl_req</code> (::circt::esi::ServiceImplementReqOp)</h3><p><em>Request for a service to be implemented</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.impl_req` qualified($appID) (`svc` $service_symbol^)? `impl` `as` $impl_type
              (`std` $stdService^)? (`opts` $impl_opts^)? `(` $inputs `)`
              attr-dict `:` functional-type($inputs, results)
              $portReqs
</code></pre><p>The connect services pass replaces <code>service.instance</code>s with this op. The
<code>portReqs</code> region is the set of connection requests which need to be
implemented for this service instance. Channels to/from the requests have
been added to the operands/results of this op and consumers/producers have
been redirected.</p><p>Some other pass or frontend is expected to replace this op with an actual
implementation.</p><p>Traits: <code>NoTerminator</code></p><p>Interfaces: <code>HasAppID</code></p><h4 id=attributes-15>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>appID</code></td><td>::circt::esi::AppIDAttr</td><td>An application relevant instance identifier</td></tr><tr><td><code>service_symbol</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>impl_type</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>stdService</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>impl_opts</code></td><td>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr></table><h4 id=operands-19>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-20>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=esiserviceinstance-circtesiserviceinstanceop><code>esi.service.instance</code> (::circt::esi::ServiceInstanceOp)</h3><p><em>Instantiate a server module</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.instance` qualified($appID) (`svc` $service_symbol^)? `impl` `as` $impl_type
              (`opts` $impl_opts^)? `(` $inputs `)`
              attr-dict `:` functional-type($inputs, results)
</code></pre><p>Instantiate a service adhering to a service declaration interface.</p><p>A pass collects all of the connection requests to the service this op
implements from the containing modules&rsquo; descendants (in the instance
hierarchy). It bubbles them all up to the module containing this op,
creating the necessary ESI channel ports, groups them appropriately, then
replaces this op with a <code>service.impl_req</code>.</p><p>If &lsquo;service_symbol&rsquo; isn&rsquo;t specified, this instance will be used to implement
all of the service requests which get surfaced to here. This option is
generally used at the top level to specify host connectivity.</p><p>Since implementing the server will usually need &ldquo;normal&rdquo; I/O, <code>inputs</code> and
<code>results</code> act like normal <code>hw.instance</code> ports.</p><p>$identifier is used by frontends to specify or remember the type of
implementation to use for this service.</p><p>Interfaces: <code>HasAppID</code></p><h4 id=attributes-16>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>appID</code></td><td>::circt::esi::AppIDAttr</td><td>An application relevant instance identifier</td></tr><tr><td><code>service_symbol</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>impl_type</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>impl_opts</code></td><td>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr></table><h4 id=operands-20>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-21>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>variadic of any type</td></tr></tbody></table><h3 id=esimanifestreq-circtesiservicerequestrecordop><code>esi.manifest.req</code> (::circt::esi::ServiceRequestRecordOp)</h3><p><em>Record of a service request</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.manifest.req` qualified($requestor) `,` $servicePort (`std` $stdService^)?
              `,` $bundleType attr-dict
</code></pre><p>A record of a service request, including the requestor, the service
requested, and the parameters of the request. Emitted before connecting the
service to preserve metadata about the original request.</p><p>Interfaces: <code>HasAppID</code>, <code>IsManifestData</code></p><h4 id=attributes-17>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>requestor</code></td><td>::circt::esi::AppIDAttr</td><td>An application relevant instance identifier</td></tr><tr><td><code>servicePort</code></td><td>::circt::hw::InnerRefAttr</td><td>Refer to a name inside a module</td></tr><tr><td><code>stdService</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>bundleType</code></td><td>::mlir::TypeAttr</td><td>type attribute of a bundle of channels</td></tr></table><h3 id=esimanifestsym-circtesisymbolmetadataop><code>esi.manifest.sym</code> (::circt::esi::SymbolMetadataOp)</h3><p><em>Metadata about a symbol</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.manifest.sym` $symbolRef
              (`name` $name^)?
              (`repo` $repo^)?
              (`commit` $commitHash^)?
              (`version` $version^)?
              (`summary` $summary^)?
              attr-dict
</code></pre><p>Metadata about a symbol, including its name, repository, commit hash,
version, and summary. All are optional, but strongly encouraged. Any
additional metadata which users wish to attach should go as discardable
attributes.</p><p>Interfaces: <code>IsManifestData</code></p><h4 id=attributes-18>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>symbolRef</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>repo</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>commitHash</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>version</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>summary</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=esibundleunpack-circtesiunpackbundleop-1><code>esi.bundle.unpack</code> (::circt::esi::UnpackBundleOp)</h3><p><em>Unpack channels from a bundle</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.bundle.unpack` $fromChannels `from` $bundle attr-dict `:` custom&lt;UnPackBundleType&gt;(
              type($toChannels), type($fromChannels), type($bundle))
</code></pre><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=operands-21>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>bundle</code></td><td>a bundle of channels</td></tr><tr><td style=text-align:center><code>fromChannels</code></td><td>variadic of an ESI channel</td></tr></tbody></table><h4 id=results-22>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>toChannels</code></td><td>variadic of an ESI channel</td></tr></tbody></table><h3 id=esiunwrapfifo-circtesiunwrapfifoop-1><code>esi.unwrap.fifo</code> (::circt::esi::UnwrapFIFOOp)</h3><p><em>Unwrap a value from an ESI port into a FIFO interface</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.unwrap.fifo` $chanInput `,` $rden attr-dict `:` qualified(type($chanInput))
</code></pre><p>Interfaces: <code>ChannelOpInterface</code>, <code>InferTypeOpInterface</code></p><h4 id=operands-22>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanInput</code></td><td>an ESI channel</td></tr><tr><td style=text-align:center><code>rden</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-23>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr><tr><td style=text-align:center><code>empty</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiunwrapiface-circtesiunwrapsvinterfaceop-1><code>esi.unwrap.iface</code> (::circt::esi::UnwrapSVInterfaceOp)</h3><p><em>Unwrap an SV interface from an ESI port</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.unwrap.iface` $chanInput `into` $interfaceSource attr-dict `:` `(` qualified(type($chanInput)) `,` qualified(type($interfaceSource)) `)`
</code></pre><p>Unwrap an ESI channel into a SystemVerilog interface containing valid,
ready, and data signals.</p><p>Interfaces: <code>ChannelOpInterface</code></p><h4 id=operands-23>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanInput</code></td><td>an ESI channel</td></tr><tr><td style=text-align:center><code>interfaceSource</code></td><td>sv.interface</td></tr></tbody></table><h3 id=esiunwrapvr-circtesiunwrapvalidreadyop-1><code>esi.unwrap.vr</code> (::circt::esi::UnwrapValidReadyOp)</h3><p><em>Unwrap a value from an ESI port</em></p><p>Unwrapping a value allows operations on the contained value. Unwrap the
channel along with a ready signal that you generate. Result is the data
along with a valid signal.</p><p>Interfaces: <code>ChannelOpInterface</code></p><h4 id=operands-24>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanInput</code></td><td>an ESI channel</td></tr><tr><td style=text-align:center><code>ready</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-24>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rawOutput</code></td><td>any type</td></tr><tr><td style=text-align:center><code>valid</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiwindowunwrap-circtesiunwrapwindow-1><code>esi.window.unwrap</code> (::circt::esi::UnwrapWindow)</h3><p><em>Unwrap a data window into a union</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.window.unwrap` $window attr-dict `:` qualified(type($window))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-25>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>window</code></td><td>a data window</td></tr></tbody></table><h4 id=results-25>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>frame</code></td><td>a UnionType</td></tr></tbody></table><h3 id=esiwrapfifo-circtesiwrapfifoop-1><code>esi.wrap.fifo</code> (::circt::esi::WrapFIFOOp)</h3><p><em>Wrap a value into an ESI port with FIFO signaling</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.wrap.fifo` $data `,` $empty attr-dict `:`
              custom&lt;WrapFIFOType&gt;(type($data), type($chanOutput))
</code></pre><p>Interfaces: <code>ChannelOpInterface</code></p><h4 id=operands-26>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr><tr><td style=text-align:center><code>empty</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-26>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanOutput</code></td><td>an ESI channel</td></tr><tr><td style=text-align:center><code>rden</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiwrapiface-circtesiwrapsvinterfaceop-1><code>esi.wrap.iface</code> (::circt::esi::WrapSVInterfaceOp)</h3><p><em>Wrap an SV interface into an ESI port</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.wrap.iface` $interfaceSink attr-dict `:` qualified(type($interfaceSink)) `-&gt;` qualified(type($output))
</code></pre><p>Wrap a SystemVerilog interface into an ESI channel. Interface MUST look
like an interface produced by ESI meaning it MUST contain valid, ready,
and data signals. Any other signals will be discarded.</p><p>Interfaces: <code>ChannelOpInterface</code></p><h4 id=operands-27>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>interfaceSink</code></td><td>sv.interface</td></tr></tbody></table><h4 id=results-27>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esiwrapvr-circtesiwrapvalidreadyop-1><code>esi.wrap.vr</code> (::circt::esi::WrapValidReadyOp)</h3><p><em>Wrap a value into an ESI port</em></p><p>Wrapping a value into an ESI port type allows modules to send values down
an ESI port. Wrap data with valid bit, result is the ESI channel and the
ready signal from the other end of the channel.</p><p>Interfaces: <code>ChannelOpInterface</code></p><h4 id=operands-28>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rawInput</code></td><td>any type</td></tr><tr><td style=text-align:center><code>valid</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-28>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanOutput</code></td><td>an ESI channel</td></tr><tr><td style=text-align:center><code>ready</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiwindowwrap-circtesiwrapwindow-1><code>esi.window.wrap</code> (::circt::esi::WrapWindow)</h3><p><em>Wrap a union into a data window</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.window.wrap` $frame attr-dict `:` custom&lt;InferWindowRet&gt;(type($frame), type($window))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-29>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>frame</code></td><td>a UnionType</td></tr></tbody></table><h4 id=results-29>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>window</code></td><td>a data window</td></tr></tbody></table><h3 id=esimanifesthier_node-circtesiappidhiernodeop-1><code>esi.manifest.hier_node</code> (::circt::esi::AppIDHierNodeOp)</h3><p><em>A node in the AppID hierarchy</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.manifest.hier_node` qualified($appID) `mod` $moduleRef attr-dict-with-keyword $children
</code></pre><p>Traits: <code>HasParent&lt;circt::esi::AppIDHierRootOp, circt::esi::AppIDHierNodeOp></code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><h4 id=attributes-19>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>appID</code></td><td>::circt::esi::AppIDAttr</td><td>An application relevant instance identifier</td></tr><tr><td><code>moduleRef</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h3 id=esimanifesthier_root-circtesiappidhierrootop-1><code>esi.manifest.hier_root</code> (::circt::esi::AppIDHierRootOp)</h3><p><em>The root of an appid instance hierarchy</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.manifest.hier_root` $topModuleRef attr-dict-with-keyword $children
</code></pre><p>Traits: <code>HasParent&lt;mlir::ModuleOp></code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><h4 id=attributes-20>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>topModuleRef</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h3 id=esibuffer-circtesichannelbufferop-2><code>esi.buffer</code> (::circt::esi::ChannelBufferOp)</h3><p><em>Control options for an ESI channel.</em></p><p>A channel buffer (<code>buffer</code>) is essentially a set of options on a channel.
It always adds at least one cycle of latency (pipeline stage) to the
channel, but this is configurable.</p><p>This operation is inserted on an ESI dataflow edge. It must exist
previous to SystemVerilog emission but can be added in a lowering pass.</p><p>A <code>stages</code> attribute may be provided to specify a specific number of cycles
(pipeline stages) to use on this channel. Must be greater than 0.</p><p>A <code>name</code> attribute may be provided to assigned a name to a buffered
connection.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%esiChan</span> <span class=p>=</span> hw<span class=p>.</span>instance <span class=s>&#34;sender&#34;</span> <span class=nf>@Sender</span> <span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl><span class=c>// Allow automatic selection of options.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%bufferedChan</span> <span class=p>=</span> esi<span class=p>.</span>buffer <span class=nv>%esiChan</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>hw<span class=p>.</span>instance <span class=s>&#34;recv&#34;</span> <span class=nf>@Reciever</span> <span class=p>(</span><span class=nv>%bufferedChan</span><span class=p>)</span> <span class=p>:</span> <span class=p>(!</span>esi<span class=p>.</span>channel<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Alternatively, specify the number of stages.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%fourStageBufferedChan</span> <span class=p>=</span> esi<span class=p>.</span>buffer <span class=nv>%esiChan</span> <span class=p>{</span> <span class=nl>stages =</span> <span class=m>4</span> <span class=p>}</span> <span class=p>:</span> <span class=k>i1</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ChannelOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-21>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>stages</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 1</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-30>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>input</code></td><td>an ESI channel</td></tr></tbody></table><h4 id=results-30>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esimanifestcompressed-circtesicompressedmanifestop-1><code>esi.manifest.compressed</code> (::circt::esi::CompressedManifestOp)</h3><p><em>A zlib-compressed JSON manifest</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.manifest.compressed` $compressedManifest attr-dict
</code></pre><h4 id=attributes-22>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>compressedManifest</code></td><td>::circt::esi::BlobAttr</td><td>A binary blob</td></tr></table><h3 id=esicosimfrom_host-circtesicosimfromhostendpointop-2><code>esi.cosim.from_host</code> (::circt::esi::CosimFromHostEndpointOp)</h3><p><em>Co-simulation endpoint receiving data from the host</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.cosim.from_host` $clk `,` $rst `,` $id attr-dict `:` qualified(type($fromHost))
</code></pre><p>A co-simulation endpoint is a connection from the simulation to some
outside process, usually a software application responsible for driving
the simulation (driver).</p><p>It is uni-directional, in this case receiving data from the host for the
simulation.</p><p>NOTE: $id MUST be unique across all endpoints at simulation runtime.</p><h4 id=attributes-23>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-31>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-31>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fromHost</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esicosimto_host-circtesicosimtohostendpointop-2><code>esi.cosim.to_host</code> (::circt::esi::CosimToHostEndpointOp)</h3><p><em>Co-simulation endpoint sending data to the host.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.cosim.to_host` $clk `,` $rst `,` $toHost`,` $id attr-dict `:` qualified(type($toHost))
</code></pre><p>A co-simulation endpoint is a connection from the simulation to some
outside process, usually a software application responsible for driving
the simulation (driver).</p><p>It is uni-directional, in this case sending data from the simulation to the
host.</p><p>NOTE: $id MUST be unique across all endpoints at simulation runtime.</p><h4 id=attributes-24>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-32>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>toHost</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esiservicedecl-circtesicustomservicedeclop-1><code>esi.service.decl</code> (::circt::esi::CustomServiceDeclOp)</h3><p><em>An ESI service interface declaration</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.decl` $sym_name $ports attr-dict
</code></pre><p>A declaration of an ESI service interface. Defines a contract between a
service provider and its clients.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>esi<span class=p>.</span>service<span class=p>.</span>decl <span class=nf>@HostComms</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  esi<span class=p>.</span>service<span class=p>.</span>port send <span class=p>:</span> <span class=p>!</span>esi<span class=p>.</span>bundle<span class=p>&lt;[!</span>esi<span class=p>.</span>any from <span class=s>&#34;send&#34;</span><span class=p>]&gt;</span>
</span></span><span class=line><span class=cl>  esi<span class=p>.</span>service<span class=p>.</span>port recieve <span class=p>:</span> <span class=p>!</span>esi<span class=p>.</span>channel<span class=p>&lt;[</span><span class=k>i8</span> to <span class=s>&#34;recv&#34;</span><span class=p>]&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>HasParent&lt;::mlir::ModuleOp></code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>ServiceDeclOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-25>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=esiservicestdfunc-circtesifuncservicedeclop><code>esi.service.std.func</code> (::circt::esi::FuncServiceDeclOp)</h3><p><em>Function service</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.std.func` $sym_name attr-dict
</code></pre><p>Declares a service which provides a function call interface to a client.</p><p>Ports:
to_client call(args: any) -> result: any
Client exposes a function call interface to the user and does not allow
out-of-order returns.</p><p>TODO: ports for out-of-order returns</p><p>Traits: <code>HasParent&lt;::mlir::ModuleOp></code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>ServiceDeclOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-26>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=esiservicestdmmio-circtesimmioservicedeclop><code>esi.service.std.mmio</code> (::circt::esi::MMIOServiceDeclOp)</h3><p><em>MMIO service</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.std.mmio` $sym_name attr-dict
</code></pre><p>Declares a service to be backed by a MMIO interface, which is platform
dependent. Must be implemented by a BSP.</p><p>Traits: <code>HasParent&lt;::mlir::ModuleOp></code></p><p>Interfaces: <code>ServiceDeclOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-27>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=esinull-circtesinullsourceop-2><code>esi.null</code> (::circt::esi::NullSourceOp)</h3><p><em>An op which never produces messages.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.null` attr-dict `:` qualified(type($out))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-32>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esibundlepack-circtesipackbundleop-2><code>esi.bundle.pack</code> (::circt::esi::PackBundleOp)</h3><p><em>Pack channels into a bundle</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.bundle.pack` $toChannels attr-dict `:` custom&lt;UnPackBundleType&gt;(
              type($toChannels), type($fromChannels), type($bundle))
</code></pre><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=operands-33>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>toChannels</code></td><td>variadic of an ESI channel</td></tr></tbody></table><h4 id=results-33>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>bundle</code></td><td>a bundle of channels</td></tr><tr><td style=text-align:center><code>fromChannels</code></td><td>variadic of an ESI channel</td></tr></tbody></table><h3 id=esistage-circtesipipelinestageop-2><code>esi.stage</code> (::circt::esi::PipelineStageOp)</h3><p><em>An elastic buffer stage.</em></p><p>An individual elastic pipeline register. Generally lowered to from a
ChannelBuffer (&lsquo;buffer&rsquo;), though can be inserted anywhere to add an
additional pipeline stage. Adding individually could be useful for
late-pass latency balancing.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ChannelOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-34>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>input</code></td><td>an ESI channel</td></tr></tbody></table><h4 id=results-34>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esimemram-circtesirandomaccessmemorydeclop><code>esi.mem.ram</code> (::circt::esi::RandomAccessMemoryDeclOp)</h3><p><em>Random access memory service</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.mem.ram` $sym_name $innerType `x` $depth attr-dict
</code></pre><p>Declares a service which is backed by a memory of some sort. Allows random
access of the inner elements.</p><p>Ports:
read(address: clog2(depth)) -> data: innerType
write({address: clog2(depth), data: innerType}) -> done: i0</p><p>Users can ensure R/W ordering by waiting for the write &ldquo;done&rdquo; message before
issuing a potentially dependant read. Ordering of R/W messages in flight is
undefined.</p><p>Traits: <code>HasParent&lt;::mlir::ModuleOp></code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>ServiceDeclOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-28>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>innerType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>depth</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h3 id=esiservicereq-circtesirequestconnectionop-1><code>esi.service.req</code> (::circt::esi::RequestConnectionOp)</h3><p><em>Request a connection to receive data</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.req` $servicePort `(` qualified($appID) `)`
              attr-dict `:` qualified(type($toClient))
</code></pre><p>Interfaces: <code>HasAppID</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-29>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>servicePort</code></td><td>::circt::hw::InnerRefAttr</td><td>Refer to a name inside a module</td></tr><tr><td><code>appID</code></td><td>::circt::esi::AppIDAttr</td><td>An application relevant instance identifier</td></tr></table><h4 id=results-35>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>toClient</code></td><td>a bundle of channels</td></tr></tbody></table><h3 id=esiserviceport-circtesiservicedeclportop-1><code>esi.service.port</code> (::circt::esi::ServiceDeclPortOp)</h3><p><em>An ESI service bundle being received by the client</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.port` $inner_sym  attr-dict `:` $toClientType
</code></pre><p>Traits: <code>HasParent&lt;::circt::esi::CustomServiceDeclOp></code></p><h4 id=attributes-30>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inner_sym</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>toClientType</code></td><td>::mlir::TypeAttr</td><td>type attribute of a bundle of channels</td></tr></table><h3 id=esimanifestimpl_conn-circtesiserviceimplclientrecordop-1><code>esi.manifest.impl_conn</code> (::circt::esi::ServiceImplClientRecordOp)</h3><p><em>Details of a service implementation client connection</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.manifest.impl_conn` $relAppIDPath `req` $servicePort `(` $bundleType `)`
              `with` $implDetails attr-dict
</code></pre><p>A record containing all the necessary details of how to connect to a client
which the parent service record is servicing.</p><p>Traits: <code>HasParent&lt;ServiceImplRecordOp></code></p><p>Interfaces: <code>IsManifestData</code></p><h4 id=attributes-31>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>relAppIDPath</code></td><td>::mlir::ArrayAttr</td><td>Array of AppIDs</td></tr><tr><td><code>servicePort</code></td><td>::circt::hw::InnerRefAttr</td><td>Refer to a name inside a module</td></tr><tr><td><code>bundleType</code></td><td>::mlir::TypeAttr</td><td>type attribute of a bundle of channels</td></tr><tr><td><code>implDetails</code></td><td>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr></table><h3 id=esimanifestservice_impl-circtesiserviceimplrecordop-1><code>esi.manifest.service_impl</code> (::circt::esi::ServiceImplRecordOp)</h3><p><em>Record of a service implementation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.manifest.service_impl` qualified($appID) (`svc` $service^)? (`std` $stdService^)?
              `by` $serviceImplName `with` $implDetails
              attr-dict-with-keyword custom&lt;ServiceImplRecordReqDetails&gt;($reqDetails)
</code></pre><p>A record of a service implementation. Optionally emitted by the service
implementation. Contains information necessary to connect to the service and
service clients.</p><p>Traits: <code>NoTerminator</code></p><p>Interfaces: <code>HasAppID</code>, <code>IsManifestData</code></p><h4 id=attributes-32>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>appID</code></td><td>::circt::esi::AppIDAttr</td><td>An application relevant instance identifier</td></tr><tr><td><code>service</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>stdService</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>serviceImplName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>implDetails</code></td><td>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr></table><h3 id=esiserviceimpl_reqreq-circtesiserviceimplementconnreqop-1><code>esi.service.impl_req.req</code> (::circt::esi::ServiceImplementConnReqOp)</h3><p><em>The canonical form of a connection request</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.impl_req.req` $servicePort `(` $relativeAppIDPath `)`
              attr-dict `:` qualified(type($toClient))
</code></pre><p>Interfaces: <code>SymbolUserOpInterface</code></p><h4 id=attributes-33>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>servicePort</code></td><td>::circt::hw::InnerRefAttr</td><td>Refer to a name inside a module</td></tr><tr><td><code>relativeAppIDPath</code></td><td>::mlir::ArrayAttr</td><td>Array of AppIDs</td></tr></table><h4 id=results-36>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>toClient</code></td><td>a bundle of channels</td></tr></tbody></table><h3 id=esiserviceimpl_req-circtesiserviceimplementreqop-1><code>esi.service.impl_req</code> (::circt::esi::ServiceImplementReqOp)</h3><p><em>Request for a service to be implemented</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.impl_req` qualified($appID) (`svc` $service_symbol^)? `impl` `as` $impl_type
              (`std` $stdService^)? (`opts` $impl_opts^)? `(` $inputs `)`
              attr-dict `:` functional-type($inputs, results)
              $portReqs
</code></pre><p>The connect services pass replaces <code>service.instance</code>s with this op. The
<code>portReqs</code> region is the set of connection requests which need to be
implemented for this service instance. Channels to/from the requests have
been added to the operands/results of this op and consumers/producers have
been redirected.</p><p>Some other pass or frontend is expected to replace this op with an actual
implementation.</p><p>Traits: <code>NoTerminator</code></p><p>Interfaces: <code>HasAppID</code></p><h4 id=attributes-34>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>appID</code></td><td>::circt::esi::AppIDAttr</td><td>An application relevant instance identifier</td></tr><tr><td><code>service_symbol</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>impl_type</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>stdService</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>impl_opts</code></td><td>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr></table><h4 id=operands-35>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-37>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=esiserviceinstance-circtesiserviceinstanceop-1><code>esi.service.instance</code> (::circt::esi::ServiceInstanceOp)</h3><p><em>Instantiate a server module</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.service.instance` qualified($appID) (`svc` $service_symbol^)? `impl` `as` $impl_type
              (`opts` $impl_opts^)? `(` $inputs `)`
              attr-dict `:` functional-type($inputs, results)
</code></pre><p>Instantiate a service adhering to a service declaration interface.</p><p>A pass collects all of the connection requests to the service this op
implements from the containing modules&rsquo; descendants (in the instance
hierarchy). It bubbles them all up to the module containing this op,
creating the necessary ESI channel ports, groups them appropriately, then
replaces this op with a <code>service.impl_req</code>.</p><p>If &lsquo;service_symbol&rsquo; isn&rsquo;t specified, this instance will be used to implement
all of the service requests which get surfaced to here. This option is
generally used at the top level to specify host connectivity.</p><p>Since implementing the server will usually need &ldquo;normal&rdquo; I/O, <code>inputs</code> and
<code>results</code> act like normal <code>hw.instance</code> ports.</p><p>$identifier is used by frontends to specify or remember the type of
implementation to use for this service.</p><p>Interfaces: <code>HasAppID</code></p><h4 id=attributes-35>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>appID</code></td><td>::circt::esi::AppIDAttr</td><td>An application relevant instance identifier</td></tr><tr><td><code>service_symbol</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>impl_type</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>impl_opts</code></td><td>::mlir::DictionaryAttr</td><td>dictionary of named attribute values</td></tr></table><h4 id=operands-36>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-38>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>variadic of any type</td></tr></tbody></table><h3 id=esimanifestreq-circtesiservicerequestrecordop-1><code>esi.manifest.req</code> (::circt::esi::ServiceRequestRecordOp)</h3><p><em>Record of a service request</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.manifest.req` qualified($requestor) `,` $servicePort (`std` $stdService^)?
              `,` $bundleType attr-dict
</code></pre><p>A record of a service request, including the requestor, the service
requested, and the parameters of the request. Emitted before connecting the
service to preserve metadata about the original request.</p><p>Interfaces: <code>HasAppID</code>, <code>IsManifestData</code></p><h4 id=attributes-36>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>requestor</code></td><td>::circt::esi::AppIDAttr</td><td>An application relevant instance identifier</td></tr><tr><td><code>servicePort</code></td><td>::circt::hw::InnerRefAttr</td><td>Refer to a name inside a module</td></tr><tr><td><code>stdService</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>bundleType</code></td><td>::mlir::TypeAttr</td><td>type attribute of a bundle of channels</td></tr></table><h3 id=esimanifestsym-circtesisymbolmetadataop-1><code>esi.manifest.sym</code> (::circt::esi::SymbolMetadataOp)</h3><p><em>Metadata about a symbol</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.manifest.sym` $symbolRef
              (`name` $name^)?
              (`repo` $repo^)?
              (`commit` $commitHash^)?
              (`version` $version^)?
              (`summary` $summary^)?
              attr-dict
</code></pre><p>Metadata about a symbol, including its name, repository, commit hash,
version, and summary. All are optional, but strongly encouraged. Any
additional metadata which users wish to attach should go as discardable
attributes.</p><p>Interfaces: <code>IsManifestData</code></p><h4 id=attributes-37>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>symbolRef</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>repo</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>commitHash</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>version</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>summary</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=esibundleunpack-circtesiunpackbundleop-2><code>esi.bundle.unpack</code> (::circt::esi::UnpackBundleOp)</h3><p><em>Unpack channels from a bundle</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.bundle.unpack` $fromChannels `from` $bundle attr-dict `:` custom&lt;UnPackBundleType&gt;(
              type($toChannels), type($fromChannels), type($bundle))
</code></pre><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=operands-37>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>bundle</code></td><td>a bundle of channels</td></tr><tr><td style=text-align:center><code>fromChannels</code></td><td>variadic of an ESI channel</td></tr></tbody></table><h4 id=results-39>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>toChannels</code></td><td>variadic of an ESI channel</td></tr></tbody></table><h3 id=esiunwrapfifo-circtesiunwrapfifoop-2><code>esi.unwrap.fifo</code> (::circt::esi::UnwrapFIFOOp)</h3><p><em>Unwrap a value from an ESI port into a FIFO interface</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.unwrap.fifo` $chanInput `,` $rden attr-dict `:` qualified(type($chanInput))
</code></pre><p>Interfaces: <code>ChannelOpInterface</code>, <code>InferTypeOpInterface</code></p><h4 id=operands-38>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanInput</code></td><td>an ESI channel</td></tr><tr><td style=text-align:center><code>rden</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-40>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr><tr><td style=text-align:center><code>empty</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiunwrapiface-circtesiunwrapsvinterfaceop-2><code>esi.unwrap.iface</code> (::circt::esi::UnwrapSVInterfaceOp)</h3><p><em>Unwrap an SV interface from an ESI port</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.unwrap.iface` $chanInput `into` $interfaceSource attr-dict `:` `(` qualified(type($chanInput)) `,` qualified(type($interfaceSource)) `)`
</code></pre><p>Unwrap an ESI channel into a SystemVerilog interface containing valid,
ready, and data signals.</p><p>Interfaces: <code>ChannelOpInterface</code></p><h4 id=operands-39>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanInput</code></td><td>an ESI channel</td></tr><tr><td style=text-align:center><code>interfaceSource</code></td><td>sv.interface</td></tr></tbody></table><h3 id=esiunwrapvr-circtesiunwrapvalidreadyop-2><code>esi.unwrap.vr</code> (::circt::esi::UnwrapValidReadyOp)</h3><p><em>Unwrap a value from an ESI port</em></p><p>Unwrapping a value allows operations on the contained value. Unwrap the
channel along with a ready signal that you generate. Result is the data
along with a valid signal.</p><p>Interfaces: <code>ChannelOpInterface</code></p><h4 id=operands-40>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanInput</code></td><td>an ESI channel</td></tr><tr><td style=text-align:center><code>ready</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-41>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rawOutput</code></td><td>any type</td></tr><tr><td style=text-align:center><code>valid</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiwindowunwrap-circtesiunwrapwindow-2><code>esi.window.unwrap</code> (::circt::esi::UnwrapWindow)</h3><p><em>Unwrap a data window into a union</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.window.unwrap` $window attr-dict `:` qualified(type($window))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-41>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>window</code></td><td>a data window</td></tr></tbody></table><h4 id=results-42>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>frame</code></td><td>a UnionType</td></tr></tbody></table><h3 id=esiwrapfifo-circtesiwrapfifoop-2><code>esi.wrap.fifo</code> (::circt::esi::WrapFIFOOp)</h3><p><em>Wrap a value into an ESI port with FIFO signaling</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.wrap.fifo` $data `,` $empty attr-dict `:`
              custom&lt;WrapFIFOType&gt;(type($data), type($chanOutput))
</code></pre><p>Interfaces: <code>ChannelOpInterface</code></p><h4 id=operands-42>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr><tr><td style=text-align:center><code>empty</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-43>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanOutput</code></td><td>an ESI channel</td></tr><tr><td style=text-align:center><code>rden</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiwrapiface-circtesiwrapsvinterfaceop-2><code>esi.wrap.iface</code> (::circt::esi::WrapSVInterfaceOp)</h3><p><em>Wrap an SV interface into an ESI port</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.wrap.iface` $interfaceSink attr-dict `:` qualified(type($interfaceSink)) `-&gt;` qualified(type($output))
</code></pre><p>Wrap a SystemVerilog interface into an ESI channel. Interface MUST look
like an interface produced by ESI meaning it MUST contain valid, ready,
and data signals. Any other signals will be discarded.</p><p>Interfaces: <code>ChannelOpInterface</code></p><h4 id=operands-43>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>interfaceSink</code></td><td>sv.interface</td></tr></tbody></table><h4 id=results-44>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>an ESI channel</td></tr></tbody></table><h3 id=esiwrapvr-circtesiwrapvalidreadyop-2><code>esi.wrap.vr</code> (::circt::esi::WrapValidReadyOp)</h3><p><em>Wrap a value into an ESI port</em></p><p>Wrapping a value into an ESI port type allows modules to send values down
an ESI port. Wrap data with valid bit, result is the ESI channel and the
ready signal from the other end of the channel.</p><p>Interfaces: <code>ChannelOpInterface</code></p><h4 id=operands-44>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rawInput</code></td><td>any type</td></tr><tr><td style=text-align:center><code>valid</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-45>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>chanOutput</code></td><td>an ESI channel</td></tr><tr><td style=text-align:center><code>ready</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=esiwindowwrap-circtesiwrapwindow-2><code>esi.window.wrap</code> (::circt::esi::WrapWindow)</h3><p><em>Wrap a union into a data window</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.window.wrap` $frame attr-dict `:` custom&lt;InferWindowRet&gt;(type($frame), type($window))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-45>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>frame</code></td><td>a UnionType</td></tr></tbody></table><h4 id=results-46>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>window</code></td><td>a data window</td></tr></tbody></table><h2 id=structural>Structural</h2><p>ESI has a special module which doesn&rsquo;t expose ports. All external interactions
are expected to be done through services.</p><h3 id=esipure_moduleinput-circtesiesipuremoduleinputop><code>esi.pure_module.input</code> (::circt::esi::ESIPureModuleInputOp)</h3><p><em>Inputs become input ports when the module is lowered</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.pure_module.input` $name attr-dict `:` type($value)
</code></pre><p>To create input ports when lowering a pure module op into an HWModuleOp, use
this op. This op is typically created by a service implementation generator.</p><p>If two &lsquo;input&rsquo; ops exist in the same block, the names match, and the type
matches they&rsquo;ll become one port during lowering. Two or more may not exist
with the same name and different types. Useful for &lsquo;clk&rsquo; and &lsquo;rst&rsquo;.</p><p>Traits: <code>HasParent&lt;ESIPureModuleOp></code></p><h4 id=attributes-38>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-47>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h3 id=esipure_module-circtesiesipuremoduleop><code>esi.pure_module</code> (::circt::esi::ESIPureModuleOp)</h3><p><em>ESI pure module</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.pure_module` $sym_name attr-dict-with-keyword $body
</code></pre><p>A module containing only ESI channels and modules with only ESI ports. All
non-local connectivity is done through ESI services. If this module is the
top level in the design, then the design&rsquo;s actual top level ports are
defined by a BSP.</p><p>Useful on its own for simulation and BSPs which don&rsquo;t define a top-level.</p><p>Traits: <code>HasParent&lt;mlir::ModuleOp></code>, <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>HWModuleLike</code>, <code>InstanceGraphModuleOpInterface</code>, <code>PortList</code>, <code>RegionKindInterface</code>, <code>Symbol</code></p><h4 id=attributes-39>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=esipure_moduleoutput-circtesiesipuremoduleoutputop><code>esi.pure_module.output</code> (::circt::esi::ESIPureModuleOutputOp)</h3><p><em>Outputs become output ports when the module is lowered</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.pure_module.output` $name `,` $value attr-dict `:` type($value)
</code></pre><p>To create output ports when lowering a pure module op into an HWModuleOp, use
this op. This op is typically created by a service implementation generator.</p><p>Two &lsquo;output&rsquo; ops with the same name cannot exist in the same block.</p><p>Traits: <code>HasParent&lt;ESIPureModuleOp></code></p><h4 id=attributes-40>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-46>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h3 id=esipure_moduleparam-circtesiesipuremoduleparamop><code>esi.pure_module.param</code> (::circt::esi::ESIPureModuleParamOp)</h3><p><em>Params become module parameters when the module is lowered</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `esi.pure_module.param` $name `:` $type attr-dict
</code></pre><p>Allows attaching parameters to modules which become HW module parameters
when lowering. Currently, they are ignored. Some low-level BSPs instantiate
modules with parameters. This allows the modules produced to accept
parameters so those BSPs can instantiate them.</p><p>Traits: <code>HasParent&lt;ESIPureModuleOp></code></p><h4 id=attributes-41>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h2 id=interfaces>Interfaces</h2><p>Misc CIRCT interfaces.</p><h2 id=channelopinterface-channelopinterface>ChannelOpInterface (<code>ChannelOpInterface</code>)</h2><p>&ldquo;An interface for operations which carries channel semantics.&rdquo;</p><h3 id=methods>Methods:</h3><h4 id=channeltype-1><code>channelType</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>circt</span><span class=o>::</span><span class=n>esi</span><span class=o>::</span><span class=n>ChannelType</span> <span class=n>channelType</span><span class=p>();</span>
</span></span></code></pre></div><p>&ldquo;Returns the channel type of this operation.&rdquo;
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=innertype><code>innerType</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>mlir</span><span class=o>::</span><span class=n>Type</span> <span class=n>innerType</span><span class=p>();</span>
</span></span></code></pre></div><p>&ldquo;Returns the inner type of this channel. This will be the type of the
data value of the channel, if the channel carries data semantics. Else,
return NoneType.&rdquo;
NOTE: This method <em>must</em> be implemented by the user.</p><h2 id=hasappid-hasappidopinterface>HasAppID (<code>HasAppIDOpInterface</code>)</h2><p>Op can be identified by an AppID.</p><h3 id=methods-1>Methods:</h3><h4 id=getappid><code>getAppID</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>::</span><span class=n>circt</span><span class=o>::</span><span class=n>esi</span><span class=o>::</span><span class=n>AppIDAttr</span> <span class=n>getAppID</span><span class=p>();</span>
</span></span></code></pre></div><p>Returns the AppID of this operation.
NOTE: This method <em>must</em> be implemented by the user.</p><h2 id=ismanifestdata-ismanifestdata>IsManifestData (<code>IsManifestData</code>)</h2><p>Op&rsquo;s attributes should be represented in the manifest.</p><h3 id=methods-2>Methods:</h3><h4 id=getmanifestclass><code>getManifestClass</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>static</span> <span class=n>StringRef</span> <span class=nf>getManifestClass</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the class name for this op.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getdetails><code>getDetails</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>getDetails</span><span class=p>(</span><span class=n>SmallVectorImpl</span><span class=o>&lt;</span><span class=n>NamedAttribute</span><span class=o>&gt;&amp;</span><span class=n>results</span><span class=p>);</span>
</span></span></code></pre></div><p>Populate results with the manifest data.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getdetailsasdict><code>getDetailsAsDict</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>DictionaryAttr</span> <span class=nf>getDetailsAsDict</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the manifest data from this op as an attribute.
NOTE: This method <em>must</em> be implemented by the user.</p><h2 id=servicedeclopinterface-servicedeclopinterface>ServiceDeclOpInterface (<code>ServiceDeclOpInterface</code>)</h2><p>Any op which represents a service declaration should implement this
interface.</p><h3 id=methods-3>Methods:</h3><h4 id=getportlist><code>getPortList</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>getPortList</span><span class=p>(</span><span class=n>llvm</span><span class=o>::</span><span class=n>SmallVectorImpl</span><span class=o>&lt;</span><span class=n>ServicePortInfo</span><span class=o>&gt;&amp;</span><span class=n>ports</span><span class=p>);</span>
</span></span></code></pre></div><p>Returns the list of interface ports for this service interface.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=gettypename><code>getTypeName</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>optional</span><span class=o>&lt;</span><span class=n>StringRef</span><span class=o>&gt;</span> <span class=n>getTypeName</span><span class=p>();</span>
</span></span></code></pre></div><p>Return a well-known name for this service type.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportinfo><code>getPortInfo</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>FailureOr</span><span class=o>&lt;</span><span class=n>ServicePortInfo</span><span class=o>&gt;</span> <span class=n>getPortInfo</span><span class=p>(</span><span class=n>StringAttr</span> <span class=n>portName</span><span class=p>);</span>
</span></span></code></pre></div><p>Get info on a particular port.
NOTE: This method <em>must</em> be implemented by the user.</p><h2>'esi' Dialect Docs</h2><ul><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/ title="Emission (Emit) Dialect Rationale"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Emission (Emit) Dialect Rationale</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/ESI/cosim/ title="ESI cosimulation model">Next - ESI cosimulation model <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class="active has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>