<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>'esi' Dialect on CIRCT</title><link>https://circt.llvm.org/docs/Dialects/ESI/</link><description>Recent content in 'esi' Dialect on CIRCT</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Jan 1970 00:00:00 +0000</lastBuildDate><atom:link href="https://circt.llvm.org/docs/Dialects/ESI/index.xml" rel="self" type="application/rss+xml"/><item><title>ESI cosimulation model</title><link>https://circt.llvm.org/docs/Dialects/ESI/cosim/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/cosim/</guid><description>Elastic Silicon Interfaces provides a feature called cosimulation. Cosim in general allows communication between the simulation and software. In the ESI case, it is typed and can be used to build an application and language specific API which is nearly identical to how the real hardware would interface. This allows users to simulate against the actual target software (or some simplification of it), enabling easier co-design.
ESI cosim uses Cap&amp;rsquo;nProto as a message format and RPC client/server.</description></item><item><title>ESI data types and communication types</title><link>https://circt.llvm.org/docs/Dialects/ESI/types/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/types/</guid><description>ESI has two different classes of MLIR types: ones which represent data on the wires (data types) and ones which specify the type of communication. From a user perspective, communication types aren&amp;rsquo;t really types &amp;ndash; this is just how the communication style is modeled in MLIR and thus an implementation detail.
Data types In addition to the types in the hw dialect, ESI will add few:
Void void translates to &amp;ldquo;no data&amp;rdquo;, meaning just a control signal.</description></item><item><title>ESI Global Services</title><link>https://circt.llvm.org/docs/Dialects/ESI/services/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/services/</guid><description>This section not fully fleshed out and suffers from poor writing.
ESI will provide access to global resource via ESI Services. These &amp;ldquo;buses&amp;rdquo; define a typed interface and instances are instantiated globally &amp;ndash; they should be accessible at all levels of the design hierarchy. ESI services are intended to provide access to truly global resources like PCIe, shared DMA engines, DRAM, network interfaces, etc. They are generic enough to be extended to non-physical interfaces like telemetry &amp;ndash; if you have a centralized telemetry reporting engine, you probably want any module or submodule in the design to be able to access and report to it.</description></item><item><title>ESI Software APIs</title><link>https://circt.llvm.org/docs/Dialects/ESI/software_api/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/software_api/</guid><description>More on this to be written.
Status: unimplemented
Thanks to ESI&amp;rsquo;s strong static typing, typed, design-dependent software APIs can be automatically generated. Said APIs would be mostly independent of the transport mechanism (PCIe, network, etc.) used to communicate with the silicon. The same API could even drive a simulation of the ESI system.
Said APIs would need to ensure that the software is talking to the correct hardware. There are several possible approaches:</description></item><item><title>Miscellaneous Notes</title><link>https://circt.llvm.org/docs/Dialects/ESI/notes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/notes/</guid><description>ABI The ABI specifies how an ESI &amp;ldquo;API&amp;rdquo; is translated to hardware, specifically RTL. This involves both the wire-level signaling between modules and how data is arranged on those wires.
This section is purposely underspecified in this proposal as it should be an implementation detail which only advanced users need know. The main issues discussed here are how lists and data windows are lowered and presented to RTL modules. Lowering of fixed-size, default-presentation semantics ports is mostly straight forward, so is not discussed here.</description></item><item><title>The Elastic Silicon Interconnect dialect</title><link>https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/</guid><description>Long ago, software function calling conventions were ad-hoc. This led to issues, particularly with register clobbering and stack corruption. This is &amp;ndash; in large part &amp;ndash; the state of FPGA/ASIC design today: wire signaling protocols are often ad-hoc, which also leads to major issues. Though there are efforts to standardize the signaling protocols there are many minor and major variants, both of which lead to confusion which can cause real problems when one is listening to and twiddling the wires manually.</description></item></channel></rss>