<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>FIRRTL Dialect Rationale - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>FIRRTL Dialect Rationale</h1><p>This document describes various design points of the FIRRTL dialect, why it is
the way it is, and current status and progress. This follows in the spirit of
other
<a href=https://mlir.llvm.org/docs/Rationale/>MLIR Rationale docs</a>.</p><h2 id=introduction>Introduction&nbsp;<a class=headline-hash href=#introduction>¶</a></h2><p><a href=https://github.com/chipsalliance/firrtl>The FIRRTL project</a> is an existing
open source compiler infrastructure used by the Chisel framework to lower &ldquo;.fir&rdquo;
files to Verilog. It provides a number of useful compiler passes and
infrastructure that allows the development of domain specific passes. The
FIRRTL project includes a
<a href=https://github.com/chipsalliance/firrtl/blob/master/spec/spec.pdf>well documented IR
specification</a>
that explains the semantics of its IR, an
<a href=https://github.com/chipsalliance/firrtl/blob/master/src/main/antlr4/FIRRTL.g4>ANTLR
grammar</a>
includes some extensions beyond it, and a compiler implemented in Scala which we
refer to as the <em>Scala FIRRTL Compiler</em> (SFC).</p><p><em>The FIRRTL dialect in CIRCT is designed to provide a drop-in replacement for
the SFC for the subset of FIRRTL IR that is produced by Chisel and in common
use.</em> The FIRRTL dialect also provides robust support for SFC <em>Annotations</em>.</p><p>To achieve these goals, the FIRRTL dialect follows the FIRRTL IR specification
and the SFC implementation almost exactly. Where the FIRRTL specification
allows for undefined behavior, FIRRTL dialect and its passes will choose the SFC
interpretation of specific undefined behavior. The small deviations we do make
are discussed below. Early versions of the FIRRTL dialect made <em>heavy
deviations</em> from FIRRTL IR and the SFC (see the Type Canonicalization section
below). These deviations, while elegant, led to difficult to resolve mismatches
with the SFC and the inability to verify FIRRTL IR. The remaining small
deviations introduced in the FIRRTL dialect are done to simplify the CIRCT
implementation of a FIRRTL compiler and to take advantage of MLIR&rsquo;s various
features.</p><p>This document generally assumes that you&rsquo;ve read and have a basic grasp of the
FIRRTL IR spec, and it can be occasionally helpful to refer to the ANTLR
grammar.</p><h2 id=status>Status&nbsp;<a class=headline-hash href=#status>¶</a></h2><p>The FIRRTL dialect and FIR parser is a generally complete implementation of the
FIRRTL specification and is actively maintained, tracking new enhancements. The
FIRRTL dialect supports some undocumented features and the &ldquo;CHIRRTL&rdquo; flavor of
FIRRTL IR that is produced from Chisel. The FIRRTL dialect has support for
parsing an SFC Annotation file consisting of only local annotations and
converting this to operation or argument attributes. Non-local annotations are
also supported.</p><p>There are some exceptions to the above:</p><ol><li>We don&rsquo;t support the <code>Fixed</code> types for fixed point numbers, and some
primitives associated with them.</li><li>We don&rsquo;t support <code>Interval</code> types</li></ol><p>Some of these may be research efforts that didn&rsquo;t gain broad adoption, in which
case we don&rsquo;t want to support them. However, if there is a good reason and a
community that would benefit from adding support for these, we can do so.</p><h2 id=naming>Naming&nbsp;<a class=headline-hash href=#naming>¶</a></h2><p>Names in Verilog form part of the public API of a design and are used for many
purposes and flows. Many things in verilog may have names, and those names
specify points of interaction with the design. For example, a wire has a name,
and one can monitor the value on the wire from a testbench by knowing this name.
Instances have names and form the core of hierarchical references through
designs. Even always blocks and loops can have names, which are required and
used.</p><p>It is therefore critical that Chisel, and by extension FIRRTL, have
language-level semantics about how entities are named and how named entities are
used and transformed. This must specify which entities with names in Chisel
generate predictable output. Since names serve multiple purposes in a design,
for example, debugging, test-bench attachment, hooks for physical layout, etc,
we must balance multiple needs. This section describes the base semantics,
which are conservative and aimed at enabling debugging. The CIRCT
implementation of a FIRRTL compiler provides options to change the name
preservation behavior to produce more debuggable or more optimized output.</p><p>Modules shall use the name given in Chisel, unless they conflict with a Verilog
reserved word, not withstanding de-duplication or relevant annotations on the
module.</p><p>Instances shall use the name given in Chisel, unless they conflict with a
Verilog reserved word. Instances have preferential use of the name in the
output in case of a conflict, after ports.</p><p>Chisel provides a &ldquo;Don&rsquo;t Touch&rdquo; annotation to protect entities from
transformation. A &ldquo;Don&rsquo;t Touch&rdquo; on a wire or node produces a wire in Verilog
and preserves the data-flow through that wire. Even a wire driven by a constant
shall not have the constant forwarded around the wire. This is because a &ldquo;Don&rsquo;t
Touch&rdquo; annotation signals the possible public use of a wire and one common use
is to provide a place to drive a new value into the logic from an external
test-bench. If the node or wire is named (and it always should be for Chisel
&ldquo;Don&rsquo;t Touch&rdquo;), this name is used, unless it conflicts with a Verilog reserved
word. This wire has preferential use of the name in the output in case of a
conflict, after ports and instances.</p><p>Named wires and nodes in FIRRTL shall appear as a wire in the output verilog.
There is no requirement that data-flow through a wire be maintained, only that
the data-flow into a wire be maintained. This allows bypassing and forwarding
around wires who exist solely because of their name. An implementation may
choose to not bypass trivial wires to reduce unused wire lint warnings, but
shouldn&rsquo;t cause other lint warnings to avoid unused wire warnings. A named wire
without a symbol is thus equivalent to a named read-probe in the circuit.</p><p>Any name of an entity inside a module which starts with <code>_</code> may be discarded.
This name pattern indicates the name is for convenience in the Chisel code
(often temporaries are required) and there is no expectation it exist in the
output.</p><h3 id=mandatory-renaming>Mandatory Renaming&nbsp;<a class=headline-hash href=#mandatory-renaming>¶</a></h3><p>We want the naming of Verilog objects to match the names used in the original
Chisel, but in several passes, there is mandatory renaming. It is important
that this be a predictable transformation. For example, after bundles are
replaced with scalars in the lower-types pass, each field should be prefixed
with the bundle name:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-scala data-lang=scala><span class=line><span class=cl><span class=n>circuit</span> <span class=nc>Example</span>
</span></span><span class=line><span class=cl>  <span class=n>module</span> <span class=nc>Example</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>myreg</span><span class=k>:</span> <span class=o>{</span> <span class=kt>a</span> <span class=kt>:UInt&lt;</span><span class=err>1</span><span class=kt>&gt;</span><span class=o>,</span> <span class=kt>b:</span> <span class=kt>UInt&lt;</span><span class=err>1</span><span class=kt>&gt;</span> <span class=o>},</span> <span class=n>clock</span>
</span></span><span class=line><span class=cl><span class=o>;</span> <span class=n>firrtl</span><span class=o>-</span><span class=n>lower</span><span class=o>-</span><span class=n>types</span> <span class=k>=&gt;</span>
</span></span><span class=line><span class=cl><span class=n>circuit</span> <span class=nc>Example</span>
</span></span><span class=line><span class=cl>  <span class=n>module</span> <span class=nc>Example</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>myreg_a</span><span class=k>:</span> <span class=kt>UInt&lt;</span><span class=err>1</span><span class=kt>&gt;</span><span class=o>,</span> <span class=n>clock</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>myreg_b</span><span class=k>:</span> <span class=kt>UInt&lt;</span><span class=err>1</span><span class=kt>&gt;</span><span class=o>,</span> <span class=n>clock</span>
</span></span></code></pre></div><p>The name transformations applied by the SFC have become part of the documented
API, and people rely on the final names to take a certain form.</p><h3 id=temporaries>Temporaries&nbsp;<a class=headline-hash href=#temporaries>¶</a></h3><p>There are names for temporaries generated by the Chisel and FIRRTL tooling which
are not important to maintain. These names are discarded when parsing, which
saves memory during compilation. New names are generated at Verilog export time,
which has the effect of renumbering intermediate value names. Names generated
by Chisel typically look like <code>_T_12</code>, and names generated by the SFC look like
<code>_GEN_12</code>. The FIRRTL compiler will not discard these names if the object has an
array attribute <code>annotations</code> containing the attribute <code>{class = "firrtl.transforms.DontTouchAnnotation}</code>.</p><p>Chisel-generated temporaries will not be discarded in compilation modes which
preserve all names.</p><h3 id=name-preservation-modes>Name Preservation Modes&nbsp;<a class=headline-hash href=#name-preservation-modes>¶</a></h3><p>Name preservation modes, compiler options that produce different name
preservation behavior, was implemented as a compromise between two divergent and
seemingly irreconcilable goals:</p><ol><li><p>A FIRRTL to Verilog compiler should apply heavy optimizations to improve its
own performance (early optimizations produce smaller IR which means later
passes need to do less work) and to improve the performance of tools
consuming output Verilog, e.g., Verilog simulator compilation and run time.</p></li><li><p>Chisel users (design and verification engineers) want to see a one-to-one
correspondence between what they write in Chisel and the Verilog that a
FIRRTL compiler produces to enable debuggability.</p></li></ol><p>These two goals are viewed as irreconcilable because certain increases to
optimizations (1) necessarily detract from debuggability (2).</p><p>Currently CIRCT&rsquo;s FIRRTL compiler, <code>firtool</code>, provides two optimization modes,
debug and release, as well as finer grained options with lower-level flags:</p><ol><li><code>-O=release</code> (or <code>-preserve-values=none</code>) may delete any component as part of
an optimization.</li><li><code>-O=debug</code> (or <code>-preserve-values=named</code>) keeps components with names that do
not begin with a leading underscore.</li><li><code>-preserve-values=all</code>, which has no exposed <code>-O</code> option, keeps all
components.</li></ol><p>As an example of these modes consider the following FIRRTL circuit:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>circuit Foo:
  module Foo:
    input a: UInt&lt;1&gt;
    output b: UInt&lt;1&gt;

    node named = a
    node _unnamed = named

    b &lt;= _unnamed
</code></pre><p>When compiled with <code>-O=release</code> (or <code>--preserve-values=none</code>), no intermediary
nodes/wires are preserved because CIRCT inlines the usages of <code>a</code> into the
assignment to <code>b</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-verilog data-lang=verilog><span class=line><span class=cl><span class=k>module</span> <span class=n>Foo</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=k>input</span>  <span class=n>a</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=k>output</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>assign</span> <span class=n>b</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>endmodule</span>
</span></span></code></pre></div><p>When compiled with <code>-O=debug</code> (or <code>-preserve-values=named</code>), the <code>_unnamed</code> node
is removed, but the <code>named</code> node is preserved:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-verilog data-lang=verilog><span class=line><span class=cl><span class=k>module</span> <span class=n>Foo</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=k>input</span>  <span class=n>a</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=k>output</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>wire</span> <span class=n>named</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>assign</span> <span class=n>b</span> <span class=o>=</span> <span class=n>named</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>endmodule</span>
</span></span></code></pre></div><p>When compiled with <code>-preserve-values=all</code> this produces the following Verilog
that preserves all nodes, regardless of name:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-verilog data-lang=verilog><span class=line><span class=cl><span class=k>module</span> <span class=n>Foo</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=k>input</span>  <span class=n>a</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=k>output</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>wire</span> <span class=n>named</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>wire</span> <span class=n>_unnamed</span> <span class=o>=</span> <span class=n>named</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>assign</span> <span class=n>b</span> <span class=o>=</span> <span class=n>_unnamed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>endmodule</span>
</span></span></code></pre></div><p>Design teams are expected to use <code>-O=debug</code> debuggabilty. Verification teams
and downstream tools are expected to use/consume <code>-O=release</code>.</p><p>This split of two different Verilog outputs initially created reproducibility
problems that CIRCT has attempted to solve with a guarantee of stable
randomization. Consider a situation where a verification team trips an
assertion failure using a release build with a particular seed. Because release
Verilog is highly optimized and difficult to debug, they want to switch to a
debug build. If the release build seed does not reproduce the failure in debug
mode, the verification team needs to search for a failure. This proved to be a
drag on Chisel users. Towards alleviating this, CIRCT will now guarantee that
registers in debug or release mode will be randomized to the same value for the
same seed.</p><p>It is important to note that the debug/release split was born out of our
inability to reconcile the goals at the top of this section. Discussion in the
subsequent section involves approaches to unify these two approaches.</p><h4 id=alternative-approaches-to-name-preservation-modes-and-historical-background>Alternative Approaches to Name Preservation Modes and Historical Background&nbsp;<a class=headline-hash href=#alternative-approaches-to-name-preservation-modes-and-historical-background>¶</a></h4><p>The following alternatives were implemented or considered instead of the
debug/release solution.</p><p>First, we created dead wire taps <em>with symbols</em> for all &ldquo;named&rdquo; things in the
original FIRRTL design. We would then try to use these dead wire taps in place
of unnamed things when possible. This simple solution produced much more
readable Verilog. However, this also had a number of problems. Namely, leaving
in dead wire taps would result in situations where ports that downstream users
were expecting to be removed were not. E.g., a module with dead wire taps would
result in more ports at a physical design boundary. Additionally, leaving in
dead wire taps may introduce coverage holes for verification teams. We
attempted to remove dead wire taps when possible. However, this was problematic
as we had given them symbols which indicates that they may have external readers
(e.g., from a manually written testbench) and was intended to indicate that
later passes could never remove these. We considered using an alternative to a
symbol, but this was rejected due to its highly special-cased nature&mdash;it was
forcing us to communicate a Chisel expectation/semantic all the way to HW/SV
dialects.</p><p>These drawbacks are unfortunate because they stem from learned expectations of
how the Scala-based FIRRTL Compiler worked. A negative view of this is that
some level of optimization was required for a learned definition of correctness.
If CIRCT was the first FIRRTL compiler, we may have been able to circumvent
these problems with alternative means that included modifications to Chisel.</p><p>Second, we considered having CIRCT create &ldquo;debug modules&rdquo; that included all
named signals in the design. An instance of this debug module would then be
instantiated, via a SystemVerilog <code>bind</code> statement, inside the original module.
This was an early suggestion. However, a concern of users of any &ldquo;debug module&rdquo;
is that the debug module would not show usages of the named signals. E.g., the
example circuit shown above would compile to something like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-verilog data-lang=verilog><span class=line><span class=cl><span class=k>module</span> <span class=n>Foo_debug</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=k>input</span> <span class=n>_0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>wire</span> <span class=n>named</span> <span class=o>=</span> <span class=n>_0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>endmodule</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>bind</span> <span class=n>Foo</span> <span class=n>Foo_debug</span> <span class=n>Foo_debug</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=n>_0</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=n>Foo</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=k>input</span>  <span class=n>a</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=k>output</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>assign</span> <span class=n>b</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>endmodule</span>
</span></span></code></pre></div><p>The main concern is that while users can see the value of <code>named</code> in a waveform,
they cannot trace back its usage in the computation of port <code>b</code> in module <code>Foo</code>.
This approach also suffers from the issues of the first approach of leaving in
ports and dead logic (that is only used when a debug instance is bound in).</p><p>This approach may be revisited in the future as it provides benefits of unifying
debug and release builds into a single release build with run-time debugging
information that can be bound in. Additionally, use of FIRRTL <code>RefType</code>s that
lower to Verilog cross-module references (XMRs) may alleviate some of the issues
above.</p><p>Third, a single build that always preserved names was considered. At the time,
this introduced long Verilog compilation and simulation times. We were not able
to discern an optimization design point which balanced the needs of
debuggability with compilation and simulation performance. This does not mean
that such a point does <em>not</em> exist, only that we were not able to find it. Such
a design point may exist and should be investigated.</p><p>Since all these efforts happened, other work has occurred which may make
reviving these efforts a fruitful endeavor. FIRRTL now has <code>RefType</code>s which are
operations which lower to Verilog cross-module references (XMRs). This may
provide a mechanism to implement the &ldquo;bound debug instance&rdquo; approach above
without perturbing port optimizations. Reliance on symbols to encode
optimization blocking behavior has been largely rolled back. A
<code>DontTouchAnnotation</code> is now encoded as an annotation as opposed to a symbol. A
new inter-module dead code elimination (IMDCE) pass was implemented which
handles port removal. The approaches above, or new approaches, may be able to
build a better name preservation approach, but with certain optimizations
enabled.</p><h2 id=symbols-and-inner-symbols>Symbols and Inner Symbols&nbsp;<a class=headline-hash href=#symbols-and-inner-symbols>¶</a></h2><p>Symbols and Inner Symbols are documented in
<a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol
Rationale</a>. This documents how
symbols are used, their interaction with &ldquo;Don&rsquo;t Touch&rdquo;, and the semantics
imposed by them.</p><p>Public Symbols indicate there are uses of an entity outside the analysis scope
of the compiler. This requires the entity be preserved in such a way as the
operations possible in the target language have the expected effect. For
example, a wire or port with a public symbol may be used by name in a test bench
to read or write new values into the circuit. Therefore, these wires cannot be
detached form their original dataflow as this would break the remote write case,
nor can their input dataflow be changed, as this would break the remote read
case. They cannot be renamed, as this would break all remote access.</p><p>Private Symbols indicate there are symbolic references to the entity, but they
are all within the scope of the compiler&rsquo;s IR and analysis. An entity with a
private symbol may be arbitrarily transformed, so long as the transformation is
semantic preserving with respect to all uses of the private symbol. If it can
be proved a wire with a private symbol is only read from via its symbol and not
written to, for example, the input can forwarded to the output (bypassing the
wire) safely. If a private symbol is unused, it may be removed. Private
symbols impose no restriction on output; they only exist to enable non-local
effects in the IR.</p><p>&ldquo;Don&rsquo;t Touch&rdquo; is implemented as a public symbol on an entity. A conservative
interpretation of &ldquo;Don&rsquo;t Touch&rdquo;, and a common use case, is that the entity is
referred to by a testbench in unknown ways. This implies no transformation
which would change observed behavior if the entity was arbitrarily read or
written to remotely. This further implies the existence of the entity in the
output.</p><p>Importantly, the existence of a symbol doesn&rsquo;t specify whether something is
read-only, write-only, or read-write. Without analysis, a pass must assume the
most conservative case, and in the case of public symbols, must always assume
the most conservative case. To do better, all uses must be analyzed and
understood (e.g. a symbol used by a verbatim has unknown use).</p><h3 id=hierarchical-path>Hierarchical Path&nbsp;<a class=headline-hash href=#hierarchical-path>¶</a></h3><p>In the FIRRTL dialect, it might be necessary to identify specific instances of
operations in the instance hierarchy. The FIRRTL <code>HierPathOp</code> operation
(<code>firrtl.hierpath</code>) can be used to describe the path through an instance
hierarchy to a declaration, which can be used by other operations or non-local
annotations. Non-local anchors can refer to most declarations, such as modules,
instances, wires, registers, and memories.</p><p>The <code>firrtl.hierpath</code> operations defines a symbol and contains a namepath, which
is a list of <code>InnerRefAttr</code> and <code>FlatSymbolRefAttr</code> attributes. A
<code>FlatSymbolRefAttr</code> is used to identify modules, and is printed as <code>@Module</code>.
<code>InnerRefAttr</code> identifies a declaration inside a module, and is printed as
<code>@Module::@wire</code>. Each element along the Paths&rsquo;s namepath carries an annotation
with class <code>circt. nonlocal</code>, which has a matching <code>circt. nonlocal</code> field
pointing to the global op. Thus instances participating in nonlocal paths are
readily apparent.</p><p>In the following example, <code>@nla</code> specifies instance <code>@bar</code> in module <code>@Foo</code>,
followed by instance <code>@baz</code> in module <code>@Bar</code>, followed by the wire named <code>@w</code> in
module <code>@Baz</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>firrtl<span class=p>.</span>circuit <span class=s>&#34;Foo&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  firrtl<span class=p>.</span>hierpath <span class=nf>@nla</span> <span class=p>[</span><span class=nf>@Foo</span><span class=p>::</span><span class=nf>@bar</span><span class=p>,</span> <span class=nf>@Bar</span><span class=p>::</span><span class=nf>@baz</span><span class=p>,</span> <span class=nf>@Baz</span><span class=p>::</span><span class=nf>@w</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  firrtl<span class=p>.</span>module <span class=nf>@Baz</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%w</span> <span class=p>=</span> firrtl<span class=p>.</span>wire sym <span class=nf>@w</span> <span class=p>{</span><span class=nl>annotations =</span> <span class=p>[{</span><span class=nl>circt.nonlocal =</span> <span class=nf>@nla</span><span class=p>,</span> <span class=nl>class =</span> <span class=s>&#34;ExampleAnno&#34;</span><span class=p>}]}</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  firrtl<span class=p>.</span>module <span class=nf>@Bar</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    firrtl<span class=p>.</span>instance baz sym <span class=nf>@baz</span> <span class=p>{</span><span class=nl>annotations =</span> <span class=p>[{</span><span class=nl>circt.nonlocal =</span> <span class=nf>@nla</span><span class=p>,</span> <span class=nl>class =</span> <span class=s>&#34;circt.nonlocal&#34;</span><span class=p>}]}</span> <span class=nf>@Baz</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  firrtl<span class=p>.</span>module <span class=nf>@Foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    firrtl<span class=p>.</span>instance bar sym <span class=nf>@bar</span> <span class=p>{</span><span class=nl>annotations =</span> <span class=p>[{</span><span class=nl>circt.nonlocal =</span> <span class=nf>@nla</span><span class=p>,</span> <span class=nl>class =</span> <span class=s>&#34;circt.nonlocal&#34;</span><span class=p>}]}</span> <span class=nf>@Bar</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=type-system>Type system&nbsp;<a class=headline-hash href=#type-system>¶</a></h2><h3 id=not-using-standard-types>Not using standard types&nbsp;<a class=headline-hash href=#not-using-standard-types>¶</a></h3><p>At one point we tried to use the integer types in the standard dialect, like
<code>si42</code> instead of <code>!firrtl.sint&lt;42></code>, but we backed away from this. While it
originally seemed appealing to use those types, FIRRTL operations generally need
to work with &ldquo;unknown width&rdquo; integer types (i.e. <code>!firrtl.sint</code>).</p><p>Having the known width and unknown width types implemented with two different
C++ classes was awkward, led to casting bugs, and prevented having a
<code>FIRRTLType</code> class that unified all the FIRRTL dialect types.</p><h3 id=not-canonicalizing-flip-types>Not Canonicalizing Flip Types&nbsp;<a class=headline-hash href=#not-canonicalizing-flip-types>¶</a></h3><p>An initial version of the FIRRTL dialect relied on canonicalization of flip
types according to the following rules:</p><ol><li><code>flip(flip(x))</code> == <code>x</code>.</li><li><code>flip(analog(x))</code> == <code>analog(x)</code> since analog types are implicitly
bidirectional.</li><li><code>flip(bundle(a,b,c,d))</code> == <code>bundle(flip(a), flip(b), flip(c), flip(d))</code> when
the bundle has non-passive type or contains an analog type. This forces the
flip into the subelements, where it recursively merges with the non-passive
subelements and analogs.</li><li><code>flip(vector(a, n))</code> == <code>vector(flip(a), n)</code> when the vector has non-passive
type or analogs. This forces the flip into the element type, generally
canceling it out.</li><li><code>bundle(flip(a), flip(b), flip(c), flip(d))</code> == <code>flip(bundle(a, b, c, d)</code>.
Due to the other rules, the operand to a flip must be a passive type, so the
entire bundle will be passive, and rule #3 won&rsquo;t be recursively reinvoked.</li></ol><p>While elegant in a number of ways (e.g., FIRRTL types are guaranteed to have a
canonical representation and can be compared using pointer equality, flips
partially subsume port directionality and &ldquo;flow&rdquo;, and analog inputs and outputs
are canonicalized to the same representation), this resulted in information loss
during canonicalization because the number of flip types can change. Namely,
three problems were identified:</p><ol><li>Type canonicalization may make illegal operations legal.</li><li>The flow of connections could not be verified because flow is a function of
the number of flip types.</li><li>The directionality of leaves in an aggregate could not be determined.</li></ol><p>As an example of the first problem, consider the following circuit:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>module Foo:
  output a: { flip a: UInt&lt;1&gt; }
  output b: { a: UInt&lt;1&gt; }

  b &lt;= a
</code></pre><p>The connection <code>b &lt;= a</code> <em>is illegal</em> FIRRTL due to a type mismatch where <code>{ flip a: UInt&lt;1> }</code> is not equal to <code>{ a: UInt&lt;1> }</code>. However, type canonicalization
would transform this circuit into the following circuit:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>module Foo:
  input a: { a: UInt&lt;1&gt; }
  output b: { a: UInt&lt;1&gt; }

  b &lt;= a
</code></pre><p>Here, the connection <code>b &lt;= a</code> <em>is legal</em> FIRRTL. This then makes it impossible
for a type canonical form to be type checked.</p><p>As an example of the second problem, consider the following circuit:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>module Bar:
  output a: { flip a: UInt&lt;1&gt; }
  input b: { flip a: UInt&lt;1&gt; }

  b &lt;= a
</code></pre><p>Here, the connection <code>b &lt;= a</code> <em>is illegal</em> FIRRTL because <code>b</code> is a source and
<code>a</code> is a sink. However, type canonicalization converts this to the following
circuit:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>module Bar:
  input a: { a: UInt&lt;1&gt; }
  output b: { a: UInt&lt;1&gt; }

  b &lt;= a
</code></pre><p>Here, the connect <code>b &lt;= a</code> <em>is legal</em> FIRRTL because <code>b</code> is now a sink and <code>a</code>
is now a source. This then makes it impossible for a type canonical form to be
flow checked.</p><p>As an example of the third problem, consider the following circuit:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>module Baz:
  wire a: {flip a: {flip a: UInt&lt;1&gt;}}
  wire b: {flip a: {flip a: UInt&lt;1&gt;}}

  b.a &lt;= a.a
</code></pre><p>The connection <code>b.a &lt;= a.a</code>, when lowered, results in the <em>reverse</em> connect
<code>a.a.a &lt;= b.a.a</code>. However, type canonicalization will remove the flips from the
circuit to produce:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>module Baz:
  wire a: {a: {a: UInt&lt;1&gt;}}
  wire b: {a: {a: UInt&lt;1&gt;}}

  b.a &lt;= a.a
</code></pre><p>Here, the connect <code>b.a &lt;= a.a</code>, when lowered, results in the normal connect
<code>b.a.a &lt;= a.a.a</code>. Type canonicalization has thereby changed the semantics of
connect.</p><p>Due to the elegance of type canonicalization, we initially decided that we would
use type canonicalization and CIRCT would accept more circuits than the SFC.
The third problem (identified much later than the first two) convinced us to
remove type canonicalization.</p><p>For a historical discussion of type canonicalization see:</p><ul><li><a href=https://github.com/llvm/circt/issues/380><code>llvm/circt#380</code></a></li><li><a href=https://github.com/llvm/circt/issues/919><code>llvm/circt#919</code></a></li><li><a href=https://github.com/llvm/circt/pull/944><code>llvm/circt#944</code></a></li></ul><h3 id=flow>Flow&nbsp;<a class=headline-hash href=#flow>¶</a></h3><p>The FIRRTL specification describes the concept of &ldquo;flow&rdquo;. Flow encodes
additional information that determines the legality of operations. FIRRTL
defines three different flows: <code>sink</code>, <code>source</code>, and <code>duplex</code>. Module inputs,
instance outputs, and nodes are <code>source</code>, module outputs and instance inputs are
<code>sink</code>, and wires and registers are <code>duplex</code>. A value with <code>sink</code> flow may only
be written to, but not read from (with the exception of module outputs and
instance inputs which may be also read from). A value with <code>source</code> flow may be
read from, but not written to. A value with <code>duplex</code> flow may be read from or
written to.</p><p>For FIRRTL connect statements, it follows that the left-hand-side must be <code>sink</code>
or <code>duplex</code> and the right-hand-side must be <code>source</code>, <code>duplex</code>, or a
port/instance <code>sink</code>.</p><p>Flow is <em>not</em> represented as a first-class type in CIRCT. We instead provide
utilities for computing flow when needed, e.g., for connect statement
verification.</p><h3 id=non-firrtl-types>Non-FIRRTL Types&nbsp;<a class=headline-hash href=#non-firrtl-types>¶</a></h3><p>The FIRRTL dialect has limited support for foreign types, i.e., types that are
defined outside the FIRRTL dialect. Almost all operations expect to be dealing
with FIRRTL types, especially those that are sensitive to the type they operate
on, like <code>firrtl.add</code> or <code>firrtl.connect</code>. However, a restricted set of
operations allows for simple pass-through semantics of foreign types. These
include the following:</p><ul><li>Ports on a <code>firrtl.module</code>, where the foreign types are treated as opaque values moving in and out of the module</li><li>Ports on a <code>firrtl.instance</code></li><li><code>firrtl.wire</code> to allow for def-after-use cases; the wire must have a single strict connect that uniquely defines the wire&rsquo;s value</li><li><code>firrtl.strictconnect</code> to module outputs, instance inputs, and wires</li></ul><p>The expected lowering for strict connects is for the connect to be eliminated
and the right-hand-side source value of the connect being instead materialized
in all places where the left hand side is used. Basically we want wires and
connects to disappear, and all places where the wire is &ldquo;read&rdquo; should instead
read the value that was driven onto the wire.</p><p>The reason we provide this foreign type support is to allow for partial lowering
of FIRRTL to HW and other dialects. Passes might lower a subset of types and
operations to the target dialect and we need a mechanism to have the lowered
values be passed around the FIRRTL module hierarchy untouched alongside the
FIRRTL ops that are yet to be lowered.</p><h3 id=const-types>Const Types&nbsp;<a class=headline-hash href=#const-types>¶</a></h3><p>FIRRTL hardware types can be specified as <code>const</code>, meaning they can only be
assigned compile-time constant values or values of other <code>const</code> types.</p><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><h3 id=multiple-result-firrtlinstance-operation>Multiple result <code>firrtl.instance</code> operation&nbsp;<a class=headline-hash href=#multiple-result-firrtlinstance-operation>¶</a></h3><p>The FIRRTL spec describes instances as returning a bundle type, where each
element of the bundle corresponds to one of the ports of the module being
instanced. This makes sense in the Scala FIRRTL implementation, given that it
does not support multiple ports.</p><p>The MLIR FIRRTL dialect takes a different approach, having each element of the
bundle result turn into its own distinct result on the <code>firrtl.instance</code>
operation. This is made possible by MLIR&rsquo;s robust support for multiple value
operands, and makes the IR much easier to analyze and work with.</p><h3 id=module-bodies-require-def-before-use-dominance-instead-of-allowing-graphs>Module bodies require def-before-use dominance instead of allowing graphs&nbsp;<a class=headline-hash href=#module-bodies-require-def-before-use-dominance-instead-of-allowing-graphs>¶</a></h3><p>MLIR allows regions with arbitrary graphs in their bodies, and this is used by
the HW dialect to allow direct expression of cyclic graphs etc. While this
makes sense for hardware in general, the FIRRTL dialect is intended to be a
pragmatic infrastructure focused on lowering of Chisel code to the HW dialect,
it isn&rsquo;t intended to be a &ldquo;generally useful IR for hardware&rdquo;.</p><p>We recommend that non-Chisel frontends target the HW dialect, or a higher level
dialect of their own creation that lowers to HW as appropriate.</p><h3 id=input-and-output-module-ports><code>input</code> and <code>output</code> Module Ports&nbsp;<a class=headline-hash href=#input-and-output-module-ports>¶</a></h3><p>The FIRRTL specification describes two kinds of ports: <code>input</code> and <code>output</code>. In
the <code>firrtl.module</code> declaration we track this via an arbitrary precision integer
attribute (<code>IntegerAttr</code>) where each bit encodes the directionality of the port
at that index.</p><p>Originally, we encoded direction as the absence of an outer flip type (input) or
presence of an outer flip type (output). This was done as part of the original
type canonicalization effort which combined input/output with the type system.
However, once type canonicalization was removed flip type only became used in
three places: on the types of bundle fields, on the variadic return types of
instances or memories, and on ports. The first is the same as the FIRRTL
specification. The second is a deviation from the FIRRTL specification, but
allowable as it takes advantage of the MLIR&rsquo;s variadic capabilities to simplify
the IR. The third was an inelegant abuse of an unrelated concept that added
bloat to the type system. Many operations would have to check for an outer flip
on ports and immediately discard it.</p><p>For this reason, the <code>IntegerAttr</code> encoding implementation was chosen.</p><p>For a historical discussion of this issue and its development see:</p><ul><li><a href=https://github.com/llvm/circt/issues/989><code>llvm/circt#989</code></a></li><li><a href=https://github.com/llvm/circt/pull/992><code>llvm/circt#992</code></a></li></ul><h3 id=firrtlbitcast><code>firrtl.bitcast</code>&nbsp;<a class=headline-hash href=#firrtlbitcast>¶</a></h3><p>The bitcast operation represents a bitwise reinterpretation (cast) of a value.
It can be used to cast a vector or bundle type to an int type or vice-versa.
The bit width of input and result types must be known. For an aggregate type,
the bit width of every field must be known. This always synthesizes away in
hardware, and follows the same endianness policy as <code>hw.bitcast</code>.</p><h3 id=firrtlmem><code>firrtl.mem</code>&nbsp;<a class=headline-hash href=#firrtlmem>¶</a></h3><p>Unlike the SFC, the FIRRTL dialect represents each memory port as a distinct
result value of the <code>firrtl.mem</code> operation. Also, the <code>firrtl.mem</code> node does
not allow zero port memories for simplicity. Zero port memories are dropped by
the .fir file parser.</p><p>In the FIRRTL pipeline, the <code>firrtl.mem</code> op can be lowered into either a
external module for macro replacement or a register of vector type. The
conditions for macro replacement are as follows:</p><ol><li><code>–replSeqMem</code> option is passed and</li><li><code>readLatency == 1</code> and</li><li><code>writeLatency == 1</code> and</li><li><code>width(data) > 0</code></li></ol><p>Any <code>MemOp</code> not satisfying the above conditions is lowered to Register vector.</p><h4 id=memtoregofvec-transformation-outline>MemToRegOfVec transformation outline:&nbsp;<a class=headline-hash href=#memtoregofvec-transformation-outline>¶</a></h4><p>The <code>MemToRegOfVec</code> pass runs early in the pipeline, after the <code>LowerCHIRRTL</code>
pass and right before the <code>InferResets</code> pass.</p><ol><li>Select all MemOps that are not candidates for macro replacement,</li><li>Create a reg</li><li>Read ports return the value at the address when the enable signal is high.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>enable</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>readOut</span> <span class=o>=</span> <span class=k>register</span><span class=p>[</span><span class=n>address</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=4><li>Write ports store the value at the address when the mask signal is high.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>enable</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>mask</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>register</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>dataIn</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>mask</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>register</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>dataIn</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=handling-of-memtaps>Handling of MemTaps&nbsp;<a class=headline-hash href=#handling-of-memtaps>¶</a></h4><p>The <code>sifive.enterprise.grandcentral.MemTapAnnotation</code> annotation is attached to
the <code>MemOp</code> and the corresponding Memtap module ports. After lowering the memory
to registers, this annotation must be properly scattered such that
GrandCentralTaps can generate the appropriate code.</p><p>The memtap module has memtap annotations, where the number of ports with the
annotation is equal to the memory depth. In the <code>MemToRegOfVec</code> transformation,
after lowering the memory to the register vector, a subannotation is created for
each sub-field of the data and the
<code>sifive.enterprise.grandcentral.MemTapAnnotation</code> annotation is copied from the
original <code>MemOp</code>. The <code>LowerTypes</code> pass will handle the subannotations
appropriately.</p><h4 id=interaction-with-asyncreset-inference>Interaction with AsyncReset Inference&nbsp;<a class=headline-hash href=#interaction-with-asyncreset-inference>¶</a></h4><p>The <code>AsyncReset</code> pass runs right after the <code>MemToRegOfVec</code>. It will transform
the memory registers to async registers if the corresponding annotations are
present. Only if a <code>MemOp</code> had
<code>sifive.enterprise.firrtl.ExcludeMemFromMemToRegOfVec</code>, annotation, then it is
not converted to an async reset register.</p><h4 id=firrtlmem-attributes><code>firrtl.mem</code> Attributes&nbsp;<a class=headline-hash href=#firrtlmem-attributes>¶</a></h4><p>A <code>firrtl.mem</code> has the following properties:</p><ol><li>Data type</li><li>Mask bitwidth</li><li>Depth</li><li>Name</li><li>Number of read ports, write ports, read-write ports</li><li>Read under write behavior</li><li>Read latency</li><li>Write latency</li></ol><h5 id=mask-bitwidth>Mask bitwidth&nbsp;<a class=headline-hash href=#mask-bitwidth>¶</a></h5><p>Any aggregate memory data type is lowered to ground type by the <code>LowerTypes</code>
pass. After lowering the data type, the data bitwidth must be divisible by mask
bitwidth. And we define the property granularity as: <code>mask granularity = (Data bitwidth)/(Mask bitwidth)</code>.</p><p>Each mask bit can guard the write to <code>mask granularity</code> number of data bits.
For a single-bit mask, one-bit guards write to the data, hence <code>mask granularity = data bitwidth</code>.</p><h4 id=macro-replacement>Macro replacement&nbsp;<a class=headline-hash href=#macro-replacement>¶</a></h4><p>Memories that satisfy the conditions above are candidates for macro replacement.</p><p>A memory generator defines the external module definition corresponding to the
memory for macro replacement. Memory generators need metadata to generate the
memory definition. SFC uses some metadata files to communicate with the memory
generators.</p><p><code>&lt;design-name>.conf</code> is a file, that contains the metadata for the memories
which are under the &ldquo;design-under-test&rdquo; module hierarchy. Following is a sample
content of the file:</p><pre tabindex=0><code>name dir_ext depth 512 width 248 ports mrw mask_gran 31
name banks_0_ext depth 2048 width 72 ports rw
name banks_1_ext depth 2048 width 72 ports rw
</code></pre><ol><li><code>name</code> followed by the memory name.</li><li><code>depth</code> followed by the memory depth.</li><li><code>width</code> followed by the data bitwidth.</li><li><code>ports</code> followed by the <code>mrw</code> for read-write port, <code>mwrite</code> for a write port
and <code>read</code> for a read port.</li><li><code>mask_gran</code> followed by the mask granularity.</li></ol><h3 id=chirrtl-memories>CHIRRTL Memories&nbsp;<a class=headline-hash href=#chirrtl-memories>¶</a></h3><p>FIRRTL has two different representations of memories: Chisel <code>cmemory</code>
operations, <code>smem</code> and <code>cmem</code>, and the standard FIRRTL <code>mem</code> operation. Chisel
memory operations exist to make it easy to produce FIRRTL code from Chisel, and
closely match the Chisel API for memories. Chisel memories are intended to be
replaced with standard FIRRTL memories early in the pipeline. The set of
operations related to Chisel memories are often referred to as CHIRRTL.</p><p>The main difference between Chisel and FIRRTL memories is that Chisel memories
have an operation to add a memory port to a memory, while FIRRTL memories
require all ports to be defined up front. Another difference is that Chisel
memories have &ldquo;enable inference&rdquo;, and are usually inferred to be enabled where
they are declared. The following example shows a CHIRRTL memory declaration, and
the standard FIRRTL memory equivalent.</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>smem mymemory : UInt&lt;4&gt;[8]
when p:
  read mport port0 = mymemory[address], clock
</code></pre><pre tabindex=0><code class=language-firrtl data-lang=firrtl>mem mymemory:
    data-type =&gt; UInt&lt;4&gt;
    depth =&gt; 8
    read-latency =&gt; 0
    write-latency =&gt; 1
    reader =&gt; port0
    read-under-write =&gt; undefined

mymemory.port0.en &lt;= p
mymemory.port0.clk &lt;= clock
mymemory.port0.addr &lt;= address
</code></pre><p>FIRRTL memory operations were created because it was thought that a concrete
memory primitive, that looks like an instance, is a better design for a compiler
IR. It was originally intended that Chisel would be modified to emit FIRRTL
memory operations directly, and the CHIRRTL operations would be retired. The
lowering from Chisel memories to FIRRTL memories proved far more complicated
than originally envisioned, specifically surrounding the type of ports,
inference of enable signals, and inference of clocks.</p><p>CHIRRTL operations have since stuck around, but their strange behavior has lead
to discussions to remove, improve, or totally redesign them. For some current
discussion about this see <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. Since CIRCT is attempting to be a drop in
replacement FIRRTL compiler, we are not attempting to implement these new ideas
for Chisel memories. Instead, we are trying to implement what exists today.</p><p>There is, however, a major compatibility issue with the existing implementation
of Chisel memories which made them difficult to support in CIRCT. The FIRRTL
specification disallows using any declaration outside of the scope where it is
created. This means that a Chisel memory port declared inside of a <code>when</code> block
can only be used inside the scope of the <code>when</code> block. Unfortunately, this
invariant is not enforced for memory ports, and this leniency has been abused by
the Chisel standard library. Due to the way clock and enable inference works, we
couldn&rsquo;t just hoist the declaration into the outer scope.</p><p>To support escaping memory port definitions, we decided to split the memory port
operation into two operations. We created a <code>chirrtl.memoryport</code> operation to
declare the memory port, and a <code>chirrtl.memoryport.access</code> operation to enable
the memory port. The following is an example of how FIRRTL translates into the
CIRCT dialect:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>smem mymem : UInt&lt;1&gt;[8]
when cond:
  infer mport myport = mymem[addr], clock
out &lt;= myport
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%mymem</span> <span class=p>=</span> chirrtl<span class=p>.</span>seqmem Undefined  <span class=p>:</span> <span class=p>!</span>chirrtl<span class=p>.</span>cmemory<span class=p>&lt;</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=m>8</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%myport_data</span><span class=p>,</span> <span class=nv>%myport_port</span> <span class=p>=</span> chirrtl<span class=p>.</span>memoryport Infer <span class=nv>%mymem</span> <span class=p>{</span><span class=nl>name =</span> <span class=s>&#34;myport&#34;</span><span class=p>}</span>  <span class=p>:</span> <span class=p>(!</span>chirrtl<span class=p>.</span>cmemory<span class=p>&lt;</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=m>8</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>(!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=p>!</span>chirrtl<span class=p>.</span>cmemoryport<span class=p>)</span>
</span></span><span class=line><span class=cl>firrtl<span class=p>.</span>when <span class=nv>%cond</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  chirrtl<span class=p>.</span>memoryport<span class=p>.</span>access <span class=nv>%myport_port</span><span class=p>[</span><span class=nv>%addr</span><span class=p>],</span> <span class=nv>%clock</span> <span class=p>:</span> <span class=p>!</span>chirrtl<span class=p>.</span>cmemoryport<span class=p>,</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>3</span><span class=p>&gt;,</span> <span class=p>!</span>firrtl<span class=p>.</span>clock
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>firrtl<span class=p>.</span>connect <span class=nv>%out</span><span class=p>,</span> <span class=nv>%myport_data</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span>
</span></span></code></pre></div><p>The CHIRRTL operations and types are contained in the CHIRRTL dialect. The is
primary reason to move them into their own dialect was to keep the CHIRRTL types
out of the FIRRTL dialect type hierarchy. We tried to have the CHIRRTL dialect
depend on the FIRRTL dialect, but the flow checking in FIRRTL had to know about
CHIRRTL operations, which created a circular dependency. To simplify how this
is handled, both dialects are contained in the same library.</p><p>For a historical discussion of this issue and its development see
<a href=https://github.com/llvm/circt/issues/1561><code>llvm/circt#1561</code></a>.</p><h3 id=more-things-are-represented-as-primitives>More things are represented as primitives&nbsp;<a class=headline-hash href=#more-things-are-represented-as-primitives>¶</a></h3><p>We describe the <code>mux</code> expression as &ldquo;primitive&rdquo;, whereas the IR spec and grammar
implement it as a special kind of expression.</p><p>We do this to simplify the implementation: These expressions have the same
structure as primitives, and modeling them as such allows reuse of the parsing
logic instead of duplication of grammar rules.</p><h3 id=invalid-invalidate-operation-is-an-expression><code>invalid</code> Invalidate Operation is an expression&nbsp;<a class=headline-hash href=#invalid-invalidate-operation-is-an-expression>¶</a></h3><p>The FIRRTL spec describes an <code>is invalid</code> statement that logically computes an
invalid value and connects it to <code>x</code> according to flow semantics. This behavior
makes analysis and transformation a bit more complicated, because there are now
two things that perform connections: <code>firrtl.connect</code> and the <code>is invalid</code>
operation.</p><p>To make things easier to reason about, we split the <code>is invalid</code> operation into
two different ops: an <code>firrtl.invalidvalue</code> op that takes no operands and
returns an invalid value, and a standard <code>firrtl.connect</code> operation that
connects the invalid value to the destination (or a <code>firrtl.attach</code> for analog
values). This has the same expressive power as the standard FIRRTL
representation but is easier to work with.</p><p>During parsing, we break up an <code>x is invalid</code> statement into leaf connections.
As an example, consider the following FIRRTL module where a bi-directional
aggregate, <code>a</code> is invalidated:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>module Foo:
  output a: { a: UInt&lt;1&gt;, flip b: UInt&lt;1&gt; }

  a is invalid
</code></pre><p>This is parsed into the following MLIR. Here, only <code>a.a</code> is invalidated:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>firrtl<span class=p>.</span>module <span class=nf>@Foo</span><span class=p>(</span>out <span class=nv>%a</span><span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>bundle<span class=p>&lt;</span>a<span class=p>:</span> uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> b<span class=p>:</span> flip<span class=p>&lt;</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;&gt;&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>subfield <span class=nv>%a</span><span class=p>[</span>a<span class=p>]</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>bundle<span class=p>&lt;</span>a<span class=p>:</span> uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> b<span class=p>:</span> flip<span class=p>&lt;</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;&gt;&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%invalid_ui1</span> <span class=p>=</span> firrtl<span class=p>.</span>invalidvalue <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  firrtl<span class=p>.</span>connect <span class=nv>%0</span><span class=p>,</span> <span class=nv>%invalid_ui1</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=inline-systemverilog-through-verbatimexpr-operation>Inline SystemVerilog through <code>verbatim.expr</code> operation&nbsp;<a class=headline-hash href=#inline-systemverilog-through-verbatimexpr-operation>¶</a></h3><p>The FIRRTL dialect offers a <code>firrtl.verbatim.expr</code> operation that allows for
SystemVerilog expressions to be embedded verbatim in the IR. It is lowered to
the corresponding <code>sv.verbatim.expr</code> operation of the underlying SystemVerilog
dialect, which embeds it in the emitted output. The operation has a FIRRTL
result type, and a variadic number of operands can be accessed from within the
inline SystemVerilog source text through string interpolation of <code>{{0}}</code>-style
placeholders.</p><p>The rationale behind this verbatim operation is to offer an escape hatch
analogous to <code>asm ("...")</code> in C/C++ and other languages, giving the user or
compiler passes full control of what exactly gets embedded in the
output. Usually, though, you would rather add a new operation to the IR to
properly represent additional constructs.</p><p>As an example, a verbatim expression could be used to interact with
yet-unsupported SystemVerilog constructs such as parametrized class typedef
members:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>firrtl<span class=p>.</span>module <span class=nf>@Magic</span> <span class=p>(</span>out <span class=nv>%n</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>verbatim<span class=p>.</span>expr <span class=s>&#34;$bits(SomeClass #(.Param(1))::SomeTypedef)&#34;</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  firrtl<span class=p>.</span>connect <span class=nv>%n</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;,</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This would lower through the other dialects to SystemVerilog as you would
expect:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-systemverilog data-lang=systemverilog><span class=line><span class=cl><span class=k>module</span> <span class=n>Magic</span> <span class=p>(</span><span class=k>output</span> <span class=p>[</span><span class=mh>31</span><span class=o>:</span><span class=mh>0</span><span class=p>]</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>assign</span> <span class=n>n</span> <span class=o>=</span> <span class=n>$bits</span><span class=p>(</span><span class=n>SomeClass</span> <span class=p>#(.</span><span class=n>Param</span><span class=p>(</span><span class=mh>1</span><span class=p>))</span><span class=o>::</span><span class=n>SomeTypedef</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>endmodule</span>
</span></span></code></pre></div><h2 id=interpretation-of-undefined-behavior>Interpretation of Undefined Behavior&nbsp;<a class=headline-hash href=#interpretation-of-undefined-behavior>¶</a></h2><p>The
<a href=https://github.com/chipsalliance/firrtl/blob/master/spec/spec.pdf>FIRRTL
Specification</a>
has undefined behavior for certain features. For compatibility reasons, FIRRTL
dialect <em>always</em> chooses to implement undefined behavior in the same manner as
the SFC.</p><h3 id=invalid>Invalid&nbsp;<a class=headline-hash href=#invalid>¶</a></h3><p>The SFC has multiple context-sensitive interpretations of invalid. Failure to
implement all of these can result in formal equivalence failures when comparing
CIRCT-generated Verilog with SFC-generated Verilog. A list of these
interpretations is enumerated below and then described in more detail.</p><ol><li>An invalid value driving the initialization value of a register (looking
through wires and connections within module scope) removes the reset from the
register.</li><li>An invalid value used in a <code>when</code>-encoded multiplexer tree results in a
direct connection to the non-invalid leg of the multiplexer.</li><li>Any other use of an invalid value is treated as constant zero.</li></ol><p>Interpretation (1) is a mechanism to remove unnecessary reset connections in a
circuit as fewer resets can enable a higher performance design. The SFC
implementation of this works as a dedicated pass that does a module-local
analysis looking for registers with resets whose initialization values come from
invalidated signals. This analysis only looks through wires and connections.
It is legal to use an invalidated output port or instance input port.</p><p>As an example, the following module should have register <code>r</code> converted to a
reset-less register:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>wire inv: UInt&lt;8&gt;
inv is invalid

wire tmp: UInt&lt;8&gt;
tmp &lt;= inv

reg r: UInt&lt;8&gt;, clock with : (reset =&gt; (reset, tmp))
</code></pre><p>Notably, if <code>tmp</code> is a <code>node</code>, this optimization should not be performed.</p><p>Interpretation (2) means that the following circuit should be optimized to a
direct connection from <code>bar</code> to <code>foo</code>:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>foo is invalid
when cond:
  foo &lt;= bar
</code></pre><p>Note that the SFC implementation of this optimization is handled via two passes.
An <code>ExpandWhens</code> (later refactored as <code>ExpandWhensAndCheck</code>) pass converts all
<code>when</code> blocks to multiplexer trees. Any invalid values that arise from this
conversion produce <code>validif</code> expressions. (This is the &ldquo;conditionally valid&rdquo;
expression which is an internal detail of the SFC which was removed from the
FIRRTL specification.) A later pass, <code>RemoveValidIfs</code> optimizes/removes
<code>validif</code> by replacing it with a direct connection.</p><p>It is important to note that the above formulations using <code>when</code> or the
SFC-internal representation using <code>validif</code> <em>are not equivalent to a mux
formulation</em> like the following. The code below should be optimized using
Interpretation (3) of invalid as constant zero:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>wire inv: UInt&lt;8&gt;
inv is invalid

foo &lt;= mux(cond, bar, inv)
</code></pre><p>A legal lowering of this is only to:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>foo &lt;= mux(cond, bar, UInt&lt;8&gt;(0))
</code></pre><p>Interpretation (3) is used in all other situations involving an invalid value.</p><p><strong>Critically, the nature of an invalid value has context-sensitive information
that relies on the exact structural nature of the circuit.</strong> It follows that
any seemingly mundane optimization can result in an end-to-end miscompilations
where the SFC is treated as ground truth.</p><p>As an example, consider a reformulation of the <code>when</code> example above, but using a
temporary, single-use, invalidated wire:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>wire inv: UInt&lt;8&gt;
inv is invalid

b &lt;= inv
when cond:
  b &lt;= a
</code></pre><p>This should <em>not</em> produce a direction connection to <code>b</code> and should instead lower
to:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>b &lt;= mux(cond, a, inv)
</code></pre><p>It follows that interpretation (3) will then convert the false leg of the <code>mux</code>
to a constant zero.</p><h2 id=intrinsics>Intrinsics&nbsp;<a class=headline-hash href=#intrinsics>¶</a></h2><p>Intrinsics are implementation-defined constructs. Intrinsics provide a way to
extend the system with functionality without changing the language. They form
an implementation-specific built-in library. Unlike traditional libraries,
implementations of intrinsics have access to internals of the compiler, allowing
them to implement features not possible in the language.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://github.com/chipsalliance/firrtl/issues/727>https://github.com/chipsalliance/firrtl/issues/727</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://github.com/chipsalliance/firrtl/pull/1821>https://github.com/chipsalliance/firrtl/pull/1821</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/ title="FIRRTL Annotations"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - FIRRTL Annotations</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/ title=Intrinsics>Next - Intrinsics <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li class=active><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>