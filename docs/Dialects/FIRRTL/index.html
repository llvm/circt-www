<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'firrtl' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/FIRRTL/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'firrtl' Dialect</h1><p>This dialect defines the <code>firrtl</code> dialect, which is used to lower from Chisel
code to Verilog. For more information, see the
<a href=https://github.com/freechipsproject/firrtl>FIRRTL GitHub
page</a>.</p><p><nav id=TableOfContents><ul><li><a href=#operation-definitions----structure>Operation Definitions &ndash; Structure</a><ul><li><a href=#firrtlcircuit-circtfirrtlcircuitop><code>firrtl.circuit</code> (::circt::firrtl::CircuitOp)</a></li><li><a href=#firrtlclass-circtfirrtlclassop><code>firrtl.class</code> (::circt::firrtl::ClassOp)</a></li><li><a href=#firrtlextclass-circtfirrtlextclassop><code>firrtl.extclass</code> (::circt::firrtl::ExtClassOp)</a></li><li><a href=#firrtlextmodule-circtfirrtlfextmoduleop><code>firrtl.extmodule</code> (::circt::firrtl::FExtModuleOp)</a></li><li><a href=#firrtlintmodule-circtfirrtlfintmoduleop><code>firrtl.intmodule</code> (::circt::firrtl::FIntModuleOp)</a></li><li><a href=#firrtlmemmodule-circtfirrtlfmemmoduleop><code>firrtl.memmodule</code> (::circt::firrtl::FMemModuleOp)</a></li><li><a href=#firrtlmodule-circtfirrtlfmoduleop><code>firrtl.module</code> (::circt::firrtl::FModuleOp)</a></li><li><a href=#firrtllayer-circtfirrtllayerop><code>firrtl.layer</code> (::circt::firrtl::LayerOp)</a></li><li><a href=#firrtloption_case-circtfirrtloptioncaseop><code>firrtl.option_case</code> (::circt::firrtl::OptionCaseOp)</a></li><li><a href=#firrtloption-circtfirrtloptionop><code>firrtl.option</code> (::circt::firrtl::OptionOp)</a></li></ul></li><li><a href=#operation-definitions----declarations>Operation Definitions &ndash; Declarations</a><ul><li><a href=#firrtlinstance_choice-circtfirrtlinstancechoiceop><code>firrtl.instance_choice</code> (::circt::firrtl::InstanceChoiceOp)</a></li><li><a href=#firrtlinstance-circtfirrtlinstanceop><code>firrtl.instance</code> (::circt::firrtl::InstanceOp)</a></li><li><a href=#firrtlmem-circtfirrtlmemop><code>firrtl.mem</code> (::circt::firrtl::MemOp)</a></li><li><a href=#firrtlnode-circtfirrtlnodeop><code>firrtl.node</code> (::circt::firrtl::NodeOp)</a></li><li><a href=#firrtlobject-circtfirrtlobjectop><code>firrtl.object</code> (::circt::firrtl::ObjectOp)</a></li><li><a href=#firrtlreg-circtfirrtlregop><code>firrtl.reg</code> (::circt::firrtl::RegOp)</a></li><li><a href=#firrtlregreset-circtfirrtlregresetop><code>firrtl.regreset</code> (::circt::firrtl::RegResetOp)</a></li><li><a href=#firrtlwire-circtfirrtlwireop><code>firrtl.wire</code> (::circt::firrtl::WireOp)</a></li></ul></li><li><a href=#statement-operation----statements>Statement Operation &ndash; Statements</a><ul><li><a href=#firrtlassert-circtfirrtlassertop><code>firrtl.assert</code> (::circt::firrtl::AssertOp)</a></li><li><a href=#firrtlassume-circtfirrtlassumeop><code>firrtl.assume</code> (::circt::firrtl::AssumeOp)</a></li><li><a href=#firrtlattach-circtfirrtlattachop><code>firrtl.attach</code> (::circt::firrtl::AttachOp)</a></li><li><a href=#firrtlconnect-circtfirrtlconnectop><code>firrtl.connect</code> (::circt::firrtl::ConnectOp)</a></li><li><a href=#firrtlcover-circtfirrtlcoverop><code>firrtl.cover</code> (::circt::firrtl::CoverOp)</a></li><li><a href=#firrtlforce-circtfirrtlforceop><code>firrtl.force</code> (::circt::firrtl::ForceOp)</a></li><li><a href=#firrtllayerblock-circtfirrtllayerblockop><code>firrtl.layerblock</code> (::circt::firrtl::LayerBlockOp)</a></li><li><a href=#firrtlmatch-circtfirrtlmatchop><code>firrtl.match</code> (::circt::firrtl::MatchOp)</a></li><li><a href=#firrtlprintf-circtfirrtlprintfop><code>firrtl.printf</code> (::circt::firrtl::PrintFOp)</a></li><li><a href=#firrtlpropassign-circtfirrtlpropassignop><code>firrtl.propassign</code> (::circt::firrtl::PropAssignOp)</a></li><li><a href=#firrtlrefdefine-circtfirrtlrefdefineop><code>firrtl.ref.define</code> (::circt::firrtl::RefDefineOp)</a></li><li><a href=#firrtlrefforce_initial-circtfirrtlrefforceinitialop><code>firrtl.ref.force_initial</code> (::circt::firrtl::RefForceInitialOp)</a></li><li><a href=#firrtlrefforce-circtfirrtlrefforceop><code>firrtl.ref.force</code> (::circt::firrtl::RefForceOp)</a></li><li><a href=#firrtlrefrelease_initial-circtfirrtlrefreleaseinitialop><code>firrtl.ref.release_initial</code> (::circt::firrtl::RefReleaseInitialOp)</a></li><li><a href=#firrtlrefrelease-circtfirrtlrefreleaseop><code>firrtl.ref.release</code> (::circt::firrtl::RefReleaseOp)</a></li><li><a href=#firrtlskip-circtfirrtlskipop><code>firrtl.skip</code> (::circt::firrtl::SkipOp)</a></li><li><a href=#firrtlstop-circtfirrtlstopop><code>firrtl.stop</code> (::circt::firrtl::StopOp)</a></li><li><a href=#firrtlstrictconnect-circtfirrtlstrictconnectop><code>firrtl.strictconnect</code> (::circt::firrtl::StrictConnectOp)</a></li><li><a href=#firrtlintverifassert-circtfirrtlverifassertintrinsicop><code>firrtl.int.verif.assert</code> (::circt::firrtl::VerifAssertIntrinsicOp)</a></li><li><a href=#firrtlintverifassume-circtfirrtlverifassumeintrinsicop><code>firrtl.int.verif.assume</code> (::circt::firrtl::VerifAssumeIntrinsicOp)</a></li><li><a href=#firrtlintverifcover-circtfirrtlverifcoverintrinsicop><code>firrtl.int.verif.cover</code> (::circt::firrtl::VerifCoverIntrinsicOp)</a></li><li><a href=#firrtlwhen-circtfirrtlwhenop><code>firrtl.when</code> (::circt::firrtl::WhenOp)</a></li></ul></li><li><a href=#operation-definitions----expressions>Operation Definitions &ndash; Expressions</a><ul><li><a href=#firrtladd-circtfirrtladdprimop><code>firrtl.add</code> (::circt::firrtl::AddPrimOp)</a></li><li><a href=#firrtlaggregateconstant-circtfirrtlaggregateconstantop><code>firrtl.aggregateconstant</code> (::circt::firrtl::AggregateConstantOp)</a></li><li><a href=#firrtland-circtfirrtlandprimop><code>firrtl.and</code> (::circt::firrtl::AndPrimOp)</a></li><li><a href=#firrtlandr-circtfirrtlandrprimop><code>firrtl.andr</code> (::circt::firrtl::AndRPrimOp)</a></li><li><a href=#firrtlasasyncreset-circtfirrtlasasyncresetprimop><code>firrtl.asAsyncReset</code> (::circt::firrtl::AsAsyncResetPrimOp)</a></li><li><a href=#firrtlasclock-circtfirrtlasclockprimop><code>firrtl.asClock</code> (::circt::firrtl::AsClockPrimOp)</a></li><li><a href=#firrtlassint-circtfirrtlassintprimop><code>firrtl.asSInt</code> (::circt::firrtl::AsSIntPrimOp)</a></li><li><a href=#firrtlasuint-circtfirrtlasuintprimop><code>firrtl.asUInt</code> (::circt::firrtl::AsUIntPrimOp)</a></li><li><a href=#firrtlbitcast-circtfirrtlbitcastop><code>firrtl.bitcast</code> (::circt::firrtl::BitCastOp)</a></li><li><a href=#firrtlbits-circtfirrtlbitsprimop><code>firrtl.bits</code> (::circt::firrtl::BitsPrimOp)</a></li><li><a href=#firrtlbool-circtfirrtlboolconstantop><code>firrtl.bool</code> (::circt::firrtl::BoolConstantOp)</a></li><li><a href=#firrtlbundlecreate-circtfirrtlbundlecreateop><code>firrtl.bundlecreate</code> (::circt::firrtl::BundleCreateOp)</a></li><li><a href=#firrtlcat-circtfirrtlcatprimop><code>firrtl.cat</code> (::circt::firrtl::CatPrimOp)</a></li><li><a href=#firrtlconstcast-circtfirrtlconstcastop><code>firrtl.constCast</code> (::circt::firrtl::ConstCastOp)</a></li><li><a href=#firrtlconstant-circtfirrtlconstantop><code>firrtl.constant</code> (::circt::firrtl::ConstantOp)</a></li><li><a href=#firrtlcvt-circtfirrtlcvtprimop><code>firrtl.cvt</code> (::circt::firrtl::CvtPrimOp)</a></li><li><a href=#firrtldshl-circtfirrtldshlprimop><code>firrtl.dshl</code> (::circt::firrtl::DShlPrimOp)</a></li><li><a href=#firrtldshlw-circtfirrtldshlwprimop><code>firrtl.dshlw</code> (::circt::firrtl::DShlwPrimOp)</a></li><li><a href=#firrtldshr-circtfirrtldshrprimop><code>firrtl.dshr</code> (::circt::firrtl::DShrPrimOp)</a></li><li><a href=#firrtldiv-circtfirrtldivprimop><code>firrtl.div</code> (::circt::firrtl::DivPrimOp)</a></li><li><a href=#firrtldouble-circtfirrtldoubleconstantop><code>firrtl.double</code> (::circt::firrtl::DoubleConstantOp)</a></li><li><a href=#firrtleq-circtfirrtleqprimop><code>firrtl.eq</code> (::circt::firrtl::EQPrimOp)</a></li><li><a href=#firrtlelementwise_and-circtfirrtlelementwiseandprimop><code>firrtl.elementwise_and</code> (::circt::firrtl::ElementwiseAndPrimOp)</a></li><li><a href=#firrtlelementwise_or-circtfirrtlelementwiseorprimop><code>firrtl.elementwise_or</code> (::circt::firrtl::ElementwiseOrPrimOp)</a></li><li><a href=#firrtlelementwise_xor-circtfirrtlelementwisexorprimop><code>firrtl.elementwise_xor</code> (::circt::firrtl::ElementwiseXorPrimOp)</a></li><li><a href=#firrtlenumcreate-circtfirrtlfenumcreateop><code>firrtl.enumcreate</code> (::circt::firrtl::FEnumCreateOp)</a></li><li><a href=#firrtlinteger-circtfirrtlfintegerconstantop><code>firrtl.integer</code> (::circt::firrtl::FIntegerConstantOp)</a></li><li><a href=#firrtlgeq-circtfirrtlgeqprimop><code>firrtl.geq</code> (::circt::firrtl::GEQPrimOp)</a></li><li><a href=#firrtlgt-circtfirrtlgtprimop><code>firrtl.gt</code> (::circt::firrtl::GTPrimOp)</a></li><li><a href=#firrtlhwstructcast-circtfirrtlhwstructcastop><code>firrtl.hwStructCast</code> (::circt::firrtl::HWStructCastOp)</a></li><li><a href=#firrtlhead-circtfirrtlheadprimop><code>firrtl.head</code> (::circt::firrtl::HeadPrimOp)</a></li><li><a href=#firrtlintegeradd-circtfirrtlintegeraddop><code>firrtl.integer.add</code> (::circt::firrtl::IntegerAddOp)</a></li><li><a href=#firrtlintegermul-circtfirrtlintegermulop><code>firrtl.integer.mul</code> (::circt::firrtl::IntegerMulOp)</a></li><li><a href=#firrtlintegershr-circtfirrtlintegershrop><code>firrtl.integer.shr</code> (::circt::firrtl::IntegerShrOp)</a></li><li><a href=#firrtlinvalidvalue-circtfirrtlinvalidvalueop><code>firrtl.invalidvalue</code> (::circt::firrtl::InvalidValueOp)</a></li><li><a href=#firrtlistag-circtfirrtlistagop><code>firrtl.istag</code> (::circt::firrtl::IsTagOp)</a></li><li><a href=#firrtlleq-circtfirrtlleqprimop><code>firrtl.leq</code> (::circt::firrtl::LEQPrimOp)</a></li><li><a href=#firrtlintltland-circtfirrtlltlandintrinsicop><code>firrtl.int.ltl.and</code> (::circt::firrtl::LTLAndIntrinsicOp)</a></li><li><a href=#firrtlintltlclock-circtfirrtlltlclockintrinsicop><code>firrtl.int.ltl.clock</code> (::circt::firrtl::LTLClockIntrinsicOp)</a></li><li><a href=#firrtlintltlconcat-circtfirrtlltlconcatintrinsicop><code>firrtl.int.ltl.concat</code> (::circt::firrtl::LTLConcatIntrinsicOp)</a></li><li><a href=#firrtlintltldelay-circtfirrtlltldelayintrinsicop><code>firrtl.int.ltl.delay</code> (::circt::firrtl::LTLDelayIntrinsicOp)</a></li><li><a href=#firrtlintltldisable-circtfirrtlltldisableintrinsicop><code>firrtl.int.ltl.disable</code> (::circt::firrtl::LTLDisableIntrinsicOp)</a></li><li><a href=#firrtlintltleventually-circtfirrtlltleventuallyintrinsicop><code>firrtl.int.ltl.eventually</code> (::circt::firrtl::LTLEventuallyIntrinsicOp)</a></li><li><a href=#firrtlintltlimplication-circtfirrtlltlimplicationintrinsicop><code>firrtl.int.ltl.implication</code> (::circt::firrtl::LTLImplicationIntrinsicOp)</a></li><li><a href=#firrtlintltlnot-circtfirrtlltlnotintrinsicop><code>firrtl.int.ltl.not</code> (::circt::firrtl::LTLNotIntrinsicOp)</a></li><li><a href=#firrtlintltlor-circtfirrtlltlorintrinsicop><code>firrtl.int.ltl.or</code> (::circt::firrtl::LTLOrIntrinsicOp)</a></li><li><a href=#firrtllt-circtfirrtlltprimop><code>firrtl.lt</code> (::circt::firrtl::LTPrimOp)</a></li><li><a href=#firrtllistcreate-circtfirrtllistcreateop><code>firrtl.list.create</code> (::circt::firrtl::ListCreateOp)</a></li><li><a href=#firrtlmul-circtfirrtlmulprimop><code>firrtl.mul</code> (::circt::firrtl::MulPrimOp)</a></li><li><a href=#firrtlmultibit_mux-circtfirrtlmultibitmuxop><code>firrtl.multibit_mux</code> (::circt::firrtl::MultibitMuxOp)</a></li><li><a href=#firrtlintmux2cell-circtfirrtlmux2cellintrinsicop><code>firrtl.int.mux2cell</code> (::circt::firrtl::Mux2CellIntrinsicOp)</a></li><li><a href=#firrtlintmux4cell-circtfirrtlmux4cellintrinsicop><code>firrtl.int.mux4cell</code> (::circt::firrtl::Mux4CellIntrinsicOp)</a></li><li><a href=#firrtlmux-circtfirrtlmuxprimop><code>firrtl.mux</code> (::circt::firrtl::MuxPrimOp)</a></li><li><a href=#firrtlneq-circtfirrtlneqprimop><code>firrtl.neq</code> (::circt::firrtl::NEQPrimOp)</a></li><li><a href=#firrtlneg-circtfirrtlnegprimop><code>firrtl.neg</code> (::circt::firrtl::NegPrimOp)</a></li><li><a href=#firrtlnot-circtfirrtlnotprimop><code>firrtl.not</code> (::circt::firrtl::NotPrimOp)</a></li><li><a href=#firrtlobjectanyref_cast-circtfirrtlobjectanyrefcastop><code>firrtl.object.anyref_cast</code> (::circt::firrtl::ObjectAnyRefCastOp)</a></li><li><a href=#firrtlobjectsubfield-circtfirrtlobjectsubfieldop><code>firrtl.object.subfield</code> (::circt::firrtl::ObjectSubfieldOp)</a></li><li><a href=#firrtlopensubfield-circtfirrtlopensubfieldop><code>firrtl.opensubfield</code> (::circt::firrtl::OpenSubfieldOp)</a></li><li><a href=#firrtlopensubindex-circtfirrtlopensubindexop><code>firrtl.opensubindex</code> (::circt::firrtl::OpenSubindexOp)</a></li><li><a href=#firrtlor-circtfirrtlorprimop><code>firrtl.or</code> (::circt::firrtl::OrPrimOp)</a></li><li><a href=#firrtlorr-circtfirrtlorrprimop><code>firrtl.orr</code> (::circt::firrtl::OrRPrimOp)</a></li><li><a href=#firrtlpad-circtfirrtlpadprimop><code>firrtl.pad</code> (::circt::firrtl::PadPrimOp)</a></li><li><a href=#firrtlpath-circtfirrtlpathop><code>firrtl.path</code> (::circt::firrtl::PathOp)</a></li><li><a href=#firrtlrefrwprobe-circtfirrtlrwprobeop><code>firrtl.ref.rwprobe</code> (::circt::firrtl::RWProbeOp)</a></li><li><a href=#firrtlrefcast-circtfirrtlrefcastop><code>firrtl.ref.cast</code> (::circt::firrtl::RefCastOp)</a></li><li><a href=#firrtlrefresolve-circtfirrtlrefresolveop><code>firrtl.ref.resolve</code> (::circt::firrtl::RefResolveOp)</a></li><li><a href=#firrtlrefsend-circtfirrtlrefsendop><code>firrtl.ref.send</code> (::circt::firrtl::RefSendOp)</a></li><li><a href=#firrtlrefsub-circtfirrtlrefsubop><code>firrtl.ref.sub</code> (::circt::firrtl::RefSubOp)</a></li><li><a href=#firrtlrem-circtfirrtlremprimop><code>firrtl.rem</code> (::circt::firrtl::RemPrimOp)</a></li><li><a href=#firrtlshl-circtfirrtlshlprimop><code>firrtl.shl</code> (::circt::firrtl::ShlPrimOp)</a></li><li><a href=#firrtlshr-circtfirrtlshrprimop><code>firrtl.shr</code> (::circt::firrtl::ShrPrimOp)</a></li><li><a href=#firrtlintsizeof-circtfirrtlsizeofintrinsicop><code>firrtl.int.sizeof</code> (::circt::firrtl::SizeOfIntrinsicOp)</a></li><li><a href=#firrtlspecialconstant-circtfirrtlspecialconstantop><code>firrtl.specialconstant</code> (::circt::firrtl::SpecialConstantOp)</a></li><li><a href=#firrtlstring-circtfirrtlstringconstantop><code>firrtl.string</code> (::circt::firrtl::StringConstantOp)</a></li><li><a href=#firrtlsub-circtfirrtlsubprimop><code>firrtl.sub</code> (::circt::firrtl::SubPrimOp)</a></li><li><a href=#firrtlsubaccess-circtfirrtlsubaccessop><code>firrtl.subaccess</code> (::circt::firrtl::SubaccessOp)</a></li><li><a href=#firrtlsubfield-circtfirrtlsubfieldop><code>firrtl.subfield</code> (::circt::firrtl::SubfieldOp)</a></li><li><a href=#firrtlsubindex-circtfirrtlsubindexop><code>firrtl.subindex</code> (::circt::firrtl::SubindexOp)</a></li><li><a href=#firrtlsubtag-circtfirrtlsubtagop><code>firrtl.subtag</code> (::circt::firrtl::SubtagOp)</a></li><li><a href=#firrtltagextract-circtfirrtltagextractop><code>firrtl.tagextract</code> (::circt::firrtl::TagExtractOp)</a></li><li><a href=#firrtltail-circtfirrtltailprimop><code>firrtl.tail</code> (::circt::firrtl::TailPrimOp)</a></li><li><a href=#firrtlresetcast-circtfirrtluninferredresetcastop><code>firrtl.resetCast</code> (::circt::firrtl::UninferredResetCastOp)</a></li><li><a href=#firrtlunresolved_path-circtfirrtlunresolvedpathop><code>firrtl.unresolved_path</code> (::circt::firrtl::UnresolvedPathOp)</a></li><li><a href=#firrtlvectorcreate-circtfirrtlvectorcreateop><code>firrtl.vectorcreate</code> (::circt::firrtl::VectorCreateOp)</a></li><li><a href=#firrtlverbatimexpr-circtfirrtlverbatimexprop><code>firrtl.verbatim.expr</code> (::circt::firrtl::VerbatimExprOp)</a></li><li><a href=#firrtlverbatimwire-circtfirrtlverbatimwireop><code>firrtl.verbatim.wire</code> (::circt::firrtl::VerbatimWireOp)</a></li><li><a href=#firrtlxmrderef-circtfirrtlxmrderefop><code>firrtl.xmr.deref</code> (::circt::firrtl::XMRDerefOp)</a></li><li><a href=#firrtlxmrref-circtfirrtlxmrrefop><code>firrtl.xmr.ref</code> (::circt::firrtl::XMRRefOp)</a></li><li><a href=#firrtlxor-circtfirrtlxorprimop><code>firrtl.xor</code> (::circt::firrtl::XorPrimOp)</a></li><li><a href=#firrtlxorr-circtfirrtlxorrprimop><code>firrtl.xorr</code> (::circt::firrtl::XorRPrimOp)</a></li></ul></li><li><a href=#type-definitions>Type Definitions</a><ul><li><a href=#analogtype>AnalogType</a></li><li><a href=#anyreftype>AnyRefType</a></li><li><a href=#asyncresettype>AsyncResetType</a></li><li><a href=#basetypealiastype>BaseTypeAliasType</a></li><li><a href=#booltype>BoolType</a></li><li><a href=#bundletype>BundleType</a></li><li><a href=#classtype>ClassType</a></li><li><a href=#clocktype>ClockType</a></li><li><a href=#doubletype>DoubleType</a></li><li><a href=#fenumtype>FEnumType</a></li><li><a href=#fvectortype>FVectorType</a></li><li><a href=#fintegertype>FIntegerType</a></li><li><a href=#listtype>ListType</a></li><li><a href=#openbundletype>OpenBundleType</a></li><li><a href=#openvectortype>OpenVectorType</a></li><li><a href=#pathtype>PathType</a></li><li><a href=#reftype>RefType</a></li><li><a href=#resettype>ResetType</a></li><li><a href=#sinttype>SIntType</a></li><li><a href=#stringtype>StringType</a></li><li><a href=#uinttype>UIntType</a></li></ul></li><li><a href=#attribute-definitions>Attribute Definitions</a><ul><li><a href=#augmentedbooleantypeattr>AugmentedBooleanTypeAttr</a></li><li><a href=#augmentedbundletypeattr>AugmentedBundleTypeAttr</a></li><li><a href=#augmenteddeletedtypeattr>AugmentedDeletedTypeAttr</a></li><li><a href=#augmenteddoubletypeattr>AugmentedDoubleTypeAttr</a></li><li><a href=#augmentedgroundtypeattr>AugmentedGroundTypeAttr</a></li><li><a href=#augmentedintegertypeattr>AugmentedIntegerTypeAttr</a></li><li><a href=#augmentedliteraltypeattr>AugmentedLiteralTypeAttr</a></li><li><a href=#augmentedstringtypeattr>AugmentedStringTypeAttr</a></li><li><a href=#augmentedvectortypeattr>AugmentedVectorTypeAttr</a></li><li><a href=#internalpathattr>InternalPathAttr</a></li><li><a href=#memoryinitattr>MemoryInitAttr</a></li><li><a href=#paramdeclattr>ParamDeclAttr</a></li></ul></li><li><a href=#classlike-classlike>ClassLike (<code>ClassLike</code>)</a><ul><li><a href=#methods>Methods:</a></li></ul></li><li><a href=#fconnectlike-fconnectlike>FConnectLike (<code>FConnectLike</code>)</a><ul><li><a href=#methods-1>Methods:</a></li></ul></li><li><a href=#finstancelike-finstancelike>FInstanceLike (<code>FInstanceLike</code>)</a><ul><li><a href=#methods-2>Methods:</a></li></ul></li><li><a href=#fmodulelike-fmodulelike>FModuleLike (<code>FModuleLike</code>)</a><ul><li><a href=#methods-3>Methods:</a></li></ul></li><li><a href=#fnamableop-fnamableop>FNamableOp (<code>FNamableOp</code>)</a><ul><li><a href=#methods-4>Methods:</a></li></ul></li><li><a href=#forceable-forceable>Forceable (<code>Forceable</code>)</a><ul><li><a href=#methods-5>Methods:</a></li></ul></li></ul></nav><h2 id=operation-definitions----structure>Operation Definitions &ndash; Structure</h2><h3 id=firrtlcircuit-circtfirrtlcircuitop><code>firrtl.circuit</code> (::circt::firrtl::CircuitOp)</h3><p><em>FIRRTL Circuit</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.circuit` $name `` custom&lt;CircuitOpAttrs&gt;(attr-dict) $body
</code></pre><p>The &ldquo;firrtl.circuit&rdquo; operation represents an overall Verilog circuit,
containing a list of modules.</p><p>Traits: <code>InnerRefNamespace</code>, <code>IsolatedFromAbove</code>, <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>SingleBlock</code>, <code>SymbolTable</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>annotations</code></td><td>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr></table><h3 id=firrtlclass-circtfirrtlclassop><code>firrtl.class</code> (::circt::firrtl::ClassOp)</h3><p><em>FIRRTL Class</em></p><p>The &ldquo;firrtl.class&rdquo; operation defines a class of property-only objects,
including a given name, a list of ports, and a body that represents the
connections within the class.</p><p>A class may only have property ports, and its body may only be ops that act
on properties, such as propassign ops.</p><p>Traits: <code>HasParent&lt;CircuitOp></code>, <code>InnerSymbolTable</code>, <code>IsolatedFromAbove</code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>ClassLike</code>, <code>FModuleLike</code>, <code>InstanceGraphModuleOpInterface</code>, <code>ModuleOpInterface</code>, <code>OpAsmOpInterface</code>, <code>PortList</code>, <code>SymbolOpInterface</code>, <code>SymbolUserOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>portDirections</code></td><td>::mlir::DenseBoolArrayAttr</td><td>i1 dense array attribute</td></tr><tr><td><code>portNames</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portTypes</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portSyms</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portLocations</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr></table><h3 id=firrtlextclass-circtfirrtlextclassop><code>firrtl.extclass</code> (::circt::firrtl::ExtClassOp)</h3><p><em>FIRRTL external class</em></p><p>The &ldquo;firrtl.extclass&rdquo; operation represents a reference to an external
firrtl class, and includes a given name, as well as a list of ports.
Just as usual firrtl.class definitions, An ext.class may only have property
ports.</p><p>example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>firrtl<span class=p>.</span>extclass <span class=nf>@MyImportedClass</span><span class=p>(</span>in in_str<span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>string<span class=p>,</span> out out_str<span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>string<span class=p>)</span>
</span></span></code></pre></div><p>Traits: <code>HasParent&lt;CircuitOp></code>, <code>InnerSymbolTable</code>, <code>IsolatedFromAbove</code></p><p>Interfaces: <code>ClassLike</code>, <code>FModuleLike</code>, <code>InstanceGraphModuleOpInterface</code>, <code>ModuleOpInterface</code>, <code>OpAsmOpInterface</code>, <code>PortList</code>, <code>SymbolOpInterface</code>, <code>SymbolUserOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>portDirections</code></td><td>::mlir::DenseBoolArrayAttr</td><td>i1 dense array attribute</td></tr><tr><td><code>portNames</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portTypes</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portSyms</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portLocations</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr></table><h3 id=firrtlextmodule-circtfirrtlfextmoduleop><code>firrtl.extmodule</code> (::circt::firrtl::FExtModuleOp)</h3><p><em>FIRRTL external module</em></p><p>The &ldquo;firrtl.extmodule&rdquo; operation represents an external reference to a
Verilog module, including a given name and a list of ports.
LowerAnnotations can add RefType ports to it. Each RefType port
must have a corresponding entry in the internalPaths attribute.
The internalPaths attribute is used to represent opaque internal paths
into the external module, to be used for generating XMRs. Each RefType
port must be removed by LowerXMR pass.</p><p>Traits: <code>HasParent&lt;CircuitOp></code>, <code>InnerSymbolTable</code>, <code>IsolatedFromAbove</code></p><p>Interfaces: <code>FModuleLike</code>, <code>InstanceGraphModuleOpInterface</code>, <code>ModuleOpInterface</code>, <code>OpAsmOpInterface</code>, <code>PortList</code>, <code>SymbolUserOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>defname</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>parameters</code></td><td>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td><code>convention</code></td><td>::circt::firrtl::ConventionAttr</td><td>lowering convention</td></tr><tr><td><code>portDirections</code></td><td>::mlir::DenseBoolArrayAttr</td><td>i1 dense array attribute</td></tr><tr><td><code>portLocations</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portAnnotations</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portSyms</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portNames</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portTypes</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>annotations</code></td><td>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td><code>layers</code></td><td>::mlir::ArrayAttr</td><td>an array of layers</td></tr><tr><td><code>internalPaths</code></td><td>::mlir::ArrayAttr</td><td>InternalPath array attribute</td></tr></table><h3 id=firrtlintmodule-circtfirrtlfintmoduleop><code>firrtl.intmodule</code> (::circt::firrtl::FIntModuleOp)</h3><p><em>FIRRTL intrinsic module</em></p><p>The &ldquo;firrtl.intmodule&rdquo; operation represents a compiler intrinsic.</p><p>Traits: <code>HasParent&lt;CircuitOp></code>, <code>InnerSymbolTable</code>, <code>IsolatedFromAbove</code></p><p>Interfaces: <code>FModuleLike</code>, <code>InstanceGraphModuleOpInterface</code>, <code>ModuleOpInterface</code>, <code>OpAsmOpInterface</code>, <code>PortList</code>, <code>SymbolUserOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>intrinsic</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>parameters</code></td><td>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td><code>portDirections</code></td><td>::mlir::DenseBoolArrayAttr</td><td>i1 dense array attribute</td></tr><tr><td><code>portLocations</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portAnnotations</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portSyms</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portNames</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portTypes</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>annotations</code></td><td>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td><code>layers</code></td><td>::mlir::ArrayAttr</td><td>an array of layers</td></tr><tr><td><code>internalPaths</code></td><td>::mlir::ArrayAttr</td><td>InternalPath array attribute</td></tr></table><h3 id=firrtlmemmodule-circtfirrtlfmemmoduleop><code>firrtl.memmodule</code> (::circt::firrtl::FMemModuleOp)</h3><p><em>FIRRTL Generated Memory Module</em></p><p>The &ldquo;firrtl.memmodule&rdquo; operation represents an external reference to a
memory module. See the &ldquo;firrtl.mem&rdquo; op for a deeper explantation of the
parameters.</p><p>A &ldquo;firrtl.mem&rdquo; operation is typically lowered to this operation when they
are not directly lowered to registers by the compiler.</p><p>Traits: <code>HasParent&lt;CircuitOp></code>, <code>InnerSymbolTable</code>, <code>IsolatedFromAbove</code></p><p>Interfaces: <code>FModuleLike</code>, <code>InstanceGraphModuleOpInterface</code>, <code>ModuleOpInterface</code>, <code>OpAsmOpInterface</code>, <code>PortList</code>, <code>SymbolUserOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>numReadPorts</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td><code>numWritePorts</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td><code>numReadWritePorts</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td><code>dataWidth</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td><code>maskBits</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td><code>readLatency</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td><code>writeLatency</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td><code>depth</code></td><td>::mlir::IntegerAttr</td><td>64-bit unsigned integer attribute</td></tr><tr><td><code>extraPorts</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portDirections</code></td><td>::mlir::DenseBoolArrayAttr</td><td>i1 dense array attribute</td></tr><tr><td><code>portLocations</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portAnnotations</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portSyms</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portNames</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portTypes</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>annotations</code></td><td>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td><code>layers</code></td><td>::mlir::ArrayAttr</td><td>an array of layers</td></tr></table><h3 id=firrtlmodule-circtfirrtlfmoduleop><code>firrtl.module</code> (::circt::firrtl::FModuleOp)</h3><p><em>FIRRTL Module</em></p><p>The &ldquo;firrtl.module&rdquo; operation represents a Verilog module, including a given
name, a list of ports, and a body that represents the connections within
the module.</p><p>Traits: <code>HasParent&lt;CircuitOp></code>, <code>InnerSymbolTable</code>, <code>IsolatedFromAbove</code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>FModuleLike</code>, <code>InstanceGraphModuleOpInterface</code>, <code>ModuleOpInterface</code>, <code>OpAsmOpInterface</code>, <code>PortList</code>, <code>SymbolUserOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>convention</code></td><td>::circt::firrtl::ConventionAttr</td><td>lowering convention</td></tr><tr><td><code>portDirections</code></td><td>::mlir::DenseBoolArrayAttr</td><td>i1 dense array attribute</td></tr><tr><td><code>portLocations</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portAnnotations</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portSyms</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portNames</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>portTypes</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>annotations</code></td><td>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td><code>layers</code></td><td>::mlir::ArrayAttr</td><td>an array of layers</td></tr></table><h3 id=firrtllayer-circtfirrtllayerop><code>firrtl.layer</code> (::circt::firrtl::LayerOp)</h3><p><em>A layer definition</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.layer` $sym_name $convention attr-dict-with-keyword $body
</code></pre><p>The <code>firrtl.layer</code> operation defines a layer and a lowering convention for
that layer. Layers are a feature of FIRRTL that add verification or
debugging code to an existing module at runtime.</p><p>A <code>firrtl.layer</code> operation only defines the layer and any layers nested
under it. Functionality is added to modules using the <code>firrtl.group</code>
operation.</p><p>Traits: <code>HasParent&lt;firrtl::CircuitOp, firrtl::LayerOp></code>, <code>IsolatedFromAbove</code>, <code>NoTerminator</code>, <code>SingleBlock</code>, <code>SymbolTable</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-7>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>convention</code></td><td>::circt::firrtl::LayerConventionAttr</td><td>layer convention</td></tr></table><h3 id=firrtloption_case-circtfirrtloptioncaseop><code>firrtl.option_case</code> (::circt::firrtl::OptionCaseOp)</h3><p><em>A configuration option value definition</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.option_case` $sym_name attr-dict
</code></pre><p><code>firrtl.option_case</code> defines an acceptable value to be provided for an
option. Ops reference it to define their behavior when this case is active.</p><p>Traits: <code>HasParent&lt;firrtl::OptionOp></code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-8>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=firrtloption-circtfirrtloptionop><code>firrtl.option</code> (::circt::firrtl::OptionOp)</h3><p><em>An option group definition</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.option` $sym_name attr-dict-with-keyword $body
</code></pre><p>The <code>firrtl.option</code> operation defines a specializable parameter with a
known set of values, represented by the <code>firrtl.option_case</code> operations
nested underneath.</p><p>Operations which support specialization reference the option and its
cases to define the specializations they support.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>
</span></span><span class=line><span class=cl>firrtl<span class=p>.</span>circuit <span class=p>{</span>
</span></span><span class=line><span class=cl>  firrtl<span class=p>.</span>option <span class=nf>@Target</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    firrtl<span class=p>.</span>option_case <span class=nf>@FPGA</span>
</span></span><span class=line><span class=cl>    firrtl<span class=p>.</span>option_case <span class=nf>@ASIC</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>HasParent&lt;firrtl::CircuitOp></code>, <code>IsolatedFromAbove</code>, <code>NoTerminator</code>, <code>SymbolTable</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-9>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h2 id=operation-definitions----declarations>Operation Definitions &ndash; Declarations</h2><h3 id=firrtlinstance_choice-circtfirrtlinstancechoiceop><code>firrtl.instance_choice</code> (::circt::firrtl::InstanceChoiceOp)</h3><p><em>Creates an instance of a module based on a option</em></p><p>The instance choice operation creates an instance choosing the target based
on the value of an option if one is specified, instantiating a default
target otherwise.</p><p>The port lists of all instance targets must match exactly.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>instance_choice foo <span class=nf>@Foo</span> alternatives <span class=nf>@Opt</span> <span class=p>{</span> <span class=nf>@FPGA</span> <span class=p>-&gt;</span> <span class=nf>@FPGAFoo</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span>in io<span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>)</span>
</span></span></code></pre></div><p>Traits: <code>HasParent&lt;firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::WhenOp, firrtl::MatchOp></code></p><p>Interfaces: <code>FNamableOp</code>, <code>HasCustomSSAName</code>, <code>InnerSymbolOpInterface</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-10>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>moduleNames</code></td><td>::mlir::ArrayAttr</td><td>flat symbol ref array attribute</td></tr><tr><td><code>caseNames</code></td><td>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>nameKind</code></td><td>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td><code>portDirections</code></td><td>::mlir::DenseBoolArrayAttr</td><td>i1 dense array attribute</td></tr><tr><td><code>portNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>annotations</code></td><td>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td><code>portAnnotations</code></td><td>::mlir::ArrayAttr</td><td>Port annotations attribute</td></tr><tr><td><code>layers</code></td><td>::mlir::ArrayAttr</td><td>an array of layers</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=firrtlinstance-circtfirrtlinstanceop><code>firrtl.instance</code> (::circt::firrtl::InstanceOp)</h3><p><em>Instantiate an instance of a module</em></p><p>This represents an instance of a module. The results are the modules inputs
and outputs. The inputs have flip type, the outputs do not.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>instance foo <span class=nf>@Foo</span><span class=p>(</span>in io<span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>)</span>
</span></span></code></pre></div><p>Traits: <code>HasParent&lt;firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::WhenOp, firrtl::MatchOp></code></p><p>Interfaces: <code>FInstanceLike</code>, <code>FNamableOp</code>, <code>HasCustomSSAName</code>, <code>InnerSymbolOpInterface</code>, <code>InstanceGraphInstanceOpInterface</code>, <code>InstanceOpInterface</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-11>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>moduleName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>nameKind</code></td><td>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td><code>portDirections</code></td><td>::mlir::DenseBoolArrayAttr</td><td>i1 dense array attribute</td></tr><tr><td><code>portNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>annotations</code></td><td>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td><code>portAnnotations</code></td><td>::mlir::ArrayAttr</td><td>Port annotations attribute</td></tr><tr><td><code>layers</code></td><td>::mlir::ArrayAttr</td><td>an array of layers</td></tr><tr><td><code>lowerToBind</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=firrtlmem-circtfirrtlmemop><code>firrtl.mem</code> (::circt::firrtl::MemOp)</h3><p><em>Define a new mem</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.mem` (`sym` $inner_sym^)? `` custom&lt;NameKind&gt;($nameKind)
              $ruw `` custom&lt;MemOp&gt;(attr-dict) `:` qualified(type($results))
</code></pre><p>Traits: <code>HasParent&lt;firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::WhenOp, firrtl::MatchOp></code></p><p>Interfaces: <code>FNamableOp</code>, <code>HasCustomSSAName</code>, <code>InnerSymbolOpInterface</code></p><h4 id=attributes-12>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>readLatency</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 0</td></tr><tr><td><code>writeLatency</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 1</td></tr><tr><td><code>depth</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 1</td></tr><tr><td><code>ruw</code></td><td>::circt::firrtl::RUWAttrAttr</td><td>Read Under Write Enum</td></tr><tr><td><code>portNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>nameKind</code></td><td>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td><code>annotations</code></td><td>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td><code>portAnnotations</code></td><td>::mlir::ArrayAttr</td><td>Port annotations attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td><code>init</code></td><td>::circt::firrtl::MemoryInitAttr</td><td>Information about the initial state of a memory</td></tr><tr><td><code>prefix</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of FIRRTLType</td></tr></tbody></table><h3 id=firrtlnode-circtfirrtlnodeop><code>firrtl.node</code> (::circt::firrtl::NodeOp)</h3><p><em>No-op to name a value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.node` (`sym` $inner_sym^)? `` custom&lt;NameKind&gt;($nameKind)
              $input (`forceable` $forceable^)? `` custom&lt;FIRRTLImplicitSSAName&gt;(attr-dict) `:` qualified(type($input))
</code></pre><p>A node is simply a named intermediate value in a circuit. The node must
be initialized to a value with a passive type and cannot be connected to.
Nodes are often used to split a complicated compound expression into named
subexpressions.</p><pre tabindex=0><code>  %result = firrtl.node %input : t1
</code></pre><p>Traits: <code>HasParent&lt;firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::WhenOp, firrtl::MatchOp></code></p><p>Interfaces: <code>FNamableOp</code>, <code>Forceable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>InnerSymbolOpInterface</code></p><h4 id=attributes-13>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>nameKind</code></td><td>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td><code>annotations</code></td><td>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td><code>forceable</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr><tr><td style=text-align:center><code>ref</code></td><td>reference type</td></tr></tbody></table><h3 id=firrtlobject-circtfirrtlobjectop><code>firrtl.object</code> (::circt::firrtl::ObjectOp)</h3><p><em>Instantiate a class to produce an object</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.object` `` custom&lt;ImplicitSSAName&gt;(attr-dict) custom&lt;ClassInterface&gt;(type($result))
</code></pre><p>This represents an instance of a class. The results is the instantiated
object.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>object <span class=nf>@Foo</span><span class=p>(</span>in io<span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>)</span>
</span></span></code></pre></div><p>Traits: <code>HasParent&lt;firrtl::FModuleOp, firrtl::ClassOp></code></p><p>Interfaces: <code>FInstanceLike</code>, <code>InstanceGraphInstanceOpInterface</code>, <code>InstanceOpInterface</code>, <code>OpAsmOpInterface</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-14>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>class type</td></tr></tbody></table><h3 id=firrtlreg-circtfirrtlregop><code>firrtl.reg</code> (::circt::firrtl::RegOp)</h3><p><em>Define a new register</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.reg` (`sym` $inner_sym^)? `` custom&lt;NameKind&gt;($nameKind)
              operands (`forceable` $forceable^)? `` custom&lt;FIRRTLImplicitSSAName&gt;(attr-dict) `:` type($clockVal) `,` qualified(type($result)) (`,` qualified(type($ref))^)?
</code></pre><p>Declare a new register:</p><pre tabindex=0><code>%name = firrtl.reg %clockVal : !firrtl.clock, t1
</code></pre><p>Traits: <code>HasParent&lt;firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::WhenOp, firrtl::MatchOp></code></p><p>Interfaces: <code>FNamableOp</code>, <code>Forceable</code>, <code>HasCustomSSAName</code>, <code>InnerSymbolOpInterface</code></p><h4 id=attributes-15>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>nameKind</code></td><td>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td><code>annotations</code></td><td>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td><code>forceable</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clockVal</code></td><td>clock</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a passive non-&lsquo;const&rsquo; base type that does not contain analog</td></tr><tr><td style=text-align:center><code>ref</code></td><td>reference type</td></tr></tbody></table><h3 id=firrtlregreset-circtfirrtlregresetop><code>firrtl.regreset</code> (::circt::firrtl::RegResetOp)</h3><p><em>Define a new register with a reset</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.regreset` (`sym` $inner_sym^)? `` custom&lt;NameKind&gt;($nameKind)
              operands (`forceable` $forceable^)? `` custom&lt;FIRRTLImplicitSSAName&gt;(attr-dict)
              `:` type($clockVal) `,` qualified(type($resetSignal)) `,` qualified(type($resetValue)) `,` qualified(type($result)) (`,` qualified(type($ref))^)?
</code></pre><p>Declare a new register:</p><pre tabindex=0><code>  %name = firrtl.regreset %clockVal, %resetSignal, %resetValue : !firrtl.clock, t1
</code></pre><p>Traits: <code>HasParent&lt;firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::WhenOp, firrtl::MatchOp></code></p><p>Interfaces: <code>FNamableOp</code>, <code>Forceable</code>, <code>HasCustomSSAName</code>, <code>InnerSymbolOpInterface</code></p><h4 id=attributes-16>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>nameKind</code></td><td>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td><code>annotations</code></td><td>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td><code>forceable</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clockVal</code></td><td>clock</td></tr><tr><td style=text-align:center><code>resetSignal</code></td><td>Reset</td></tr><tr><td style=text-align:center><code>resetValue</code></td><td>a base type</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a passive non-&lsquo;const&rsquo; base type that does not contain analog</td></tr><tr><td style=text-align:center><code>ref</code></td><td>reference type</td></tr></tbody></table><h3 id=firrtlwire-circtfirrtlwireop><code>firrtl.wire</code> (::circt::firrtl::WireOp)</h3><p><em>Define a new wire</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.wire` (`sym` $inner_sym^)? `` custom&lt;NameKind&gt;($nameKind)
              (`forceable` $forceable^)? `` custom&lt;FIRRTLImplicitSSAName&gt;(attr-dict) `:`
              qualified(type($result)) (`,` qualified(type($ref))^)?
</code></pre><p>Declare a new wire:</p><pre tabindex=0><code>  %name = firrtl.wire : t1
</code></pre><p>Traits: <code>HasParent&lt;firrtl::FModuleOp, firrtl::LayerBlockOp, firrtl::WhenOp, firrtl::MatchOp></code></p><p>Interfaces: <code>FNamableOp</code>, <code>Forceable</code>, <code>HasCustomSSAName</code>, <code>InnerSymbolOpInterface</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-17>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>nameKind</code></td><td>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td><code>annotations</code></td><td>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td><code>forceable</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr><tr><td style=text-align:center><code>ref</code></td><td>reference type</td></tr></tbody></table><h2 id=statement-operation----statements>Statement Operation &ndash; Statements</h2><h3 id=firrtlassert-circtfirrtlassertop><code>firrtl.assert</code> (::circt::firrtl::AssertOp)</h3><p><em>Assert Verification Statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.assert` $clock `,` $predicate `,` $enable `,`
              $message (`(` $substitutions^ `)`)? `:` type($clock) `,` type($predicate) `,` type($enable) (`,` qualified(type($substitutions))^)?
              custom&lt;VerifAttrs&gt;(attr-dict)
</code></pre><h4 id=attributes-18>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>isConcurrent</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>eventControl</code></td><td>::circt::firrtl::EventControlAttr</td><td>edge control trigger</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=firrtlassume-circtfirrtlassumeop><code>firrtl.assume</code> (::circt::firrtl::AssumeOp)</h3><p><em>Assume Verification Statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.assume` $clock `,` $predicate `,` $enable `,`
              $message (`(` $substitutions^ `)`)? `:` type($clock) `,` type($predicate) `,` type($enable) (`,` qualified(type($substitutions))^)?
              custom&lt;VerifAttrs&gt;(attr-dict)
</code></pre><h4 id=attributes-19>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>isConcurrent</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>eventControl</code></td><td>::circt::firrtl::EventControlAttr</td><td>edge control trigger</td></tr></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=firrtlattach-circtfirrtlattachop><code>firrtl.attach</code> (::circt::firrtl::AttachOp)</h3><p><em>Analog Attach Statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.attach` $attached attr-dict `:` qualified(type($attached))
</code></pre><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>attached</code></td><td>variadic of analog type</td></tr></tbody></table><h3 id=firrtlconnect-circtfirrtlconnectop><code>firrtl.connect</code> (::circt::firrtl::ConnectOp)</h3><p><em>Connect two signals</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.connect` $dest `,` $src  attr-dict `:` qualified(type($dest)) `,` qualified(type($src))
</code></pre><p>Connect Operation:</p><pre tabindex=0><code>  firrtl.connect %dest, %src : t1, t2
</code></pre><p>Interfaces: <code>FConnectLike</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>a base type or foreign type</td></tr><tr><td style=text-align:center><code>src</code></td><td>a base type or foreign type</td></tr></tbody></table><h3 id=firrtlcover-circtfirrtlcoverop><code>firrtl.cover</code> (::circt::firrtl::CoverOp)</h3><p><em>Cover Verification Statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.cover` $clock `,` $predicate `,` $enable `,`
              $message (`(` $substitutions^ `)`)? `:` type($clock) `,` type($predicate) `,` type($enable) (`,` qualified(type($substitutions))^)?
              custom&lt;VerifAttrs&gt;(attr-dict)
</code></pre><h4 id=attributes-20>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>isConcurrent</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>eventControl</code></td><td>::circt::firrtl::EventControlAttr</td><td>edge control trigger</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=firrtlforce-circtfirrtlforceop><code>firrtl.force</code> (::circt::firrtl::ForceOp)</h3><p><em>Force procedural statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.force` $dest `,` $src attr-dict `:` qualified(type($dest)) `,` qualified(type($src))
</code></pre><p>Maps to the corresponding <code>sv.force</code> operation.
Traits: <code>SameTypeOperands</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>a base type</td></tr><tr><td style=text-align:center><code>src</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtllayerblock-circtfirrtllayerblockop><code>firrtl.layerblock</code> (::circt::firrtl::LayerBlockOp)</h3><p><em>A definition of a layer block</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.layerblock` $layerName $region attr-dict
</code></pre><p>The <code>firrtl.layerblock</code> operation defines optional code that is
conditionally part of a <code>firrtl.module</code> if its referenced <code>firrtl.layer</code> is
enabled. This is typically used to store verification or debugging code
that is lowered to a module that is &ldquo;enabled&rdquo; using the <code>firrtl.layer</code>&rsquo;s
convention (e.g., remote instantiation via SystemVerilog <code>bind</code>). A layer
block can read from (capture) values defined in parent layer blocks or in
the parent module, but may not write to hardware declared outside the layer
block.</p><p>A <code>firrtl.layerblock</code> must refer to an existing layer definition
(<code>firrtl.layer</code>) via a symbol reference. A nested <code>firrtl.layerblock</code>
refers to a nested layer definition via a nested symbol reference.</p><p>Traits: <code>HasParent&lt;firrtl::FModuleOp, firrtl::LayerBlockOp></code>, <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>SymbolUserOpInterface</code></p><h4 id=attributes-21>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>layerName</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr></table><h3 id=firrtlmatch-circtfirrtlmatchop><code>firrtl.match</code> (::circt::firrtl::MatchOp)</h3><p><em>Match Statement</em></p><p>The &ldquo;firrtl.match&rdquo; operation represents a pattern matching statement on a
enumeration. This operation does not return a value and cannot be used as an
expression. Last connect semantics work similarly to a when statement.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  firrtl<span class=p>.</span>match <span class=nv>%in</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>enum<span class=p>&lt;</span>Some<span class=p>:</span> uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> None<span class=p>:</span> uint<span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    case Some<span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=p>!</span>firrtl<span class=p>.</span>strictconnect <span class=nv>%w</span><span class=p>,</span> <span class=nv>%arg0</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    case None<span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=p>!</span>firrt<span class=p>.</span>strictconnect <span class=nv>%w</span><span class=p>,</span> <span class=nv>%c1</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>NoTerminator</code>, <code>RecursiveMemoryEffects</code>, <code>RecursivelySpeculatableImplTrait</code>, <code>SingleBlock</code></p><p>Interfaces: <code>ConditionallySpeculatable</code></p><h4 id=attributes-22>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tags</code></td><td>::mlir::ArrayAttr</td><td>32-bit integer array attribute</td></tr></table><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>enum type</td></tr></tbody></table><h3 id=firrtlprintf-circtfirrtlprintfop><code>firrtl.printf</code> (::circt::firrtl::PrintFOp)</h3><p><em>Formatted Print Statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.printf` $clock `,` $cond `,` $formatString `` custom&lt;PrintfAttrs&gt;(attr-dict) ` `
              (`(` $substitutions^ `)`)? `:` type($clock) `,` type($cond) (`,` qualified(type($substitutions))^)?
</code></pre><h4 id=attributes-23>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>formatString</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>cond</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of a base type</td></tr></tbody></table><h3 id=firrtlpropassign-circtfirrtlpropassignop><code>firrtl.propassign</code> (::circt::firrtl::PropAssignOp)</h3><p><em>Assign to a sink property value.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.propassign` $dest `,` $src attr-dict `:` qualified(type($dest))
</code></pre><p>Assign an output property value. The types must match exactly.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  firrtl<span class=p>.</span>propassign <span class=nv>%dest</span><span class=p>,</span> <span class=nv>%src</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>string
</span></span></code></pre></div><p>Traits: <code>HasParent&lt;FModuleOp, ClassOp, LayerBlockOp></code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>FConnectLike</code></p><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>property type</td></tr><tr><td style=text-align:center><code>src</code></td><td>property type</td></tr></tbody></table><h3 id=firrtlrefdefine-circtfirrtlrefdefineop><code>firrtl.ref.define</code> (::circt::firrtl::RefDefineOp)</h3><p><em>FIRRTL Define References</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.define` $dest `,` $src  attr-dict `:` qualified(type($dest))
</code></pre><p>Define a target reference to the source reference:</p><pre tabindex=0><code>  firrtl.ref.define %dest, %src : ref&lt;t1&gt;
</code></pre><p>Used to statically route reference from source to destination
through the design, one module at a time.</p><p>Similar to &ldquo;connect&rdquo; but cannot have multiple define&rsquo;s to same
destination and the define is never conditional even if under
a &ldquo;when&rdquo;.</p><p>Source and destination must resolve statically.</p><p>Traits: <code>SameTypeOperands</code></p><p>Interfaces: <code>FConnectLike</code></p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>reference type</td></tr><tr><td style=text-align:center><code>src</code></td><td>reference type</td></tr></tbody></table><h3 id=firrtlrefforce_initial-circtfirrtlrefforceinitialop><code>firrtl.ref.force_initial</code> (::circt::firrtl::RefForceInitialOp)</h3><p><em>FIRRTL force_initial statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.force_initial` $predicate `,` $dest `,` $src attr-dict `:` type($predicate) `,` qualified(type($src))
</code></pre><p>Force a RWProbe to the specified value continuously.</p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>dest</code></td><td>rwprobe type</td></tr><tr><td style=text-align:center><code>src</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlrefforce-circtfirrtlrefforceop><code>firrtl.ref.force</code> (::circt::firrtl::RefForceOp)</h3><p><em>FIRRTL force statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.force` $clock `,` $predicate `,` $dest `,` $src attr-dict `:` type($clock) `,` type($predicate) `,` qualified(type($src))
</code></pre><p>Force a RWProbe to the specified value using the specified clock and predicate.</p><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>dest</code></td><td>rwprobe type</td></tr><tr><td style=text-align:center><code>src</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlrefrelease_initial-circtfirrtlrefreleaseinitialop><code>firrtl.ref.release_initial</code> (::circt::firrtl::RefReleaseInitialOp)</h3><p><em>FIRRTL release_initial statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.release_initial` $predicate `,` $dest attr-dict `:` type($predicate) `,` qualified(type($dest))
</code></pre><p>Release the target RWProbe.</p><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>dest</code></td><td>rwprobe type</td></tr></tbody></table><h3 id=firrtlrefrelease-circtfirrtlrefreleaseop><code>firrtl.ref.release</code> (::circt::firrtl::RefReleaseOp)</h3><p><em>FIRRTL release statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.release` $clock `,` $predicate `,` $dest attr-dict `:` type($clock) `,` type($predicate) `,` qualified(type($dest))
</code></pre><p>Release the target RWProbe using the specified clock and predicate.</p><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>dest</code></td><td>rwprobe type</td></tr></tbody></table><h3 id=firrtlskip-circtfirrtlskipop><code>firrtl.skip</code> (::circt::firrtl::SkipOp)</h3><p><em>Skip statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.skip` attr-dict
</code></pre><p>Skip Statement:</p><pre tabindex=0><code>   %firrtl.skip
</code></pre><p>This is a no-op statement.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h3 id=firrtlstop-circtfirrtlstopop><code>firrtl.stop</code> (::circt::firrtl::StopOp)</h3><p><em>Stop Statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.stop` $clock `,` $cond `,` $exitCode `` custom&lt;StopAttrs&gt;(attr-dict) `:` type($clock) `,` type($cond)
</code></pre><h4 id=attributes-24>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>exitCode</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>cond</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlstrictconnect-circtfirrtlstrictconnectop><code>firrtl.strictconnect</code> (::circt::firrtl::StrictConnectOp)</h3><p><em>Connect two signals</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.strictconnect` $dest `,` $src  attr-dict `:`
              custom&lt;OptionalBinaryOpTypes&gt;(type($dest), type($src))
</code></pre><p>Connect two values with strict constraints:</p><pre tabindex=0><code>  firrtl.strictconnect %dest, %src : t1
  firrtl.strictconnect %dest, %src : t1, !firrtl.alias&lt;foo, t1&gt;
</code></pre><p>Interfaces: <code>FConnectLike</code></p><h4 id=operands-18>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>a sized passive base type (contains no uninferred widths, or flips) or foreign type</td></tr><tr><td style=text-align:center><code>src</code></td><td>a sized passive base type (contains no uninferred widths, or flips) or foreign type</td></tr></tbody></table><h3 id=firrtlintverifassert-circtfirrtlverifassertintrinsicop><code>firrtl.int.verif.assert</code> (::circt::firrtl::VerifAssertIntrinsicOp)</h3><p><em>FIRRTL variant of <code>verif.assert</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.verif.assert` operands attr-dict `:` type(operands)
</code></pre><p>See <code>verif.assert</code> op in the Verif dialect.</p><h4 id=attributes-25>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>label</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-19>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>property</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlintverifassume-circtfirrtlverifassumeintrinsicop><code>firrtl.int.verif.assume</code> (::circt::firrtl::VerifAssumeIntrinsicOp)</h3><p><em>FIRRTL variant of <code>verif.assume</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.verif.assume` operands attr-dict `:` type(operands)
</code></pre><p>See <code>verif.assume</code> op in the Verif dialect.</p><h4 id=attributes-26>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>label</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-20>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>property</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlintverifcover-circtfirrtlverifcoverintrinsicop><code>firrtl.int.verif.cover</code> (::circt::firrtl::VerifCoverIntrinsicOp)</h3><p><em>FIRRTL variant of <code>verif.cover</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.verif.cover` operands attr-dict `:` type(operands)
</code></pre><p>See <code>verif.cover</code> op in the Verif dialect.</p><h4 id=attributes-27>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>label</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-21>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>property</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlwhen-circtfirrtlwhenop><code>firrtl.when</code> (::circt::firrtl::WhenOp)</h3><p><em>When Statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.when` $condition `:` type($condition) $thenRegion (`else` $elseRegion^)? attr-dict-with-keyword
</code></pre><p>The &ldquo;firrtl.when&rdquo; operation represents a conditional. Connections within
a conditional statement that connect to previously declared components hold
only when the given condition is high. The condition must have a 1-bit
unsigned integer type.</p><p>Traits: <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><h4 id=operands-22>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>1-bit uint</td></tr></tbody></table><h2 id=operation-definitions----expressions>Operation Definitions &ndash; Expressions</h2><h3 id=firrtladd-circtfirrtladdprimop><code>firrtl.add</code> (::circt::firrtl::AddPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.add` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsIntTypeKind</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-23>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlaggregateconstant-circtfirrtlaggregateconstantop><code>firrtl.aggregateconstant</code> (::circt::firrtl::AggregateConstantOp)</h3><p><em>Produce a constant of a passive aggregate value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.aggregateconstant` $fields attr-dict `:` type($result)
</code></pre><p>The constant operation produces a constant value of an aggregate type. The
type must be passive. Clock and reset values are supported.
For nested aggregates, embedded arrays are used.</p><pre tabindex=0><code>  %result = firrtl.aggregateconstant [1, 2, 3] : !firrtl.bundle&lt;a: uint&lt;8&gt;, b: uint&lt;5&gt;, c: uint&lt;4&gt;&gt;
  %result = firrtl.aggregateconstant [1, 2, 3] : !firrtl.vector&lt;uint&lt;8&gt;, 3&gt;
  %result = firrtl.aggregateconstant [[1, 2], [3, 5]] : !firrtl.vector&lt;!firrtl.bundle&lt;a: uint&lt;8&gt;, b: uint&lt;5&gt;&gt;, 2&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-28>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fields</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a aggregate type</td></tr></tbody></table><h3 id=firrtland-circtfirrtlandprimop><code>firrtl.and</code> (::circt::firrtl::AndPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.and` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsIntTypeKind</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-24>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlandr-circtfirrtlandrprimop><code>firrtl.andr</code> (::circt::firrtl::AndRPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.andr` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Horizontally reduce a value to one bit, using the &lsquo;and&rsquo; operation to merge
bits. <code>andr(x)</code> is equivalent to <code>concat(x, 1b1) == ~0</code>. As such, it
returns 1 for zero-bit-wide operands.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-25>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlasasyncreset-circtfirrtlasasyncresetprimop><code>firrtl.asAsyncReset</code> (::circt::firrtl::AsAsyncResetPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.asAsyncReset` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-26>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit uint/sint/analog, reset, asyncreset, or clock</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>async reset type</td></tr></tbody></table><h3 id=firrtlasclock-circtfirrtlasclockprimop><code>firrtl.asClock</code> (::circt::firrtl::AsClockPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.asClock` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-27>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit uint/sint/analog, reset, asyncreset, or clock</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>clock</td></tr></tbody></table><h3 id=firrtlassint-circtfirrtlassintprimop><code>firrtl.asSInt</code> (::circt::firrtl::AsSIntPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.asSInt` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-28>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a base type</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint type</td></tr></tbody></table><h3 id=firrtlasuint-circtfirrtlasuintprimop><code>firrtl.asUInt</code> (::circt::firrtl::AsUIntPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.asUInt` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-29>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a base type</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlbitcast-circtfirrtlbitcastop><code>firrtl.bitcast</code> (::circt::firrtl::BitCastOp)</h3><p><em>Reinterpret one value to another value of the same size and
potentially different type. This op is lowered to hw::BitCastOp.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.bitcast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-30>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a base type</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h3 id=firrtlbits-circtfirrtlbitsprimop><code>firrtl.bits</code> (::circt::firrtl::BitsPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.bits` $input $hi `to` $lo attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>bits</code> operation extracts the bits between <code>hi</code> (inclusive) and <code>lo</code>
(inclusive) from <code>input</code>. <code>hi</code> must be greater than or equal to <code>lo</code>. Both
<code>hi</code> and <code>lo</code> must be non-negative and less than the bit width of <code>input</code>.
The result is <code>hi - lo + 1</code> bits wide.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-29>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>hi</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>lo</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-31>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlbool-circtfirrtlboolconstantop><code>firrtl.bool</code> (::circt::firrtl::BoolConstantOp)</h3><p><em>Produce a constant boolean value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.bool` $value attr-dict
</code></pre><p>Produces a constant value of boolean type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>bool true
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-30>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=results-18>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>boolean type</td></tr></tbody></table><h3 id=firrtlbundlecreate-circtfirrtlbundlecreateop><code>firrtl.bundlecreate</code> (::circt::firrtl::BundleCreateOp)</h3><p><em>Produce a bundle value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.bundlecreate` $fields attr-dict `:` functional-type($fields, $result)
</code></pre><p>Create an bundle from component values. This is equivalent in terms of
flow to creating a node.</p><pre tabindex=0><code>  %result = firrtl.bundlecreate %1, %2, %3 : !firrtl.bundle&lt;a: uint&lt;8&gt;, b: uint&lt;5&gt;, c: uint&lt;4&gt;&gt;
</code></pre><h4 id=operands-32>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fields</code></td><td>variadic of a base type</td></tr></tbody></table><h4 id=results-19>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bundle type</td></tr></tbody></table><h3 id=firrtlcat-circtfirrtlcatprimop><code>firrtl.cat</code> (::circt::firrtl::CatPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.cat` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsIntTypeKind</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-33>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-20>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlconstcast-circtfirrtlconstcastop><code>firrtl.constCast</code> (::circt::firrtl::ConstCastOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.constCast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Cast from a &lsquo;const&rsquo; to a non-&lsquo;const&rsquo; type.</p><pre tabindex=0><code>%result = firrtl.constCast %in : (!firrtl.const.t1) -&gt; !firrtl.t1
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-34>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h4 id=results-21>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h3 id=firrtlconstant-circtfirrtlconstantop><code>firrtl.constant</code> (::circt::firrtl::ConstantOp)</h3><p><em>Produce a constant value</em></p><p>The constant operation produces a constant value of SInt or UInt type, it
never produces a zero bit wide result.</p><pre tabindex=0><code>  %result = firrtl.constant 42 : t1
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code>, <code>FirstAttrDerivedResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-31>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute with sign</td></tr></table><h4 id=results-22>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlcvt-circtfirrtlcvtprimop><code>firrtl.cvt</code> (::circt::firrtl::CvtPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.cvt` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-35>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-23>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint type</td></tr></tbody></table><h3 id=firrtldshl-circtfirrtldshlprimop><code>firrtl.dshl</code> (::circt::firrtl::DShlPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.dshl` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>A dynamic shift left operation. The width of <code>$result</code> is expanded to
<code>width($lhs) + 1 &lt;&lt; width($rhs) - 1</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-36>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>uint type</td></tr></tbody></table><h4 id=results-24>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldshlw-circtfirrtldshlwprimop><code>firrtl.dshlw</code> (::circt::firrtl::DShlwPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.dshlw` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>A dynamic shift left operation same as &lsquo;dshl&rsquo; but with different width rule.
The width of <code>$result</code> is equal to <code>$lhs</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-37>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>uint type</td></tr></tbody></table><h4 id=results-25>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldshr-circtfirrtldshrprimop><code>firrtl.dshr</code> (::circt::firrtl::DShrPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.dshr` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-38>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>uint type</td></tr></tbody></table><h4 id=results-26>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldiv-circtfirrtldivprimop><code>firrtl.div</code> (::circt::firrtl::DivPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.div` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Divides the first argument (the numerator) by the second argument
(the denominator) truncating the result (rounding towards zero).</p><p><strong>If the denominator is zero, the result is undefined.</strong></p><p>The compiler may optimize this undefined behavior in any way it
wants. Notably <code>div(a, a)</code> will be optimized to <code>1</code>. This may cause
erroneous formal equivalence mismatches between unoptimized and
optimized FIRRTL dialects that are separately converted to Verilog.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsIntTypeKind</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-39>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-27>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldouble-circtfirrtldoubleconstantop><code>firrtl.double</code> (::circt::firrtl::DoubleConstantOp)</h3><p><em>Produce a constant double value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.double` $value attr-dict
</code></pre><p>Produces a constant value of double type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>double <span class=m>3.2</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-32>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::FloatAttr</td><td>double-precision float</td></tr></table><h4 id=results-28>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>double type</td></tr></tbody></table><h3 id=firrtleq-circtfirrtleqprimop><code>firrtl.eq</code> (::circt::firrtl::EQPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.eq` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsIntTypeKind</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-40>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-29>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlelementwise_and-circtfirrtlelementwiseandprimop><code>firrtl.elementwise_and</code> (::circt::firrtl::ElementwiseAndPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.elementwise_and` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-41>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>1d vector with Int element type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>1d vector with Int element type</td></tr></tbody></table><h4 id=results-30>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1d vector with UInt element type</td></tr></tbody></table><h3 id=firrtlelementwise_or-circtfirrtlelementwiseorprimop><code>firrtl.elementwise_or</code> (::circt::firrtl::ElementwiseOrPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.elementwise_or` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-42>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>1d vector with Int element type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>1d vector with Int element type</td></tr></tbody></table><h4 id=results-31>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1d vector with UInt element type</td></tr></tbody></table><h3 id=firrtlelementwise_xor-circtfirrtlelementwisexorprimop><code>firrtl.elementwise_xor</code> (::circt::firrtl::ElementwiseXorPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.elementwise_xor` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-43>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>1d vector with UInt element type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>1d vector with Int element type</td></tr></tbody></table><h4 id=results-32>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1d vector with UInt element type</td></tr></tbody></table><h3 id=firrtlenumcreate-circtfirrtlfenumcreateop><code>firrtl.enumcreate</code> (::circt::firrtl::FEnumCreateOp)</h3><p><em>Produce a enum value</em></p><p>Create an enum from tag and value.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>%result</span> <span class=p>=</span> firrtl<span class=p>.</span>enumcreate field<span class=err>-</span>name<span class=p>(</span><span class=nv>%input</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>enum<span class=p>&lt;</span>None<span class=p>:</span> uint<span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;,</span> Some<span class=p>:</span> uint<span class=p>&lt;</span><span class=m>8</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><h4 id=attributes-33>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fieldIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-44>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a base type</td></tr></tbody></table><h4 id=results-33>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>enum type</td></tr></tbody></table><h3 id=firrtlinteger-circtfirrtlfintegerconstantop><code>firrtl.integer</code> (::circt::firrtl::FIntegerConstantOp)</h3><p><em>Produce a constant integer value</em></p><p>Produces a constant value of integer type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>integer <span class=m>42</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-34>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute with sign</td></tr></table><h4 id=results-34>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>integer type</td></tr></tbody></table><h3 id=firrtlgeq-circtfirrtlgeqprimop><code>firrtl.geq</code> (::circt::firrtl::GEQPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.geq` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsIntTypeKind</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-45>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-35>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlgt-circtfirrtlgtprimop><code>firrtl.gt</code> (::circt::firrtl::GTPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.gt` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsIntTypeKind</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-46>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-36>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlhwstructcast-circtfirrtlhwstructcastop><code>firrtl.hwStructCast</code> (::circt::firrtl::HWStructCastOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.hwStructCast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-47>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results-37>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlhead-circtfirrtlheadprimop><code>firrtl.head</code> (::circt::firrtl::HeadPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.head` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-35>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>amount</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-48>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-38>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlintegeradd-circtfirrtlintegeraddop><code>firrtl.integer.add</code> (::circt::firrtl::IntegerAddOp)</h3><p><em>Add two FIntegerType values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.integer.add` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>The add operation result is the arbitrary precision signed integer
arithmetic sum of the two operands.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> firrtl<span class=p>.</span>integer<span class=p>.</span>add <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>(!</span>firrtl<span class=p>.</span>integer<span class=p>,</span> <span class=p>!</span>firrtl<span class=p>.</span>integer<span class=p>)</span> <span class=p>-&gt;</span>
</span></span><span class=line><span class=cl>                                     <span class=p>!</span>firrtl<span class=p>.</span>integer
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-49>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>integer type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>integer type</td></tr></tbody></table><h4 id=results-39>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>integer type</td></tr></tbody></table><h3 id=firrtlintegermul-circtfirrtlintegermulop><code>firrtl.integer.mul</code> (::circt::firrtl::IntegerMulOp)</h3><p><em>Multiply two FIntegerType values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.integer.mul` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>The multiply operation result is the arbitrary precision signed integer
arithmetic product of the two operands.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> firrtl<span class=p>.</span>integer<span class=p>.</span>mul <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>(!</span>firrtl<span class=p>.</span>integer<span class=p>,</span> <span class=p>!</span>firrtl<span class=p>.</span>integer<span class=p>)</span> <span class=p>-&gt;</span>
</span></span><span class=line><span class=cl>                                     <span class=p>!</span>firrtl<span class=p>.</span>integer
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-50>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>integer type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>integer type</td></tr></tbody></table><h4 id=results-40>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>integer type</td></tr></tbody></table><h3 id=firrtlintegershr-circtfirrtlintegershrop><code>firrtl.integer.shr</code> (::circt::firrtl::IntegerShrOp)</h3><p><em>Shift an FIntegerType value right by an FIntegerType value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.integer.shr` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>The shift right operation result is the arbitrary precision signed integer
arithmetic shift right of the lhs operand by the rhs operand. The rhs
operand must be non-negative.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> firrtl<span class=p>.</span>integer<span class=p>.</span>shr <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>(!</span>firrtl<span class=p>.</span>integer<span class=p>,</span> <span class=p>!</span>firrtl<span class=p>.</span>integer<span class=p>)</span> <span class=p>-&gt;</span>
</span></span><span class=line><span class=cl>                                     <span class=p>!</span>firrtl<span class=p>.</span>integer
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-51>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>integer type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>integer type</td></tr></tbody></table><h4 id=results-41>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>integer type</td></tr></tbody></table><h3 id=firrtlinvalidvalue-circtfirrtlinvalidvalueop><code>firrtl.invalidvalue</code> (::circt::firrtl::InvalidValueOp)</h3><p><em>InvalidValue primitive</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.invalidvalue` attr-dict `:` qualified(type($result))
</code></pre><p>The InvalidValue operation returns an invalid value of a specified type:</p><pre tabindex=0><code>  %result = firrtl.invalid : !firrtl.uint&lt;1&gt;
</code></pre><p>This corresponds to the FIRRTL invalidate operation without the implicit
connect semantics. Each invalid op produces a unique invalid value.
InvalidOp is not constant-like</p><p>Interfaces: <code>HasCustomSSAName</code>, <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=results-42>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlistag-circtfirrtlistagop><code>firrtl.istag</code> (::circt::firrtl::IsTagOp)</h3><p><em>Test the active variant of an enumeration</em></p><p>This operation is used to test the active variant of an enumeration. The
tag tested for must be one of the possible variants of the input type. If
the tag is the currently active variant the result will be 1, otherwise the
result will be 0.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>istag A <span class=nv>%v</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>enum<span class=p>&lt;</span>A<span class=p>:</span> UInt<span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;,</span> B<span class=p>:</span> UInt<span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-36>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fieldIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-52>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>enum type</td></tr></tbody></table><h4 id=results-43>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlleq-circtfirrtlleqprimop><code>firrtl.leq</code> (::circt::firrtl::LEQPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.leq` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsIntTypeKind</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-53>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-44>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlintltland-circtfirrtlltlandintrinsicop><code>firrtl.int.ltl.and</code> (::circt::firrtl::LTLAndIntrinsicOp)</h3><p><em>FIRRTL variant of <code>ltl.and</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.ltl.and` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>See <code>ltl.and</code> op in the LTL dialect.
Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-54>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>1-bit uint</td></tr></tbody></table><h4 id=results-45>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlintltlclock-circtfirrtlltlclockintrinsicop><code>firrtl.int.ltl.clock</code> (::circt::firrtl::LTLClockIntrinsicOp)</h3><p><em>FIRRTL variant of <code>ltl.clock</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.ltl.clock` $input `,` $clock attr-dict `:` functional-type(operands, results)
</code></pre><p>See <code>ltl.clock</code> op in the LTL dialect.
Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-55>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr></tbody></table><h4 id=results-46>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlintltlconcat-circtfirrtlltlconcatintrinsicop><code>firrtl.int.ltl.concat</code> (::circt::firrtl::LTLConcatIntrinsicOp)</h3><p><em>FIRRTL variant of <code>ltl.concat</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.ltl.concat` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>See <code>ltl.concat</code> op in the LTL dialect.
Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-56>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>1-bit uint</td></tr></tbody></table><h4 id=results-47>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlintltldelay-circtfirrtlltldelayintrinsicop><code>firrtl.int.ltl.delay</code> (::circt::firrtl::LTLDelayIntrinsicOp)</h3><p><em>FIRRTL variant of <code>ltl.delay</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.ltl.delay` $input `,` $delay (`,` $length^)? attr-dict `:`
              functional-type(operands, results)
</code></pre><p>See <code>ltl.delay</code> op in the LTL dialect.
Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-37>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>delay</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>length</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-57>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit uint</td></tr></tbody></table><h4 id=results-48>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlintltldisable-circtfirrtlltldisableintrinsicop><code>firrtl.int.ltl.disable</code> (::circt::firrtl::LTLDisableIntrinsicOp)</h3><p><em>FIRRTL variant of <code>ltl.disable</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.ltl.disable` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>See <code>ltl.disable</code> op in the LTL dialect.
Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-58>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>1-bit uint</td></tr></tbody></table><h4 id=results-49>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlintltleventually-circtfirrtlltleventuallyintrinsicop><code>firrtl.int.ltl.eventually</code> (::circt::firrtl::LTLEventuallyIntrinsicOp)</h3><p><em>FIRRTL variant of <code>ltl.eventually</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.ltl.eventually` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>See <code>ltl.eventually</code> op in the LTL dialect.
Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-59>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit uint</td></tr></tbody></table><h4 id=results-50>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlintltlimplication-circtfirrtlltlimplicationintrinsicop><code>firrtl.int.ltl.implication</code> (::circt::firrtl::LTLImplicationIntrinsicOp)</h3><p><em>FIRRTL variant of <code>ltl.implication</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.ltl.implication` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>See <code>ltl.implication</code> op in the LTL dialect.
Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-60>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>1-bit uint</td></tr></tbody></table><h4 id=results-51>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlintltlnot-circtfirrtlltlnotintrinsicop><code>firrtl.int.ltl.not</code> (::circt::firrtl::LTLNotIntrinsicOp)</h3><p><em>FIRRTL variant of <code>ltl.not</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.ltl.not` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>See <code>ltl.not</code> op in the LTL dialect.
Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-61>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit uint</td></tr></tbody></table><h4 id=results-52>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlintltlor-circtfirrtlltlorintrinsicop><code>firrtl.int.ltl.or</code> (::circt::firrtl::LTLOrIntrinsicOp)</h3><p><em>FIRRTL variant of <code>ltl.or</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.ltl.or` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>See <code>ltl.or</code> op in the LTL dialect.
Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-62>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>1-bit uint</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>1-bit uint</td></tr></tbody></table><h4 id=results-53>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtllt-circtfirrtlltprimop><code>firrtl.lt</code> (::circt::firrtl::LTPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.lt` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsIntTypeKind</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-63>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-54>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtllistcreate-circtfirrtllistcreateop><code>firrtl.list.create</code> (::circt::firrtl::ListCreateOp)</h3><p><em>Produce a list value</em></p><p>Produces a value of list type containing the provided elements.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> firrtl<span class=p>.</span>list<span class=p>.</span>create <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>list<span class=p>&lt;</span>string<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-64>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>elements</code></td><td>variadic of property type</td></tr></tbody></table><h4 id=results-55>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>list type</td></tr></tbody></table><h3 id=firrtlmul-circtfirrtlmulprimop><code>firrtl.mul</code> (::circt::firrtl::MulPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.mul` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsIntTypeKind</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-65>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-56>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlmultibit_mux-circtfirrtlmultibitmuxop><code>firrtl.multibit_mux</code> (::circt::firrtl::MultibitMuxOp)</h3><p><em>Multibit multiplexer</em></p><p>The multibit mux expression dynamically selects operands. The
index must be an expression with an unsigned integer type.</p><pre tabindex=0><code>  %result = firrtl.multibit_mux %index,
            %v_{n-1}, ..., %v_2, %v_1, %v_0  : t1, t2
</code></pre><p>The order of operands is defined in the same way as hw dialect.
For the example above, if <code>%index</code> is 0, then the value is <code>%v_0</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-66>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>index</code></td><td>uint type</td></tr><tr><td style=text-align:center><code>inputs</code></td><td>variadic of a base type</td></tr></tbody></table><h4 id=results-57>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlintmux2cell-circtfirrtlmux2cellintrinsicop><code>firrtl.int.mux2cell</code> (::circt::firrtl::Mux2CellIntrinsicOp)</h3><p><em>An intrinsic lowered into 2-to-1 MUX cell in synthesis tools.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.mux2cell` `(` operands `)` attr-dict `:` functional-type(operands, $result)
</code></pre><p>This intrinsic exposes a low-level API to use 2-to-1 MUX cell in backend
synthesis tool. At FIRRTL level, this operation participates
the inference process in the same way as a normal mux operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-67>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sel</code></td><td>1-bit uint or uint with uninferred width</td></tr><tr><td style=text-align:center><code>high</code></td><td>a passive base type (contain no flips)</td></tr><tr><td style=text-align:center><code>low</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h4 id=results-58>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h3 id=firrtlintmux4cell-circtfirrtlmux4cellintrinsicop><code>firrtl.int.mux4cell</code> (::circt::firrtl::Mux4CellIntrinsicOp)</h3><p><em>An intrinsic lowered into 4-to-1 MUX cell in synthesis tools.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.mux4cell` `(` operands `)` attr-dict `:` functional-type(operands, $result)
</code></pre><p>This intrinsic exposes a low-level API to use 4-to-1 MUX cell in backend
synthesis tool. At FIRRTL level, this operation participates
the inference process as a sugar of mux operation chains.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-68>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sel</code></td><td>2-bit uint or uint with uninferred width</td></tr><tr><td style=text-align:center><code>v3</code></td><td>a passive base type (contain no flips)</td></tr><tr><td style=text-align:center><code>v2</code></td><td>a passive base type (contain no flips)</td></tr><tr><td style=text-align:center><code>v1</code></td><td>a passive base type (contain no flips)</td></tr><tr><td style=text-align:center><code>v0</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h4 id=results-59>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h3 id=firrtlmux-circtfirrtlmuxprimop><code>firrtl.mux</code> (::circt::firrtl::MuxPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.mux` `(` operands `)` attr-dict `:` functional-type(operands, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-69>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sel</code></td><td>1-bit uint or uint with uninferred width</td></tr><tr><td style=text-align:center><code>high</code></td><td>a passive base type (contain no flips)</td></tr><tr><td style=text-align:center><code>low</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h4 id=results-60>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h3 id=firrtlneq-circtfirrtlneqprimop><code>firrtl.neq</code> (::circt::firrtl::NEQPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.neq` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsIntTypeKind</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-70>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-61>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlneg-circtfirrtlnegprimop><code>firrtl.neg</code> (::circt::firrtl::NegPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.neg` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-71>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-62>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint type</td></tr></tbody></table><h3 id=firrtlnot-circtfirrtlnotprimop><code>firrtl.not</code> (::circt::firrtl::NotPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.not` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-72>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-63>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlobjectanyref_cast-circtfirrtlobjectanyrefcastop><code>firrtl.object.anyref_cast</code> (::circt::firrtl::ObjectAnyRefCastOp)</h3><p><em>Cast object reference to anyref.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.object.anyref_cast` $input attr-dict `:` type($input)
</code></pre><p>Cast any object reference to AnyRef type. This is needed for passing objects
of a known class to sinks that accept any reference.</p><p>Example</p><pre tabindex=0><code>  %0= firrtl.object.anyref_cast %object : !firrtl.class&lt;@Foo()&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-73>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>class type</td></tr></tbody></table><h4 id=results-64>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any reference type</td></tr></tbody></table><h3 id=firrtlobjectsubfield-circtfirrtlobjectsubfieldop><code>firrtl.object.subfield</code> (::circt::firrtl::ObjectSubfieldOp)</h3><p><em>Extract an element of an object</em></p><p>The object.subfield expression refers to a subelement of an object.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%field</span> <span class=p>=</span> firrtl<span class=p>.</span>object<span class=p>.</span>subfield <span class=nv>%object</span><span class=p>[</span>field<span class=p>]</span> <span class=p>:</span> <span class=p>!</span>firrt<span class=p>.</span>class<span class=p>&lt;</span><span class=nf>@Class</span><span class=p>(</span>field<span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>string<span class=p>)&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-38>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-74>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>class type</td></tr></tbody></table><h4 id=results-65>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>property type</td></tr></tbody></table><h3 id=firrtlopensubfield-circtfirrtlopensubfieldop><code>firrtl.opensubfield</code> (::circt::firrtl::OpenSubfieldOp)</h3><p><em>Extract a subfield of another value</em></p><p>The subfield expression refers to a subelement of an expression with a
bundle type.</p><pre tabindex=0><code>  %result = firrtl.opensubfield %input[field-name] : !input-type
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-39>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fieldIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-75>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>open bundle type</td></tr></tbody></table><h4 id=results-66>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlopensubindex-circtfirrtlopensubindexop><code>firrtl.opensubindex</code> (::circt::firrtl::OpenSubindexOp)</h3><p><em>Extract an element of a vector value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.opensubindex` $input `[` $index `]` attr-dict `:` qualified(type($input))
</code></pre><p>The subindex expression statically refers, by index, to a subelement
of an expression with a vector type. The index must be a non-negative
integer and cannot be equal to or exceed the length of the vector it
indexes.</p><pre tabindex=0><code>  %result = firrtl.opensubindex %input[index] : t1
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-40>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-76>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>open vector type</td></tr></tbody></table><h4 id=results-67>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlor-circtfirrtlorprimop><code>firrtl.or</code> (::circt::firrtl::OrPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.or` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsIntTypeKind</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-77>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-68>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlorr-circtfirrtlorrprimop><code>firrtl.orr</code> (::circt::firrtl::OrRPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.orr` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Horizontally reduce a value to one bit, using the &lsquo;or&rsquo; operation to merge
bits. <code>orr(x)</code> is equivalent to <code>concat(x, 1b0) != 0</code>. As such, it
returns 0 for zero-bit-wide operands.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-78>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-69>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h3 id=firrtlpad-circtfirrtlpadprimop><code>firrtl.pad</code> (::circt::firrtl::PadPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.pad` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>Pad the input out to an <code>amount</code> wide integer, sign extending or zero
extending according to <code>input</code>s type. If <code>amount</code> is less than the existing
width of <code>input</code>, then input is unmodified.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-41>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>amount</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-79>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-70>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlpath-circtfirrtlpathop><code>firrtl.path</code> (::circt::firrtl::PathOp)</h3><p><em>Produce a path value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.path` $targetKind $target attr-dict
</code></pre><p>Produces a value which represents a path to the target in a design.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>hw<span class=p>.</span>hierpath <span class=nf>@Path</span> <span class=p>[</span><span class=nf>@Foo</span><span class=p>::</span><span class=nf>@bar</span><span class=p>,</span> <span class=nf>@Bar</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nv>%wire</span> <span class=p>=</span> firrtl<span class=p>.</span>wire <span class=p>{</span><span class=nl>annotations =</span> <span class=p>[</span> <span class=p>{</span><span class=nl>class =</span> <span class=s>&#34;circt.tracker&#34;</span><span class=p>,</span> <span class=nl>id =</span> distinct<span class=p>[</span><span class=m>0</span><span class=p>]&lt;&gt;,</span> <span class=nl>circt.nonlocal =</span> <span class=nf>@Path</span><span class=p>}</span> <span class=p>]}</span> <span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>path reference distinct<span class=p>[</span><span class=m>0</span><span class=p>]&lt;&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-42>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>targetKind</code></td><td>::circt::firrtl::TargetKindAttr</td><td>object model target kind</td></tr><tr><td><code>target</code></td><td>::mlir::DistinctAttr</td><td>distinct attribute</td></tr></table><h4 id=results-71>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>path type</td></tr></tbody></table><h3 id=firrtlrefrwprobe-circtfirrtlrwprobeop><code>firrtl.ref.rwprobe</code> (::circt::firrtl::RWProbeOp)</h3><p><em>FIRRTL RWProbe</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.rwprobe` $target attr-dict `:` type($result)
</code></pre><p>Create a RWProbe for the target.
Target must be local.</p><pre tabindex=0><code>  %result = firrtl.ref.rwprobe @mod::@sym : firrtl.rwprobe&lt;t&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InnerRefUserOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-43>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>target</code></td><td>::circt::hw::InnerRefAttr</td><td>Refer to a name inside a module</td></tr></table><h4 id=results-72>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>rwprobe type (with concrete resets only)</td></tr></tbody></table><h3 id=firrtlrefcast-circtfirrtlrefcastop><code>firrtl.ref.cast</code> (::circt::firrtl::RefCastOp)</h3><p><em>Cast between compatible reference types</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.cast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Losslessly cast between compatible reference types.
Source and destination must be recursively identical or destination
has uninferred variants of the corresponding element in source.</p><pre tabindex=0><code>  %result = firrtl.ref.cast %ref : (t1) -&gt; t2
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-80>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>reference type</td></tr></tbody></table><h4 id=results-73>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>reference type</td></tr></tbody></table><h3 id=firrtlrefresolve-circtfirrtlrefresolveop><code>firrtl.ref.resolve</code> (::circt::firrtl::RefResolveOp)</h3><p><em>FIRRTL Resolve a Reference</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.resolve` $ref attr-dict `:` qualified(type($ref))
</code></pre><p>Resolve a remote reference for reading a remote value.
It takes a RefType input and returns the corresponding BaseType value.
If an XMR is emitted for this reference, it will be at the location
of this operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-81>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ref</code></td><td>reference type</td></tr></tbody></table><h4 id=results-74>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlrefsend-circtfirrtlrefsendop><code>firrtl.ref.send</code> (::circt::firrtl::RefSendOp)</h3><p><em>FIRRTL Send through Reference</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.send` $base attr-dict `:` qualified(type($base))
</code></pre><p>Endpoint of a remote reference. Send a value through a reference
to be read from the firrtl.ref.resolve op.
It takes a BaseType input and returns the corresponding RefType value.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-82>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base</code></td><td>a base type</td></tr></tbody></table><h4 id=results-75>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>reference type</td></tr></tbody></table><h3 id=firrtlrefsub-circtfirrtlrefsubop><code>firrtl.ref.sub</code> (::circt::firrtl::RefSubOp)</h3><p><em>Extract an element of an aggregate RefType value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.ref.sub` $input `[` $index `]` attr-dict `:` qualified(type($input))
</code></pre><p>The refsub expression statically refers, by index, to a sub-element
of an expression with a RefType. The index must be a non-negative
integer and cannot be equal to or exceed the underlying vector size
or number of elements in bundle.</p><pre tabindex=0><code>  %result = firrtl.ref.sub %input[index] : t1
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-44>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-83>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>reference type</td></tr></tbody></table><h4 id=results-76>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>reference type</td></tr></tbody></table><h3 id=firrtlrem-circtfirrtlremprimop><code>firrtl.rem</code> (::circt::firrtl::RemPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.rem` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsIntTypeKind</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-84>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-77>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlshl-circtfirrtlshlprimop><code>firrtl.shl</code> (::circt::firrtl::ShlPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.shl` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>shl</code> operation concatenates <code>amount</code> zero bits to the least significant
end of <code>input</code>. <code>amount</code> must be non-negative.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-45>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>amount</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-85>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-78>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlshr-circtfirrtlshrprimop><code>firrtl.shr</code> (::circt::firrtl::ShrPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.shr` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>shr</code> operation truncates least significant <code>amount</code> bits from <code>input</code>.
If <code>amount</code> is greater than of equal to <code>width(input)</code>, the value will be
zero for unsigned types and the sign bit for signed types. <code>amount</code> must be
non-negative.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-46>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>amount</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-86>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-79>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlintsizeof-circtfirrtlsizeofintrinsicop><code>firrtl.int.sizeof</code> (::circt::firrtl::SizeOfIntrinsicOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.int.sizeof` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-87>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a base type</td></tr></tbody></table><h4 id=results-80>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit uint</td></tr></tbody></table><h3 id=firrtlspecialconstant-circtfirrtlspecialconstantop><code>firrtl.specialconstant</code> (::circt::firrtl::SpecialConstantOp)</h3><p><em>Produce a constant Reset or Clock value</em></p><p>The constant operation produces a constant value of Reset, AsyncReset, or
Clock type. The value can only be 0 or 1.</p><pre tabindex=0><code>  %result = firrtl.specialconstant 1 : !firrtl.clock
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-47>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=results-81>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>clock or reset type or async reset type</td></tr></tbody></table><h3 id=firrtlstring-circtfirrtlstringconstantop><code>firrtl.string</code> (::circt::firrtl::StringConstantOp)</h3><p><em>Produce a constant string value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.string` $value attr-dict
</code></pre><p>Produces a constant value of string type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>string <span class=s>&#34;hello world&#34;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-48>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-82>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>string type</td></tr></tbody></table><h3 id=firrtlsub-circtfirrtlsubprimop><code>firrtl.sub</code> (::circt::firrtl::SubPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.sub` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsIntTypeKind</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-88>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-83>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlsubaccess-circtfirrtlsubaccessop><code>firrtl.subaccess</code> (::circt::firrtl::SubaccessOp)</h3><p><em>Extract a dynamic element of a vector value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.subaccess` $input `[` $index `]` attr-dict `:` qualified(type($input)) `,` qualified(type($index))
</code></pre><p>The subaccess expression dynamically refers to a subelement of a
vector-typed expression using a calculated index. The index must be an
expression with an unsigned integer type.</p><pre tabindex=0><code>  %result = firrtl.subaccess %input[%idx] : t1, t2
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-89>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>vector type</td></tr><tr><td style=text-align:center><code>index</code></td><td>uint type</td></tr></tbody></table><h4 id=results-84>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlsubfield-circtfirrtlsubfieldop><code>firrtl.subfield</code> (::circt::firrtl::SubfieldOp)</h3><p><em>Extract a subfield of another value</em></p><p>The subfield expression refers to a subelement of an expression with a
bundle type.</p><pre tabindex=0><code>  %result = firrtl.subfield %input[field-name] : !input-type
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-49>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fieldIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-90>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>bundle type</td></tr></tbody></table><h4 id=results-85>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlsubindex-circtfirrtlsubindexop><code>firrtl.subindex</code> (::circt::firrtl::SubindexOp)</h3><p><em>Extract an element of a vector value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.subindex` $input `[` $index `]` attr-dict `:` qualified(type($input))
</code></pre><p>The subindex expression statically refers, by index, to a subelement
of an expression with a vector type. The index must be a non-negative
integer and cannot be equal to or exceed the length of the vector it
indexes.</p><pre tabindex=0><code>  %result = firrtl.subindex %input[index] : t1
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-50>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-91>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>vector type</td></tr></tbody></table><h4 id=results-86>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlsubtag-circtfirrtlsubtagop><code>firrtl.subtag</code> (::circt::firrtl::SubtagOp)</h3><p><em>Extract an element of a enum value</em></p><p>The subtag expression refers to a subelement of a
enum-typed expression.</p><pre tabindex=0><code>  %result = firrtl.subtag %input[field-name] : !input-type
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-51>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fieldIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-92>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>enum type</td></tr></tbody></table><h4 id=results-87>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtltagextract-circtfirrtltagextractop><code>firrtl.tagextract</code> (::circt::firrtl::TagExtractOp)</h3><p><em>Extract the tag from a value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.tagextract` $input attr-dict `:` qualified(type($input))
</code></pre><p>The tagextract expression returns the binary value of the current tag of an
enum value.</p><pre tabindex=0><code>  %result = firrtl.tagextract %input : !input-type
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-93>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>enum type</td></tr></tbody></table><h4 id=results-88>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtltail-circtfirrtltailprimop><code>firrtl.tail</code> (::circt::firrtl::TailPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.tail` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>tail</code> operation truncates the <code>amount</code> most significant bits from
<code>input</code>. <code>amount</code> must be non-negative and less than or equal to the bit
width of e. The result is <code>width(input)-amount</code> bits wide.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-52>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>amount</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-94>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-89>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlresetcast-circtfirrtluninferredresetcastop><code>firrtl.resetCast</code> (::circt::firrtl::UninferredResetCastOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.resetCast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Cast between reset types. This is used to enable strictconnects early in
the pipeline by isolating all uninferred reset connections to a single op.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-95>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>Reset</td></tr></tbody></table><h4 id=results-90>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Reset</td></tr></tbody></table><h3 id=firrtlunresolved_path-circtfirrtlunresolvedpathop><code>firrtl.unresolved_path</code> (::circt::firrtl::UnresolvedPathOp)</h3><p><em>Produce a path value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.unresolved_path` $target attr-dict
</code></pre><p>Produces a value which represents a path to the target in a design.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nl>0 =</span> firrtl<span class=p>.</span>unresolved_path <span class=s>&#34;~Circuit|Module&gt;w&#34;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-53>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>target</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-91>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>path type</td></tr></tbody></table><h3 id=firrtlvectorcreate-circtfirrtlvectorcreateop><code>firrtl.vectorcreate</code> (::circt::firrtl::VectorCreateOp)</h3><p><em>Produce a vector value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.vectorcreate` $fields attr-dict `:` functional-type($fields, $result)
</code></pre><p>Create a vector from component values. This is equivalent in terms of
flow to creating a node. The first operand indicates 0-th element of
the result.</p><pre tabindex=0><code>  %result = firrtl.vectorcreate %1, %2, %3 : !firrtl.vector&lt;uint&lt;8&gt;, 3&gt;
</code></pre><h4 id=operands-96>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fields</code></td><td>variadic of a base type</td></tr></tbody></table><h4 id=results-92>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector type</td></tr></tbody></table><h3 id=firrtlverbatimexpr-circtfirrtlverbatimexprop><code>firrtl.verbatim.expr</code> (::circt::firrtl::VerbatimExprOp)</h3><p><em>Expression that expands to a value given SystemVerilog text</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.verbatim.expr` $text (`(` $substitutions^ `)`)?
              `:` functional-type($substitutions, $result) attr-dict
</code></pre><p>This operation produces a typed value expressed by a string of
SystemVerilog. This can be used to access macros and other values that are
only sensible as Verilog text.</p><p>The text string is expected to have the highest precedence, so you should
include parentheses in the string if it isn&rsquo;t a single token. This is also
assumed to not have side effects (use <code>sv.verbatim</code> if you need them).</p><p><code>firrtl.verbatim.expr</code> allows operand substitutions with <code>{{0}}</code> syntax.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-54>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>text</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>symbols</code></td><td>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></table><h4 id=operands-97>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-93>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlverbatimwire-circtfirrtlverbatimwireop><code>firrtl.verbatim.wire</code> (::circt::firrtl::VerbatimWireOp)</h3><p><em>Expression with wire semantics that expands to a value given SystemVerilog text</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.verbatim.wire` $text (`(` $substitutions^ `)`)?
              `:` functional-type($substitutions, $result) attr-dict
</code></pre><p>This operation produces a typed value with wire semantics, expressed by a
string of SystemVerilog. This can be used to access macros and other values
that are only sensible as Verilog text.</p><p>The text string is expected to have the highest precedence, so you should
include parentheses in the string if it isn&rsquo;t a single token. This is also
assumed to not have side effects (use <code>sv.verbatim</code> if you need them).</p><p><code>firrtl.verbatim.wire</code> allows operand substitutions with <code>{{0}}</code> syntax.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-55>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>text</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>symbols</code></td><td>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></table><h4 id=operands-98>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-94>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a base type</td></tr></tbody></table><h3 id=firrtlxmrderef-circtfirrtlxmrderefop><code>firrtl.xmr.deref</code> (::circt::firrtl::XMRDerefOp)</h3><p><em>FIRRTL XMR operation, reading an XMR target.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.xmr.deref` $ref (`,` $verbatimSuffix^)? attr-dict `:` qualified(type($dest))
</code></pre><h4 id=attributes-56>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>ref</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>verbatimSuffix</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-95>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>a passive base type (contain no flips)</td></tr></tbody></table><h3 id=firrtlxmrref-circtfirrtlxmrrefop><code>firrtl.xmr.ref</code> (::circt::firrtl::XMRRefOp)</h3><p><em>FIRRTL XMR operation, targetable by ref ops.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.xmr.ref` $ref (`,` $verbatimSuffix^)? attr-dict `:` qualified(type($dest))
</code></pre><h4 id=attributes-57>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>ref</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>verbatimSuffix</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-96>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>reference type</td></tr></tbody></table><h3 id=firrtlxor-circtfirrtlxorprimop><code>firrtl.xor</code> (::circt::firrtl::XorPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.xor` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsIntTypeKind</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-99>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-97>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlxorr-circtfirrtlxorrprimop><code>firrtl.xorr</code> (::circt::firrtl::XorRPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.xorr` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Horizontally reduce a value to one bit, using the &lsquo;xor&rsquo; operation to merge
bits. <code>xorr(x)</code> is equivalent to <code>popcount(concat(x, 1b0)) & 1</code>. As
such, it returns 0 for zero-bit-wide operands.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-100>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-98>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit uint</td></tr></tbody></table><h2 id=type-definitions>Type Definitions</h2><h3 id=analogtype>AnalogType</h3><p>Analog signal</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>widthOrSentinel</td><td style=text-align:center><code>int32_t</code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=anyreftype>AnyRefType</h3><p>A reference to an instance of any class.</p><p>A reference of type AnyRef can be used in ports, property assignments, and
any other Property &ldquo;plumbing&rdquo; ops. But it is opaque, and references to
objects of AnyRef type cannot be &ldquo;dereferenced&rdquo;. There is no information
about the referred to object&rsquo;s fields, so subfield access, etc. is illegal.</p><h3 id=asyncresettype>AsyncResetType</h3><p>AsyncReset signal</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=basetypealiastype>BaseTypeAliasType</h3><p>type alias for firrtl base types</p><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>StringAttr</code></td><td></td></tr><tr><td style=text-align:center>innerType</td><td style=text-align:center><code>::circt::firrtl::FIRRTLBaseType</code></td><td>An inner type</td></tr></tbody></table><h3 id=booltype>BoolType</h3><p>A boolean property. Not representable in hardware.</p><h3 id=bundletype>BundleType</h3><p>an aggregate of named elements. This is effectively a struct.</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elements</td><td style=text-align:center><code>ArrayRef&lt;BundleElement></code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=classtype>ClassType</h3><pre><code>An instance of a class.

Example:
```mlir
!firrtl.class&lt;@Module(in p0: !firrtl.uint&lt;8&gt;, out p1: !firrtl.uint&lt;8&gt;)&gt;
```
</code></pre><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>FlatSymbolRefAttr</code></td><td></td></tr><tr><td style=text-align:center>elements</td><td style=text-align:center><code>::llvm::ArrayRef&lt;ClassElement></code></td><td></td></tr></tbody></table><h3 id=clocktype>ClockType</h3><p>Clock signal</p><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=doubletype>DoubleType</h3><p>A double property. Not representable in hardware.</p><h3 id=fenumtype>FEnumType</h3><p>a sum type of named elements.</p><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elements</td><td style=text-align:center><code>ArrayRef&lt;EnumElement></code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=fvectortype>FVectorType</h3><p>a fixed size collection of elements, like an array.</p><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>::circt::firrtl::FIRRTLBaseType</code></td><td>Type of vector elements</td></tr><tr><td style=text-align:center>numElements</td><td style=text-align:center><code>size_t</code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=fintegertype>FIntegerType</h3><p>An unlimited length signed integer type. Not representable in hardware.</p><h3 id=listtype>ListType</h3><p>A typed property list of any length. Not representable in hardware.</p><h4 id=parameters-8>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>circt::firrtl::PropertyType</code></td><td>element type</td></tr></tbody></table><h3 id=openbundletype>OpenBundleType</h3><p>an aggregate of named elements. This is effectively a struct.</p><h4 id=parameters-9>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elements</td><td style=text-align:center><code>ArrayRef&lt;BundleElement></code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=openvectortype>OpenVectorType</h3><p>a fixed size collection of elements, like an array.</p><h4 id=parameters-10>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>::circt::firrtl::FIRRTLType</code></td><td>Type of vector elements</td></tr><tr><td style=text-align:center>numElements</td><td style=text-align:center><code>size_t</code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=pathtype>PathType</h3><p>A path to a hardware entity. Not representable in hardware.</p><h3 id=reftype>RefType</h3><p>A reference to a signal elsewhere.</p><p>A reference type, such as <code>firrtl.probe&lt;uint&lt;1>></code> or <code>firrtl.rwprobe&lt;uint&lt;2>></code>.</p><p>Used for remote reads and writes of the wrapped base type.</p><p>Parameterized over the referenced base type, with flips removed.</p><p>Not a base type.</p><p>Values of this type are used to capture dataflow paths,
and do not represent a circuit element or entity.</p><p>Generally read-only (probe), optionally forceable (rwprobe).</p><h4 id=parameters-11>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>type</td><td style=text-align:center><code>::circt::firrtl::FIRRTLBaseType</code></td><td>Type of reference target</td></tr><tr><td style=text-align:center>forceable</td><td style=text-align:center><code>bool</code></td><td></td></tr><tr><td style=text-align:center>layer</td><td style=text-align:center><code>::mlir::SymbolRefAttr</code></td><td></td></tr></tbody></table><h3 id=resettype>ResetType</h3><p>Reset Signal</p><h4 id=parameters-12>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=sinttype>SIntType</h3><p>A signed integer type, whose width may not be known.</p><h4 id=parameters-13>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>widthOrSentinel</td><td style=text-align:center><code>int32_t</code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=stringtype>StringType</h3><p>An unlimited length string type. Not representable in hardware.</p><h3 id=uinttype>UIntType</h3><p>An unsigned integer type, whose width may not be known.</p><h4 id=parameters-14>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>widthOrSentinel</td><td style=text-align:center><code>int32_t</code></td><td></td></tr><tr><td style=text-align:center>isConst</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h2 id=attribute-definitions>Attribute Definitions</h2><h3 id=augmentedbooleantypeattr>AugmentedBooleanTypeAttr</h3><p>GrandCentral AugmentedBooleanType</p><p>Syntax:</p><pre tabindex=0><code>#firrtl.augmentedBoolean&lt;
  DictionaryAttr   # underlying
&gt;
</code></pre><p>Used in the GrandCentralPass.</p><h4 id=parameters-15>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedbundletypeattr>AugmentedBundleTypeAttr</h3><p>GrandCentral AugmentedBundleType</p><p>Syntax:</p><pre tabindex=0><code>#firrtl.augmentedBundle&lt;
  DictionaryAttr   # underlying
&gt;
</code></pre><p>Used in the GrandCentralPass.</p><h4 id=parameters-16>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmenteddeletedtypeattr>AugmentedDeletedTypeAttr</h3><p>GrandCentral AugmentedDeletedType</p><p>Syntax:</p><pre tabindex=0><code>#firrtl.augmentedDeleted&lt;
  DictionaryAttr   # underlying
&gt;
</code></pre><p>Used in the GrandCentralPass.</p><h4 id=parameters-17>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmenteddoubletypeattr>AugmentedDoubleTypeAttr</h3><p>GrandCentral AugmentedDoubleType</p><p>Syntax:</p><pre tabindex=0><code>#firrtl.augmentedDouble&lt;
  DictionaryAttr   # underlying
&gt;
</code></pre><p>Used in the GrandCentralPass.</p><h4 id=parameters-18>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedgroundtypeattr>AugmentedGroundTypeAttr</h3><p>GrandCentral AugmentedGroundType</p><p>Syntax:</p><pre tabindex=0><code>#firrtl.augmentedGround&lt;
  DictionaryAttr   # underlying
&gt;
</code></pre><p>Used in the GrandCentralPass.</p><h4 id=parameters-19>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedintegertypeattr>AugmentedIntegerTypeAttr</h3><p>GrandCentral AugmentedIntegerType</p><p>Syntax:</p><pre tabindex=0><code>#firrtl.augmentedInteger&lt;
  DictionaryAttr   # underlying
&gt;
</code></pre><p>Used in the GrandCentralPass.</p><h4 id=parameters-20>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedliteraltypeattr>AugmentedLiteralTypeAttr</h3><p>GrandCentral AugmentedLiteralType</p><p>Syntax:</p><pre tabindex=0><code>#firrtl.augmentedLiteral&lt;
  DictionaryAttr   # underlying
&gt;
</code></pre><p>Used in the GrandCentralPass.</p><h4 id=parameters-21>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedstringtypeattr>AugmentedStringTypeAttr</h3><p>GrandCentral AugmentedStringType</p><p>Syntax:</p><pre tabindex=0><code>#firrtl.augmentedString&lt;
  DictionaryAttr   # underlying
&gt;
</code></pre><p>Used in the GrandCentralPass.</p><h4 id=parameters-22>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedvectortypeattr>AugmentedVectorTypeAttr</h3><p>GrandCentral AugmentedVectorType</p><p>Syntax:</p><pre tabindex=0><code>#firrtl.augmentedVector&lt;
  DictionaryAttr   # underlying
&gt;
</code></pre><p>Used in the GrandCentralPass.</p><h4 id=parameters-23>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=internalpathattr>InternalPathAttr</h3><p>Internal path for ref-type ports</p><p>Syntax:</p><pre tabindex=0><code>#firrtl.internalpath&lt;
  ::mlir::StringAttr   # path
&gt;
</code></pre><h4 id=parameters-24>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>path</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr></tbody></table><h3 id=memoryinitattr>MemoryInitAttr</h3><p>Information about the initial state of a memory</p><p>Syntax:</p><pre tabindex=0><code>#firrtl.meminit&lt;
  ::mlir::StringAttr,   # filename
  bool,   # isBinary
  bool   # isInline
&gt;
</code></pre><p>This attribute captures information about the external initialization of a
memory. This is the FIRRTL Dialect representation of both
&ldquo;firrtl.annotations.LoadMemoryFromFile&rdquo; and
&ldquo;firrtl.annotations.MemoryFileInlineAnnotation&rdquo;.</p><h4 id=parameters-25>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>filename</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>isBinary</td><td style=text-align:center><code>bool</code></td><td></td></tr><tr><td style=text-align:center>isInline</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h3 id=paramdeclattr>ParamDeclAttr</h3><p>Module or instance parameter definition</p><p>An attribute describing a module parameter, or instance parameter
specification.</p><h4 id=parameters-26>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h2 id=classlike-classlike>ClassLike (<code>ClassLike</code>)</h2><p>Provide common class information.</p><h3 id=methods>Methods:</h3><h4 id=getinstancetype><code>getInstanceType</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ClassType</span> <span class=nf>getInstanceType</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the type for instances of this class
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=verifytype><code>verifyType</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>LogicalResult</span> <span class=nf>verifyType</span><span class=p>(</span><span class=o>::</span><span class=n>circt</span><span class=o>::</span><span class=n>firrtl</span><span class=o>::</span><span class=n>ClassType</span> <span class=n>type</span><span class=p>,</span> <span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>function_ref</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>InFlightDiagnostic</span><span class=p>()</span><span class=o>&gt;</span> <span class=n>emitError</span><span class=p>);</span>
</span></span></code></pre></div><p>Verify that the given type agrees with this class
NOTE: This method <em>must</em> be implemented by the user.</p><h2 id=fconnectlike-fconnectlike>FConnectLike (<code>FConnectLike</code>)</h2><p>Provide common connection information.</p><h3 id=methods-1>Methods:</h3><h4 id=getdest><code>getDest</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Value</span> <span class=nf>getDest</span><span class=p>();</span>
</span></span></code></pre></div><p>Return a destination of connection.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getsrc><code>getSrc</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Value</span> <span class=nf>getSrc</span><span class=p>();</span>
</span></span></code></pre></div><p>Return a source of connection.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getconnectbehaviorkind><code>getConnectBehaviorKind</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>static</span> <span class=n>ConnectBehaviorKind</span> <span class=nf>getConnectBehaviorKind</span><span class=p>();</span>
</span></span></code></pre></div><p>Return connection behavior kind.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=hasstaticsingleconnectbehavior><code>hasStaticSingleConnectBehavior</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=nf>hasStaticSingleConnectBehavior</span><span class=p>();</span>
</span></span></code></pre></div><p>Returns true if ConnectBehavior is StaticSingleConnect.</p><h4 id=haslastconnectbehavior><code>hasLastConnectBehavior</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=nf>hasLastConnectBehavior</span><span class=p>();</span>
</span></span></code></pre></div><p>Returns true if ConnectBehavior is LastConnect.</p><h2 id=finstancelike-finstancelike>FInstanceLike (<code>FInstanceLike</code>)</h2><p>Provide common instance information.</p><h3 id=methods-2>Methods:</h3><h4 id=getreferencedmodulename><code>getReferencedModuleName</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>StringRef</span> <span class=n>getReferencedModuleName</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the name of the instantiated module
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getreferencedmodulenameattr><code>getReferencedModuleNameAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>StringAttr</span> <span class=n>getReferencedModuleNameAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the name of the instantiated module
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getreferencedoperation><code>getReferencedOperation</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Operation</span> <span class=o>*</span><span class=n>getReferencedOperation</span><span class=p>(</span><span class=k>const</span> <span class=n>SymbolTable</span><span class=o>&amp;</span><span class=n>symtbl</span><span class=p>);</span>
</span></span></code></pre></div><p>Get the referenced module via a symbol table.
NOTE: This method <em>must</em> be implemented by the user.</p><h2 id=fmodulelike-fmodulelike>FModuleLike (<code>FModuleLike</code>)</h2><p>Provide common module information.</p><h3 id=methods-3>Methods:</h3><h4 id=getparameters><code>getParameters</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>getParameters</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the parameters</p><h4 id=getconventionattr><code>getConventionAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ConventionAttr</span> <span class=nf>getConventionAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the module&rsquo;s instantiation convention
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getconvention><code>getConvention</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Convention</span> <span class=nf>getConvention</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the module&rsquo;s instantiation convention
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getlayersattr><code>getLayersAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>getLayersAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the module&rsquo;s enabled layers
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getlayers><code>getLayers</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>getLayers</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the module&rsquo;s enabled layers.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportdirectionsattr><code>getPortDirectionsAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>mlir</span><span class=o>::</span><span class=n>DenseBoolArrayAttr</span> <span class=n>getPortDirectionsAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port directions attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportdirections><code>getPortDirections</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>getPortDirections</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port directions
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportdirection><code>getPortDirection</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Direction</span> <span class=nf>getPortDirection</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port direction
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportnamesattr><code>getPortNamesAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>getPortNamesAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port names attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportnames><code>getPortNames</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>getPortNames</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port names
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportnameattr><code>getPortNameAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>StringAttr</span> <span class=nf>getPortNameAttr</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port name
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportname><code>getPortName</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>StringRef</span> <span class=nf>getPortName</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port name
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getporttypesattr><code>getPortTypesAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>getPortTypesAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port types attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getporttypes><code>getPortTypes</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>getPortTypes</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port types
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getporttypeattr><code>getPortTypeAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>TypeAttr</span> <span class=nf>getPortTypeAttr</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port type
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getporttype><code>getPortType</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Type</span> <span class=nf>getPortType</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port type
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportannotationsattr><code>getPortAnnotationsAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>getPortAnnotationsAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port annotations attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportannotations><code>getPortAnnotations</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>getPortAnnotations</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port annotations attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getannotationsattrforport><code>getAnnotationsAttrForPort</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>getAnnotationsAttrForPort</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port&rsquo;s annotations attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getannotationsforport><code>getAnnotationsForPort</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>getAnnotationsForPort</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port&rsquo;s annotations
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportsymbolsattr><code>getPortSymbolsAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>getPortSymbolsAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port symbols attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportsymbols><code>getPortSymbols</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>getPortSymbols</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port symbols
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=hasportsymbolattr><code>hasPortSymbolAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>hasPortSymbolAttr</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Check if port has symbol attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportsymbolattr><code>getPortSymbolAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>InnerSymAttr</span> <span class=n>getPortSymbolAttr</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get the port symbol attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=setportsymbols><code>setPortSymbols</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setPortSymbols</span><span class=p>(</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>symbols</span><span class=p>);</span>
</span></span></code></pre></div><p>Set the symbols of all ports and their fields
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=setportsymbolattr><code>setPortSymbolAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setPortSymbolAttr</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>,</span> <span class=n>StringAttr</span> <span class=n>symbol</span><span class=p>);</span>
</span></span></code></pre></div><p>Set a port&rsquo;s top-level symbol to the specified string, dropping any symbols on its fields
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=setportsymbolsattr><code>setPortSymbolsAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setPortSymbolsAttr</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>,</span> <span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>InnerSymAttr</span> <span class=n>symbol</span><span class=p>);</span>
</span></span></code></pre></div><p>Set the symbols for a port including its fields
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=setportsymbol><code>setPortSymbol</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setPortSymbol</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>,</span> <span class=n>StringRef</span> <span class=n>symbol</span><span class=p>);</span>
</span></span></code></pre></div><p>Set a port&rsquo;s top-level symbol to the specified string, dropping any symbols on its fields
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportlocationsattr><code>getPortLocationsAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>getPortLocationsAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port locations attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportlocations><code>getPortLocations</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>getPortLocations</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port locations attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportlocationattr><code>getPortLocationAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>LocationAttr</span> <span class=nf>getPortLocationAttr</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port&rsquo;s location attribute
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportlocation><code>getPortLocation</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Location</span> <span class=nf>getPortLocation</span><span class=p>(</span><span class=n>size_t</span> <span class=n>portIndex</span><span class=p>);</span>
</span></span></code></pre></div><p>Get a port&rsquo;s location
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getports><code>getPorts</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>SmallVector</span><span class=o>&lt;</span><span class=n>PortInfo</span><span class=o>&gt;</span> <span class=n>getPorts</span><span class=p>();</span>
</span></span></code></pre></div><p>Get information about all ports
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=insertports><code>insertPorts</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>insertPorts</span><span class=p>(</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>unsigned</span><span class=p>,</span> <span class=n>PortInfo</span><span class=o>&gt;&gt;</span> <span class=n>ports</span><span class=p>);</span>
</span></span></code></pre></div><p>Inserts the given ports at the corresponding indices
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=eraseports><code>erasePorts</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>erasePorts</span><span class=p>(</span><span class=k>const</span> <span class=n>llvm</span><span class=o>::</span><span class=n>BitVector</span><span class=o>&amp;</span><span class=n>portIndices</span><span class=p>);</span>
</span></span></code></pre></div><p>Erases the ports that have their corresponding bit set in <code>portIndices</code>
NOTE: This method <em>must</em> be implemented by the user.</p><h2 id=fnamableop-fnamableop>FNamableOp (<code>FNamableOp</code>)</h2><p>The interface provides common methods for namable operations
related to name preservation semantics.</p><h3 id=methods-4>Methods:</h3><h4 id=hasdroppablename><code>hasDroppableName</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>hasDroppableName</span><span class=p>();</span>
</span></span></code></pre></div><p>Return true if the name is droppable.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=dropname><code>dropName</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>dropName</span><span class=p>();</span>
</span></span></code></pre></div><p>Completely drop a name.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=setnamekindattr><code>setNameKindAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setNameKindAttr</span><span class=p>(</span><span class=n>firrtl</span><span class=o>::</span><span class=n>NameKindEnumAttr</span> <span class=n>nameKind</span><span class=p>);</span>
</span></span></code></pre></div><p>Set a namekind.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getnameattr><code>getNameAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>mlir</span><span class=o>::</span><span class=n>StringAttr</span> <span class=n>getNameAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Return the name.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getname><code>getName</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>llvm</span><span class=o>::</span><span class=n>StringRef</span> <span class=n>getName</span><span class=p>();</span>
</span></span></code></pre></div><p>Return the name.
NOTE: This method <em>must</em> be implemented by the user.</p><h2 id=forceable-forceable>Forceable (<code>Forceable</code>)</h2><p>Interaction with declarations of forceable hardware components,
and managing references to them.</p><h3 id=methods-5>Methods:</h3><h4 id=isforceable><code>isForceable</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>isForceable</span><span class=p>();</span>
</span></span></code></pre></div><p>Return true if the operation is forceable.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getdata><code>getData</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>mlir</span><span class=o>::</span><span class=n>TypedValue</span><span class=o>&lt;</span><span class=n>FIRRTLBaseType</span><span class=o>&gt;</span> <span class=n>getData</span><span class=p>();</span>
</span></span></code></pre></div><p>Return data value that will be targeted.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getdataraw><code>getDataRaw</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Value</span> <span class=nf>getDataRaw</span><span class=p>();</span>
</span></span></code></pre></div><p>Return raw data value that will be targeted.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getdatatype><code>getDataType</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>FIRRTLBaseType</span> <span class=nf>getDataType</span><span class=p>();</span>
</span></span></code></pre></div><p>Return data type that will be referenced.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getdataref><code>getDataRef</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>mlir</span><span class=o>::</span><span class=n>TypedValue</span><span class=o>&lt;</span><span class=n>RefType</span><span class=o>&gt;</span> <span class=n>getDataRef</span><span class=p>();</span>
</span></span></code></pre></div><p>Return reference result, or null if not active.
NOTE: This method <em>must</em> be implemented by the user.</p><h2>'firrtl' Dialect Docs</h2><ul><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/ title="The Elastic Silicon Interconnect dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - The Elastic Silicon Interconnect dialect</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/ title="FIRRTL Annotations">Next - FIRRTL Annotations <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class="active has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>