<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'firrtl' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/FIRRTL/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'firrtl' Dialect</h1><p>Types and operations for firrtl dialect
This dialect defines the <code>firrtl</code> dialect, which is used to lower from
Chisel code to Verilog. For more information, see the
<a href=https://github.com/freechipsproject/firrtl>FIRRTL GitHub page</a>.</p><p><nav id=TableOfContents><ul><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#firrtladd-circtfirrtladdprimop><code>firrtl.add</code> (::circt::firrtl::AddPrimOp)</a></li><li><a href=#firrtland-circtfirrtlandprimop><code>firrtl.and</code> (::circt::firrtl::AndPrimOp)</a></li><li><a href=#firrtlandr-circtfirrtlandrprimop><code>firrtl.andr</code> (::circt::firrtl::AndRPrimOp)</a></li><li><a href=#firrtlasasyncreset-circtfirrtlasasyncresetprimop><code>firrtl.asAsyncReset</code> (::circt::firrtl::AsAsyncResetPrimOp)</a></li><li><a href=#firrtlasclock-circtfirrtlasclockprimop><code>firrtl.asClock</code> (::circt::firrtl::AsClockPrimOp)</a></li><li><a href=#firrtlassint-circtfirrtlassintprimop><code>firrtl.asSInt</code> (::circt::firrtl::AsSIntPrimOp)</a></li><li><a href=#firrtlasuint-circtfirrtlasuintprimop><code>firrtl.asUInt</code> (::circt::firrtl::AsUIntPrimOp)</a></li><li><a href=#firrtlassert-circtfirrtlassertop><code>firrtl.assert</code> (::circt::firrtl::AssertOp)</a></li><li><a href=#firrtlassume-circtfirrtlassumeop><code>firrtl.assume</code> (::circt::firrtl::AssumeOp)</a></li><li><a href=#firrtlattach-circtfirrtlattachop><code>firrtl.attach</code> (::circt::firrtl::AttachOp)</a></li><li><a href=#firrtlbitcast-circtfirrtlbitcastop><code>firrtl.bitcast</code> (::circt::firrtl::BitCastOp)</a></li><li><a href=#firrtlbits-circtfirrtlbitsprimop><code>firrtl.bits</code> (::circt::firrtl::BitsPrimOp)</a></li><li><a href=#firrtlcat-circtfirrtlcatprimop><code>firrtl.cat</code> (::circt::firrtl::CatPrimOp)</a></li><li><a href=#firrtlcircuit-circtfirrtlcircuitop><code>firrtl.circuit</code> (::circt::firrtl::CircuitOp)</a></li><li><a href=#firrtlconnect-circtfirrtlconnectop><code>firrtl.connect</code> (::circt::firrtl::ConnectOp)</a></li><li><a href=#firrtlconstant-circtfirrtlconstantop><code>firrtl.constant</code> (::circt::firrtl::ConstantOp)</a></li><li><a href=#firrtlcover-circtfirrtlcoverop><code>firrtl.cover</code> (::circt::firrtl::CoverOp)</a></li><li><a href=#firrtlcvt-circtfirrtlcvtprimop><code>firrtl.cvt</code> (::circt::firrtl::CvtPrimOp)</a></li><li><a href=#firrtldshl-circtfirrtldshlprimop><code>firrtl.dshl</code> (::circt::firrtl::DShlPrimOp)</a></li><li><a href=#firrtldshlw-circtfirrtldshlwprimop><code>firrtl.dshlw</code> (::circt::firrtl::DShlwPrimOp)</a></li><li><a href=#firrtldshr-circtfirrtldshrprimop><code>firrtl.dshr</code> (::circt::firrtl::DShrPrimOp)</a></li><li><a href=#firrtldiv-circtfirrtldivprimop><code>firrtl.div</code> (::circt::firrtl::DivPrimOp)</a></li><li><a href=#firrtleq-circtfirrtleqprimop><code>firrtl.eq</code> (::circt::firrtl::EQPrimOp)</a></li><li><a href=#firrtlextmodule-circtfirrtlfextmoduleop><code>firrtl.extmodule</code> (::circt::firrtl::FExtModuleOp)</a></li><li><a href=#firrtlmemmodule-circtfirrtlfmemmoduleop><code>firrtl.memmodule</code> (::circt::firrtl::FMemModuleOp)</a></li><li><a href=#firrtlmodule-circtfirrtlfmoduleop><code>firrtl.module</code> (::circt::firrtl::FModuleOp)</a></li><li><a href=#firrtlforce-circtfirrtlforceop><code>firrtl.force</code> (::circt::firrtl::ForceOp)</a></li><li><a href=#firrtlgeq-circtfirrtlgeqprimop><code>firrtl.geq</code> (::circt::firrtl::GEQPrimOp)</a></li><li><a href=#firrtlgt-circtfirrtlgtprimop><code>firrtl.gt</code> (::circt::firrtl::GTPrimOp)</a></li><li><a href=#firrtlhwstructcast-circtfirrtlhwstructcastop><code>firrtl.hwStructCast</code> (::circt::firrtl::HWStructCastOp)</a></li><li><a href=#firrtlhead-circtfirrtlheadprimop><code>firrtl.head</code> (::circt::firrtl::HeadPrimOp)</a></li><li><a href=#firrtlhierpath-circtfirrtlhierpathop><code>firrtl.hierpath</code> (::circt::firrtl::HierPathOp)</a></li><li><a href=#firrtlinstance-circtfirrtlinstanceop><code>firrtl.instance</code> (::circt::firrtl::InstanceOp)</a></li><li><a href=#firrtlinvalidvalue-circtfirrtlinvalidvalueop><code>firrtl.invalidvalue</code> (::circt::firrtl::InvalidValueOp)</a></li><li><a href=#firrtlleq-circtfirrtlleqprimop><code>firrtl.leq</code> (::circt::firrtl::LEQPrimOp)</a></li><li><a href=#firrtllt-circtfirrtlltprimop><code>firrtl.lt</code> (::circt::firrtl::LTPrimOp)</a></li><li><a href=#firrtlmem-circtfirrtlmemop><code>firrtl.mem</code> (::circt::firrtl::MemOp)</a></li><li><a href=#firrtlmul-circtfirrtlmulprimop><code>firrtl.mul</code> (::circt::firrtl::MulPrimOp)</a></li><li><a href=#firrtlmultibit_mux-circtfirrtlmultibitmuxop><code>firrtl.multibit_mux</code> (::circt::firrtl::MultibitMuxOp)</a></li><li><a href=#firrtlmux-circtfirrtlmuxprimop><code>firrtl.mux</code> (::circt::firrtl::MuxPrimOp)</a></li><li><a href=#firrtlneq-circtfirrtlneqprimop><code>firrtl.neq</code> (::circt::firrtl::NEQPrimOp)</a></li><li><a href=#firrtlneg-circtfirrtlnegprimop><code>firrtl.neg</code> (::circt::firrtl::NegPrimOp)</a></li><li><a href=#firrtlnode-circtfirrtlnodeop><code>firrtl.node</code> (::circt::firrtl::NodeOp)</a></li><li><a href=#firrtlnot-circtfirrtlnotprimop><code>firrtl.not</code> (::circt::firrtl::NotPrimOp)</a></li><li><a href=#firrtlor-circtfirrtlorprimop><code>firrtl.or</code> (::circt::firrtl::OrPrimOp)</a></li><li><a href=#firrtlorr-circtfirrtlorrprimop><code>firrtl.orr</code> (::circt::firrtl::OrRPrimOp)</a></li><li><a href=#firrtlpad-circtfirrtlpadprimop><code>firrtl.pad</code> (::circt::firrtl::PadPrimOp)</a></li><li><a href=#firrtlprintf-circtfirrtlprintfop><code>firrtl.printf</code> (::circt::firrtl::PrintFOp)</a></li><li><a href=#firrtlprobe-circtfirrtlprobeop><code>firrtl.probe</code> (::circt::firrtl::ProbeOp)</a></li><li><a href=#firrtlreg-circtfirrtlregop><code>firrtl.reg</code> (::circt::firrtl::RegOp)</a></li><li><a href=#firrtlregreset-circtfirrtlregresetop><code>firrtl.regreset</code> (::circt::firrtl::RegResetOp)</a></li><li><a href=#firrtlrem-circtfirrtlremprimop><code>firrtl.rem</code> (::circt::firrtl::RemPrimOp)</a></li><li><a href=#firrtlshl-circtfirrtlshlprimop><code>firrtl.shl</code> (::circt::firrtl::ShlPrimOp)</a></li><li><a href=#firrtlshr-circtfirrtlshrprimop><code>firrtl.shr</code> (::circt::firrtl::ShrPrimOp)</a></li><li><a href=#firrtlskip-circtfirrtlskipop><code>firrtl.skip</code> (::circt::firrtl::SkipOp)</a></li><li><a href=#firrtlspecialconstant-circtfirrtlspecialconstantop><code>firrtl.specialconstant</code> (::circt::firrtl::SpecialConstantOp)</a></li><li><a href=#firrtlstop-circtfirrtlstopop><code>firrtl.stop</code> (::circt::firrtl::StopOp)</a></li><li><a href=#firrtlstrictconnect-circtfirrtlstrictconnectop><code>firrtl.strictconnect</code> (::circt::firrtl::StrictConnectOp)</a></li><li><a href=#firrtlsub-circtfirrtlsubprimop><code>firrtl.sub</code> (::circt::firrtl::SubPrimOp)</a></li><li><a href=#firrtlsubaccess-circtfirrtlsubaccessop><code>firrtl.subaccess</code> (::circt::firrtl::SubaccessOp)</a></li><li><a href=#firrtlsubfield-circtfirrtlsubfieldop><code>firrtl.subfield</code> (::circt::firrtl::SubfieldOp)</a></li><li><a href=#firrtlsubindex-circtfirrtlsubindexop><code>firrtl.subindex</code> (::circt::firrtl::SubindexOp)</a></li><li><a href=#firrtltail-circtfirrtltailprimop><code>firrtl.tail</code> (::circt::firrtl::TailPrimOp)</a></li><li><a href=#firrtlverbatimexpr-circtfirrtlverbatimexprop><code>firrtl.verbatim.expr</code> (::circt::firrtl::VerbatimExprOp)</a></li><li><a href=#firrtlverbatimwire-circtfirrtlverbatimwireop><code>firrtl.verbatim.wire</code> (::circt::firrtl::VerbatimWireOp)</a></li><li><a href=#firrtlwhen-circtfirrtlwhenop><code>firrtl.when</code> (::circt::firrtl::WhenOp)</a></li><li><a href=#firrtlwire-circtfirrtlwireop><code>firrtl.wire</code> (::circt::firrtl::WireOp)</a></li><li><a href=#firrtlxor-circtfirrtlxorprimop><code>firrtl.xor</code> (::circt::firrtl::XorPrimOp)</a></li><li><a href=#firrtlxorr-circtfirrtlxorrprimop><code>firrtl.xorr</code> (::circt::firrtl::XorRPrimOp)</a></li></ul></li><li><a href=#attribute-definition>Attribute definition</a><ul><li><a href=#augmentedbooleantypeattr>AugmentedBooleanTypeAttr</a></li><li><a href=#augmentedbundletypeattr>AugmentedBundleTypeAttr</a></li><li><a href=#augmenteddeletedtypeattr>AugmentedDeletedTypeAttr</a></li><li><a href=#augmenteddoubletypeattr>AugmentedDoubleTypeAttr</a></li><li><a href=#augmentedgroundtypeattr>AugmentedGroundTypeAttr</a></li><li><a href=#augmentedintegertypeattr>AugmentedIntegerTypeAttr</a></li><li><a href=#augmentedliteraltypeattr>AugmentedLiteralTypeAttr</a></li><li><a href=#augmentedstringtypeattr>AugmentedStringTypeAttr</a></li><li><a href=#augmentedvectortypeattr>AugmentedVectorTypeAttr</a></li><li><a href=#innersymattr>InnerSymAttr</a></li><li><a href=#innersympropertiesattr>InnerSymPropertiesAttr</a></li><li><a href=#invalidvalueattr>InvalidValueAttr</a></li><li><a href=#namekindenumattr>NameKindEnumAttr</a></li><li><a href=#paramdeclattr>ParamDeclAttr</a></li></ul></li><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#analog-type>analog type</a></li><li><a href=#a-passive-type-that-does-not-contain-analog>a passive type that does not contain analog</a></li><li><a href=#reset>Reset</a></li><li><a href=#asyncreset>AsyncReset</a></li><li><a href=#bundletype>BundleType</a></li><li><a href=#clock>clock</a></li><li><a href=#firrtltype>FIRRTLType</a></li><li><a href=#fvectortype>FVectorType</a></li><li><a href=#sint-or-uint-type>sint or uint type</a></li><li><a href=#uint1-sint1-or-analog1>UInt&lt;1>, SInt&lt;1>, or Analog&lt;1></a></li><li><a href=#a-passive-type-contain-no-flips>a passive type (contain no flips)</a></li><li><a href=#reset-1>Reset</a></li><li><a href=#sint-type>sint type</a></li><li><a href=#a-sized-type-contains-no-unifered-widths>a sized type (contains no unifered widths)</a></li><li><a href=#uint1-or-uint>UInt&lt;1> or UInt</a></li><li><a href=#uint-type>uint type</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition</h2><h3 id=firrtladd-circtfirrtladdprimop><code>firrtl.add</code> (::circt::firrtl::AddPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.add` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: Commutative, SameOperandsIntTypeKind</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtland-circtfirrtlandprimop><code>firrtl.and</code> (::circt::firrtl::AndPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.and` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: Commutative, SameOperandsIntTypeKind</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlandr-circtfirrtlandrprimop><code>firrtl.andr</code> (::circt::firrtl::AndRPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.andr` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Horizontally reduce a value to one bit, using the &lsquo;and&rsquo; operation to merge
bits. <code>andr(x)</code> is equivalent to <code>concat(x, 1b1) == ~0</code>. As such, it
returns 1 for zero-bit-wide operands.</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlasasyncreset-circtfirrtlasasyncresetprimop><code>firrtl.asAsyncReset</code> (::circt::firrtl::AsAsyncResetPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.asAsyncReset` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit uint/sint/analog, reset, asyncreset, or clock</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>AsyncReset</td></tr></tbody></table><h3 id=firrtlasclock-circtfirrtlasclockprimop><code>firrtl.asClock</code> (::circt::firrtl::AsClockPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.asClock` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit uint/sint/analog, reset, asyncreset, or clock</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>clock</td></tr></tbody></table><h3 id=firrtlassint-circtfirrtlassintprimop><code>firrtl.asSInt</code> (::circt::firrtl::AsSIntPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.asSInt` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>FIRRTLType</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint type</td></tr></tbody></table><h3 id=firrtlasuint-circtfirrtlasuintprimop><code>firrtl.asUInt</code> (::circt::firrtl::AsUIntPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.asUInt` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>FIRRTLType</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlassert-circtfirrtlassertop><code>firrtl.assert</code> (::circt::firrtl::AssertOp)</h3><p>Assert Verification Statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.assert` $clock `,` $predicate `,` $enable `,`
              $message (`(` $operands^ `)` `:` qualified(type($operands)))?
              custom&lt;VerifAttrs&gt;(attr-dict)
</code></pre><h4 id=attributes>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>isConcurrent</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>eventControl</code></td><td style=text-align:center>::EventControlAttr</td><td>edge control trigger</td></tr></tbody></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td style=text-align:center><code>enable</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlassume-circtfirrtlassumeop><code>firrtl.assume</code> (::circt::firrtl::AssumeOp)</h3><p>Assume Verification Statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.assume` $clock `,` $predicate `,` $enable `,`
              $message (`(` $operands^ `)` `:` qualified(type($operands)))?
              custom&lt;VerifAttrs&gt;(attr-dict)
</code></pre><h4 id=attributes-1>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>isConcurrent</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>eventControl</code></td><td style=text-align:center>::EventControlAttr</td><td>edge control trigger</td></tr></tbody></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td style=text-align:center><code>enable</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlattach-circtfirrtlattachop><code>firrtl.attach</code> (::circt::firrtl::AttachOp)</h3><p>Analog Attach Statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.attach` $operands attr-dict `:` qualified(type($operands))
</code></pre><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>analog type</td></tr></tbody></table><h3 id=firrtlbitcast-circtfirrtlbitcastop><code>firrtl.bitcast</code> (::circt::firrtl::BitCastOp)</h3><pre><code>Reinterpret one value to another value of the same size and
potentially different type. This op is lowered to hw::BitCastOp.
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.bitcast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>FIRRTLType</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlbits-circtfirrtlbitsprimop><code>firrtl.bits</code> (::circt::firrtl::BitsPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.bits` $input $hi `to` $lo attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>bits</code> operation extracts the bits between <code>hi</code> (inclusive) and <code>lo</code>
(inclusive) from <code>input</code>. <code>hi</code> must be greater than or equal to <code>lo</code>. Both
<code>hi</code> and <code>lo</code> must be non-negative and less than the bit width of <code>input</code>.
The result is <code>hi - lo + 1</code> bits wide.</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-2>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>hi</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>lo</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlcat-circtfirrtlcatprimop><code>firrtl.cat</code> (::circt::firrtl::CatPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.cat` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlcircuit-circtfirrtlcircuitop><code>firrtl.circuit</code> (::circt::firrtl::CircuitOp)</h3><p>FIRRTL Circuit</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.circuit` $name custom&lt;CircuitOpAttrs&gt;(attr-dict) $body
</code></pre><p>The &ldquo;firrtl.circuit&rdquo; operation represents an overall Verilog circuit,
containing a list of modules.</p><p>Traits: InnerRefNamespace, IsolatedFromAbove, NoRegionArguments, NoTerminator, SingleBlock, SymbolTable</p><h4 id=attributes-3>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr></tbody></table><h3 id=firrtlconnect-circtfirrtlconnectop><code>firrtl.connect</code> (::circt::firrtl::ConnectOp)</h3><p>Connect two signals</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.connect` $dest `,` $src  attr-dict `:` qualified(type($dest)) `,` qualified(type($src))
</code></pre><p>Connect Operation:</p><pre tabindex=0><code>  firrtl.connect %dest, %src : t1, t2
</code></pre><p>Interfaces: FConnectLike</p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>FIRRTLType</td></tr><tr><td style=text-align:center><code>src</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlconstant-circtfirrtlconstantop><code>firrtl.constant</code> (::circt::firrtl::ConstantOp)</h3><p>Produce a constant value</p><p>The constant operation produces a constant value of SInt or UInt type, it
never produces a zero bit wide result.</p><pre tabindex=0><code>  %result = firrtl.constant 42 : t1
</code></pre><p>Traits: ConstantLike, FirstAttrDerivedResultType</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-4>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>arbitrary integer attribute with sign</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlcover-circtfirrtlcoverop><code>firrtl.cover</code> (::circt::firrtl::CoverOp)</h3><p>Cover Verification Statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.cover` $clock `,` $predicate `,` $enable `,`
              $message (`(` $operands^ `)` `:` qualified(type($operands)))?
              custom&lt;VerifAttrs&gt;(attr-dict)
</code></pre><h4 id=attributes-5>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>isConcurrent</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td style=text-align:center><code>eventControl</code></td><td style=text-align:center>::EventControlAttr</td><td>edge control trigger</td></tr></tbody></table><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td style=text-align:center><code>enable</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlcvt-circtfirrtlcvtprimop><code>firrtl.cvt</code> (::circt::firrtl::CvtPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.cvt` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint type</td></tr></tbody></table><h3 id=firrtldshl-circtfirrtldshlprimop><code>firrtl.dshl</code> (::circt::firrtl::DShlPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.dshl` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>A dynamic shift left operation. The width of <code>$result</code> is expanded to
<code>width($lhs) + 1 &lt;&lt; width($rhs) - 1</code>.</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>uint type</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldshlw-circtfirrtldshlwprimop><code>firrtl.dshlw</code> (::circt::firrtl::DShlwPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.dshlw` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>A dynamic shift left operation same as &lsquo;dshl&rsquo; but with different width rule.
The width of <code>$result</code> is equal to <code>$lhs</code>.</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>uint type</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldshr-circtfirrtldshrprimop><code>firrtl.dshr</code> (::circt::firrtl::DShrPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.dshr` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-18>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>uint type</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtldiv-circtfirrtldivprimop><code>firrtl.div</code> (::circt::firrtl::DivPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.div` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Divides the first argument (the numerator) by the second argument
(the denominator) truncating the result (rounding towards zero).</p><p><strong>If the denominator is zero, the result is undefined.</strong></p><p>The compiler may optimize this undefined behavior in any way it
wants. Notably <code>div(a, a)</code> will be optimized to <code>1</code>. This may cause
erroneous formal equivalence mismatches between unoptimized and
optimized FIRRTL dialects that are separately converted to Verilog.</p><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-19>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtleq-circtfirrtleqprimop><code>firrtl.eq</code> (::circt::firrtl::EQPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.eq` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: Commutative, SameOperandsIntTypeKind</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-20>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlextmodule-circtfirrtlfextmoduleop><code>firrtl.extmodule</code> (::circt::firrtl::FExtModuleOp)</h3><p>FIRRTL extmodule</p><p>The &ldquo;firrtl.extmodule&rdquo; operation represents an external reference to a
Verilog module, including a given name and a list of ports.</p><p>Traits: HasParent<circuitop>, IsolatedFromAbove</p><p>Interfaces: FModuleLike, HWModuleLike, OpAsmOpInterface, Symbol</p><h4 id=attributes-6>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>defname</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>parameters</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr></tbody></table><h3 id=firrtlmemmodule-circtfirrtlfmemmoduleop><code>firrtl.memmodule</code> (::circt::firrtl::FMemModuleOp)</h3><p>FIRRTL Generated Module</p><p>The &ldquo;firrtl.memmodule&rdquo; operation represents an external reference to a
memory module. See the &ldquo;firrtl.mem&rdquo; op for a deeper explantation of the
parameters.</p><p>A &ldquo;firrtl.mem&rdquo; operation is typically lowered to this operation when they
are not directly lowered to registers by the compiler.</p><p>Traits: HasParent<circuitop>, IsolatedFromAbove</p><p>Interfaces: FModuleLike, HWModuleLike, OpAsmOpInterface, Symbol</p><h4 id=attributes-7>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>numReadPorts</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>numWritePorts</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>numReadWritePorts</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>dataWidth</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>maskBits</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>readLatency</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>writeLatency</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>depth</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit unsigned integer attribute</td></tr><tr><td style=text-align:center><code>extraPorts</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr></tbody></table><h3 id=firrtlmodule-circtfirrtlfmoduleop><code>firrtl.module</code> (::circt::firrtl::FModuleOp)</h3><p>FIRRTL Module</p><p>The &ldquo;firrtl.module&rdquo; operation represents a Verilog module, including a given
name, a list of ports, and a body that represents the connections within
the module.</p><p>Traits: HasParent<circuitop>, InnerSymbolTable, IsolatedFromAbove, NoTerminator, SingleBlock</p><p>Interfaces: FModuleLike, HWModuleLike, OpAsmOpInterface, Symbol</p><h4 id=attributes-8>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr></tbody></table><h3 id=firrtlforce-circtfirrtlforceop><code>firrtl.force</code> (::circt::firrtl::ForceOp)</h3><p>Force procedural statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.force` $dest `,` $src attr-dict `:` qualified(type($dest)) `,` qualified(type($src))
</code></pre><p>Maps to the corresponding <code>sv.force</code> operation.
Traits: SameTypeOperands</p><h4 id=operands-21>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>FIRRTLType</td></tr><tr><td style=text-align:center><code>src</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlgeq-circtfirrtlgeqprimop><code>firrtl.geq</code> (::circt::firrtl::GEQPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.geq` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-22>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlgt-circtfirrtlgtprimop><code>firrtl.gt</code> (::circt::firrtl::GTPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.gt` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-23>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-18>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlhwstructcast-circtfirrtlhwstructcastop><code>firrtl.hwStructCast</code> (::circt::firrtl::HWStructCastOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.hwStructCast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-24>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results-19>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=firrtlhead-circtfirrtlheadprimop><code>firrtl.head</code> (::circt::firrtl::HeadPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.head` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-9>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>amount</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-25>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-20>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlhierpath-circtfirrtlhierpathop><code>firrtl.hierpath</code> (::circt::firrtl::HierPathOp)</h3><p>Hierarchical path specification</p><p>The &ldquo;firrtl.hierpath&rdquo; operation represents a path through the hierarchy.
This is used to specify namable things for use in other operations, for
example in verbatim substitution. Non-local annotations also use these.</p><p>Traits: HasParent<circuitop>, IsolatedFromAbove</p><p>Interfaces: InnerRefUserOpInterface, Symbol</p><h4 id=attributes-10>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>namepath</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></tbody></table><h3 id=firrtlinstance-circtfirrtlinstanceop><code>firrtl.instance</code> (::circt::firrtl::InstanceOp)</h3><p>Instantiate an instance of a module</p><p>This represents an instance of a module. The results are the modules inputs
and outputs. The inputs have flip type, the outputs do not.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> firrtl<span class=p>.</span>instance foo <span class=nf>@Foo</span><span class=p>(</span>in io<span class=p>:</span> <span class=p>!</span>firrtl<span class=p>.</span>uint<span class=p>)</span>
</span></span></code></pre></div><p>Traits: HasParent&lt;firrtl::FModuleOp, firrtl::WhenOp></p><p>Interfaces: FNamableOp, HWInstanceLike, HasCustomSSAName, InnerSymbol, SymbolUserOpInterface</p><h4 id=attributes-11>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>moduleName</code></td><td style=text-align:center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>nameKind</code></td><td style=text-align:center>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td style=text-align:center><code>portDirections</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr><tr><td style=text-align:center><code>portNames</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td style=text-align:center><code>portAnnotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Port annotations attribute</td></tr><tr><td style=text-align:center><code>lowerToBind</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::circt::firrtl::InnerSymAttr</td><td>Inner symbol definition</td></tr></tbody></table><h4 id=results-21>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlinvalidvalue-circtfirrtlinvalidvalueop><code>firrtl.invalidvalue</code> (::circt::firrtl::InvalidValueOp)</h3><p>InvalidValue primitive</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.invalidvalue` attr-dict `:` qualified(type($result))
</code></pre><p>The InvalidValue operation returns an invalid value of a specified type:</p><pre tabindex=0><code>  %result = firrtl.invalid : !firrtl.uint&lt;1&gt;
</code></pre><p>This corresponds to the FIRRTL invalidate operation without the implicit
connect semantics.</p><p>Traits: ConstantLike</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-22>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlleq-circtfirrtlleqprimop><code>firrtl.leq</code> (::circt::firrtl::LEQPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.leq` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-26>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-23>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtllt-circtfirrtlltprimop><code>firrtl.lt</code> (::circt::firrtl::LTPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.lt` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-27>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-24>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlmem-circtfirrtlmemop><code>firrtl.mem</code> (::circt::firrtl::MemOp)</h3><p>Define a new mem</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.mem` (`sym` $inner_sym^)? custom&lt;NameKind&gt;($nameKind)
              $ruw custom&lt;MemOp&gt;(attr-dict) `:` qualified(type($results))
</code></pre><p>Interfaces: FNamableOp, HasCustomSSAName, InnerSymbol</p><h4 id=attributes-12>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>readLatency</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 0</td></tr><tr><td style=text-align:center><code>writeLatency</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 1</td></tr><tr><td style=text-align:center><code>depth</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 1</td></tr><tr><td style=text-align:center><code>ruw</code></td><td style=text-align:center>::RUWAttrAttr</td><td>Read Under Write Enum</td></tr><tr><td style=text-align:center><code>portNames</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>nameKind</code></td><td style=text-align:center>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td style=text-align:center><code>portAnnotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Port annotations attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::circt::firrtl::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td style=text-align:center><code>groupID</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr></tbody></table><h4 id=results-25>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlmul-circtfirrtlmulprimop><code>firrtl.mul</code> (::circt::firrtl::MulPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.mul` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: Commutative, SameOperandsIntTypeKind</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-28>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-26>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlmultibit_mux-circtfirrtlmultibitmuxop><code>firrtl.multibit_mux</code> (::circt::firrtl::MultibitMuxOp)</h3><p>Multibit multiplexer</p><p>The multibit mux expression dynamically selects operands. The
index must be an expression with an unsigned integer type.</p><pre tabindex=0><code>  %result = firrtl.multibit_mux %index,
            %v_{n-1}, ..., %v_2, %v_1, %v_0  : t1, t2
</code></pre><p>The order of operands is defined in the same way as hw dialect.
For the example above, if <code>%index</code> is 0, then the value is <code>%v_0</code>.</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-29>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>index</code></td><td>FIRRTLType</td></tr><tr><td style=text-align:center><code>inputs</code></td><td>FIRRTLType</td></tr></tbody></table><h4 id=results-27>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlmux-circtfirrtlmuxprimop><code>firrtl.mux</code> (::circt::firrtl::MuxPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.mux` `(` operands `)` attr-dict `:` functional-type(operands, $result)
</code></pre><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-30>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sel</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td style=text-align:center><code>high</code></td><td>a passive type (contain no flips)</td></tr><tr><td style=text-align:center><code>low</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h4 id=results-28>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h3 id=firrtlneq-circtfirrtlneqprimop><code>firrtl.neq</code> (::circt::firrtl::NEQPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.neq` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: Commutative, SameOperandsIntTypeKind</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-31>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-29>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlneg-circtfirrtlnegprimop><code>firrtl.neg</code> (::circt::firrtl::NegPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.neg` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-32>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-30>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint type</td></tr></tbody></table><h3 id=firrtlnode-circtfirrtlnodeop><code>firrtl.node</code> (::circt::firrtl::NodeOp)</h3><p>No-op to name a value</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.node` (`sym` $inner_sym^)? custom&lt;NameKind&gt;($nameKind)
              $input custom&lt;ImplicitSSAName&gt;(attr-dict) `:` qualified(type($input))
</code></pre><p>A node is simply a named intermediate value in a circuit. The node must
be initialized to a value with a passive type and cannot be connected to.
Nodes are often used to split a complicated compound expression into named
subexpressions.</p><pre tabindex=0><code>  %result = firrtl.node %input : t1
</code></pre><p>Traits: SameOperandsAndResultType</p><p>Interfaces: FNamableOp, HasCustomSSAName, InferTypeOpInterface, InnerSymbol</p><h4 id=attributes-13>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>nameKind</code></td><td style=text-align:center>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::circt::firrtl::InnerSymAttr</td><td>Inner symbol definition</td></tr></tbody></table><h4 id=operands-33>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a passive type (contain no flips)</td></tr></tbody></table><h4 id=results-31>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlnot-circtfirrtlnotprimop><code>firrtl.not</code> (::circt::firrtl::NotPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.not` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-34>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-32>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlor-circtfirrtlorprimop><code>firrtl.or</code> (::circt::firrtl::OrPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.or` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: Commutative, SameOperandsIntTypeKind</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-35>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-33>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlorr-circtfirrtlorrprimop><code>firrtl.orr</code> (::circt::firrtl::OrRPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.orr` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Horizontally reduce a value to one bit, using the &lsquo;or&rsquo; operation to merge
bits. <code>orr(x)</code> is equivalent to <code>concat(x, 1b0) != 0</code>. As such, it
returns 0 for zero-bit-wide operands.</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-36>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-34>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlpad-circtfirrtlpadprimop><code>firrtl.pad</code> (::circt::firrtl::PadPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.pad` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>Pad the input out to an <code>amount</code> wide integer, sign extending or zero
extending according to <code>input</code>s type. If <code>amount</code> is less than the existing
width of <code>input</code>, then input is unmodified.</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-14>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>amount</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-37>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-35>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlprintf-circtfirrtlprintfop><code>firrtl.printf</code> (::circt::firrtl::PrintFOp)</h3><p>Formatted Print Statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.printf` $clock `,` $cond `,` $formatString custom&lt;PrintfAttrs&gt;(attr-dict)
              (`(` $operands^ `)` `:` qualified(type($operands)))?
</code></pre><h4 id=attributes-15>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>formatString</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-38>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>cond</code></td><td>UInt&lt;1> or UInt</td></tr><tr><td style=text-align:center><code>operands</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlprobe-circtfirrtlprobeop><code>firrtl.probe</code> (::circt::firrtl::ProbeOp)</h3><p>FIRRTL Value Probe</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.probe` $inner_sym attr-dict ( `,` $operands^  `:` qualified(type($operands)))?
</code></pre><p>Captures values without binding to any accidental name.</p><h4 id=attributes-16>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-39>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlreg-circtfirrtlregop><code>firrtl.reg</code> (::circt::firrtl::RegOp)</h3><p>Define a new register</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.reg` (`sym` $inner_sym^)? custom&lt;NameKind&gt;($nameKind)
              operands custom&lt;ImplicitSSAName&gt;(attr-dict) `:` qualified(type($result))
</code></pre><p>Declare a new register:</p><pre tabindex=0><code>%name = firrtl.reg %clockVal : t1
</code></pre><p>Interfaces: FNamableOp, HasCustomSSAName, InnerSymbol</p><h4 id=attributes-17>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>nameKind</code></td><td style=text-align:center>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::circt::firrtl::InnerSymAttr</td><td>Inner symbol definition</td></tr></tbody></table><h4 id=operands-40>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clockVal</code></td><td>clock</td></tr></tbody></table><h4 id=results-36>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a passive type that does not contain analog</td></tr></tbody></table><h3 id=firrtlregreset-circtfirrtlregresetop><code>firrtl.regreset</code> (::circt::firrtl::RegResetOp)</h3><p>Define a new register with a reset</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.regreset` (`sym` $inner_sym^)? custom&lt;NameKind&gt;($nameKind)
              operands custom&lt;ImplicitSSAName&gt;(attr-dict)
              `:` qualified(type($resetSignal)) `,` qualified(type($resetValue)) `,` qualified(type($result))
</code></pre><p>Declare a new register:</p><pre tabindex=0><code>  %name = firrtl.regreset %clockVal, %resetSignal, %resetValue : t1
</code></pre><p>Interfaces: FNamableOp, HasCustomSSAName, InnerSymbol</p><h4 id=attributes-18>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>nameKind</code></td><td style=text-align:center>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::circt::firrtl::InnerSymAttr</td><td>Inner symbol definition</td></tr></tbody></table><h4 id=operands-41>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clockVal</code></td><td>clock</td></tr><tr><td style=text-align:center><code>resetSignal</code></td><td>Reset</td></tr><tr><td style=text-align:center><code>resetValue</code></td><td>a passive type that does not contain analog</td></tr></tbody></table><h4 id=results-37>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a passive type that does not contain analog</td></tr></tbody></table><h3 id=firrtlrem-circtfirrtlremprimop><code>firrtl.rem</code> (::circt::firrtl::RemPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.rem` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-42>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-38>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlshl-circtfirrtlshlprimop><code>firrtl.shl</code> (::circt::firrtl::ShlPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.shl` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>shl</code> operation concatenates <code>amount</code> zero bits to the least significant
end of <code>input</code>. <code>amount</code> must be non-negative.</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-19>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>amount</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-43>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-39>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlshr-circtfirrtlshrprimop><code>firrtl.shr</code> (::circt::firrtl::ShrPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.shr` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>shr</code> operation truncates least significant <code>amount</code> bits from <code>input</code>.
If <code>amount</code> is greater than of equal to <code>width(input)</code>, the value will be
zero for unsigned types and the sign bit for signed types. <code>amount</code> must be
non-negative.</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-20>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>amount</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-44>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-40>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlskip-circtfirrtlskipop><code>firrtl.skip</code> (::circt::firrtl::SkipOp)</h3><p>Skip statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.skip` attr-dict
</code></pre><p>Skip Statement:</p><pre tabindex=0><code>   %firrtl.skip
</code></pre><p>This is a no-op statement.</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h3 id=firrtlspecialconstant-circtfirrtlspecialconstantop><code>firrtl.specialconstant</code> (::circt::firrtl::SpecialConstantOp)</h3><p>Produce a constant Reset or Clock value</p><p>The constant operation produces a constant value of Reset, AsyncReset, or
Clock type. The value can only be 0 or 1.</p><pre tabindex=0><code>  %result = firrtl.specialconstant 1 : !firrtl.clock
</code></pre><p>Traits: ConstantLike</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-21>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td style=text-align:center>::mlir::BoolAttr</td><td>bool attribute</td></tr></tbody></table><h4 id=results-41>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>clock or Reset or AsyncReset</td></tr></tbody></table><h3 id=firrtlstop-circtfirrtlstopop><code>firrtl.stop</code> (::circt::firrtl::StopOp)</h3><p>Stop Statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.stop` $clock `,` $cond `,` $exitCode custom&lt;StopAttrs&gt;(attr-dict)
</code></pre><h4 id=attributes-22>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>exitCode</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-45>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>clock</td></tr><tr><td style=text-align:center><code>cond</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlstrictconnect-circtfirrtlstrictconnectop><code>firrtl.strictconnect</code> (::circt::firrtl::StrictConnectOp)</h3><p>Connect two signals</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.strictconnect` $dest `,` $src  attr-dict `:` qualified(type($dest))
</code></pre><p>Connect two values with strict constraints:</p><pre tabindex=0><code>  firrtl.strictconnect %dest, %src : t1
</code></pre><p>Traits: SameTypeOperands</p><p>Interfaces: FConnectLike</p><h4 id=operands-46>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>a sized type (contains no unifered widths)</td></tr><tr><td style=text-align:center><code>src</code></td><td>a sized type (contains no unifered widths)</td></tr></tbody></table><h3 id=firrtlsub-circtfirrtlsubprimop><code>firrtl.sub</code> (::circt::firrtl::SubPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.sub` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: SameOperandsIntTypeKind</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-47>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-42>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>sint or uint type</td></tr></tbody></table><h3 id=firrtlsubaccess-circtfirrtlsubaccessop><code>firrtl.subaccess</code> (::circt::firrtl::SubaccessOp)</h3><p>Extract a dynamic element of a vector value</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.subaccess` $input `[` $index `]` attr-dict `:` qualified(type($input)) `,` qualified(type($index))
</code></pre><p>The subaccess expression dynamically refers to a subelement of a
vector-typed expression using a calculated index. The index must be an
expression with an unsigned integer type.</p><pre tabindex=0><code>  %result = firrtl.subaccess %input[%idx] : t1, t2
</code></pre><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-48>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>FIRRTLType</td></tr><tr><td style=text-align:center><code>index</code></td><td>uint type</td></tr></tbody></table><h4 id=results-43>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlsubfield-circtfirrtlsubfieldop><code>firrtl.subfield</code> (::circt::firrtl::SubfieldOp)</h3><p>Extract a subfield of another value</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.subfield` $input `(` $fieldIndex `)` attr-dict `:` functional-type($input, $result)
</code></pre><p>The subfield expression refers to a subelement of an expression with a
bundle type.</p><pre tabindex=0><code>  %result = firrtl.subfield %input &#34;fieldIndex&#34; : t1, t2
</code></pre><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-23>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fieldIndex</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-49>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>BundleType</td></tr></tbody></table><h4 id=results-44>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlsubindex-circtfirrtlsubindexop><code>firrtl.subindex</code> (::circt::firrtl::SubindexOp)</h3><p>Extract an element of a vector value</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.subindex` $input `[` $index `]` attr-dict `:` qualified(type($input))
</code></pre><p>The subindex expression statically refers, by index, to a subelement
of an expression with a vector type. The index must be a non-negative
integer and cannot be equal to or exceed the length of the vector it
indexes.</p><pre tabindex=0><code>  %result = firrtl.subindex %input[index] : t1
</code></pre><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-24>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>index</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-50>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>FIRRTLType</td></tr></tbody></table><h4 id=results-45>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtltail-circtfirrtltailprimop><code>firrtl.tail</code> (::circt::firrtl::TailPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.tail` $input `,` $amount attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>tail</code> operation truncates the <code>amount</code> most significant bits from
<code>input</code>. <code>amount</code> must be non-negative and less than or equal to the bit
width of e. The result is <code>width(input)-amount</code> bits wide.</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-25>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>amount</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></tbody></table><h4 id=operands-51>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-46>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlverbatimexpr-circtfirrtlverbatimexprop><code>firrtl.verbatim.expr</code> (::circt::firrtl::VerbatimExprOp)</h3><p>Expression that expands to a value given SystemVerilog text</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.verbatim.expr` $text (`(` $operands^ `)`)?
              `:` functional-type($operands, $result) attr-dict
</code></pre><p>This operation produces a typed value expressed by a string of
SystemVerilog. This can be used to access macros and other values that are
only sensible as Verilog text.</p><p>The text string is expected to have the highest precedence, so you should
include parentheses in the string if it isn&rsquo;t a single token. This is also
assumed to not have side effects (use <code>sv.verbatim</code> if you need them).</p><p><code>firrtl.verbatim.expr</code> allows operand substitutions with <code>{{0}}</code> syntax.</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-26>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>text</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>symbols</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></tbody></table><h4 id=operands-52>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h4 id=results-47>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlverbatimwire-circtfirrtlverbatimwireop><code>firrtl.verbatim.wire</code> (::circt::firrtl::VerbatimWireOp)</h3><p>Expression with wire semantics that expands to a value given SystemVerilog text</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.verbatim.wire` $text (`(` $operands^ `)`)?
              `:` functional-type($operands, $result) attr-dict
</code></pre><p>This operation produces a typed value with wire semantics, expressed by a
string of SystemVerilog. This can be used to access macros and other values
that are only sensible as Verilog text.</p><p>The text string is expected to have the highest precedence, so you should
include parentheses in the string if it isn&rsquo;t a single token. This is also
assumed to not have side effects (use <code>sv.verbatim</code> if you need them).</p><p><code>firrtl.verbatim.wire</code> allows operand substitutions with <code>{{0}}</code> syntax.</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-27>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>text</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>symbols</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></tbody></table><h4 id=operands-53>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h4 id=results-48>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlwhen-circtfirrtlwhenop><code>firrtl.when</code> (::circt::firrtl::WhenOp)</h3><p>When Statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.when` $condition $thenRegion (`else` $elseRegion^)? attr-dict-with-keyword
</code></pre><p>The &ldquo;firrtl.when&rdquo; operation represents a conditional. Connections within
a conditional statement that connect to previously declared components hold
only when the given condition is high. The condition must have a 1-bit
unsigned integer type.</p><p>Traits: NoRegionArguments, NoTerminator, RecursiveSideEffects, SingleBlock</p><h4 id=operands-54>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h3 id=firrtlwire-circtfirrtlwireop><code>firrtl.wire</code> (::circt::firrtl::WireOp)</h3><p>Define a new wire</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.wire` (`sym` $inner_sym^)? custom&lt;NameKind&gt;($nameKind)
              custom&lt;ImplicitSSAName&gt;(attr-dict) `:` qualified(type($result))
</code></pre><p>Declare a new wire:</p><pre tabindex=0><code>  %name = firrtl.wire : t1
</code></pre><p>Interfaces: FNamableOp, HasCustomSSAName, InnerSymbol</p><h4 id=attributes-28>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>nameKind</code></td><td style=text-align:center>::circt::firrtl::NameKindEnumAttr</td><td>name kind</td></tr><tr><td style=text-align:center><code>annotations</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>Annotation array attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::circt::firrtl::InnerSymAttr</td><td>Inner symbol definition</td></tr></tbody></table><h4 id=results-49>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>FIRRTLType</td></tr></tbody></table><h3 id=firrtlxor-circtfirrtlxorprimop><code>firrtl.xor</code> (::circt::firrtl::XorPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.xor` $lhs `,` $rhs  attr-dict `:`
              `(` qualified(type($lhs)) `,` qualified(type($rhs)) `)` `-&gt;` qualified(type($result))
</code></pre><p>Traits: Commutative, SameOperandsIntTypeKind</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-55>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>sint or uint type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-50>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>uint type</td></tr></tbody></table><h3 id=firrtlxorr-circtfirrtlxorrprimop><code>firrtl.xorr</code> (::circt::firrtl::XorRPrimOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `firrtl.xorr` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Horizontally reduce a value to one bit, using the &lsquo;xor&rsquo; operation to merge
bits. <code>xorr(x)</code> is equivalent to <code>popcount(concat(x, 1b0)) & 1</code>. As
such, it returns 0 for zero-bit-wide operands.</p><p>Interfaces: HasCustomSSAName, InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-56>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>sint or uint type</td></tr></tbody></table><h4 id=results-51>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>UInt&lt;1> or UInt</td></tr></tbody></table><h2 id=attribute-definition>Attribute definition</h2><h3 id=augmentedbooleantypeattr>AugmentedBooleanTypeAttr</h3><p>GrandCentral AugmentedBooleanType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedbundletypeattr>AugmentedBundleTypeAttr</h3><p>GrandCentral AugmentedBundleType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmenteddeletedtypeattr>AugmentedDeletedTypeAttr</h3><p>GrandCentral AugmentedDeletedType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmenteddoubletypeattr>AugmentedDoubleTypeAttr</h3><p>GrandCentral AugmentedDoubleType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedgroundtypeattr>AugmentedGroundTypeAttr</h3><p>GrandCentral AugmentedGroundType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedintegertypeattr>AugmentedIntegerTypeAttr</h3><p>GrandCentral AugmentedIntegerType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedliteraltypeattr>AugmentedLiteralTypeAttr</h3><p>GrandCentral AugmentedLiteralType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedstringtypeattr>AugmentedStringTypeAttr</h3><p>GrandCentral AugmentedStringType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=augmentedvectortypeattr>AugmentedVectorTypeAttr</h3><p>GrandCentral AugmentedVectorType</p><p>Used in the GrandCentralPass.</p><h4 id=parameters-8>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlying</td><td style=text-align:center><code>DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=innersymattr>InnerSymAttr</h3><p>Inner symbol definition</p><p>Defines the properties of an inner_sym attribute. It specifies the symbol
name and symbol visibility for each field ID. For any ground types,
there are no subfields and the field ID is 0. For aggregate types, a
unique field ID is assigned to each field by visiting them in a
depth-first pre-order. The custom assembly format ensures that for ground
types, only <code>@&lt;sym_name></code> is printed.</p><h4 id=parameters-9>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>props</td><td style=text-align:center><code>::llvm::ArrayRef&lt;InnerSymPropertiesAttr></code></td><td></td></tr></tbody></table><h3 id=innersympropertiesattr>InnerSymPropertiesAttr</h3><h4 id=parameters-10>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>StringAttr</code></td><td></td></tr><tr><td style=text-align:center>fieldID</td><td style=text-align:center><code>int64_t</code></td><td></td></tr><tr><td style=text-align:center>sym_visibility</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr></tbody></table><h3 id=invalidvalueattr>InvalidValueAttr</h3><p>A constant value of firrtl.invalid type</p><p>Syntax:</p><pre tabindex=0><code>!firrtl.invalidvalue&lt;
  ::mlir::Type   # type
&gt;
</code></pre><p>Represents an firrtl.invalidvalue value, whose type is specified by the
type of the attribute.</p><h4 id=parameters-11>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=namekindenumattr>NameKindEnumAttr</h3><p>name kind</p><p>Syntax:</p><pre tabindex=0><code>!firrtl.name_kind&lt;
  ::circt::firrtl::NameKindEnum   # value
&gt;
</code></pre><h4 id=parameters-12>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::circt::firrtl::NameKindEnum</code></td><td>an enum of type NameKindEnum</td></tr></tbody></table><h3 id=paramdeclattr>ParamDeclAttr</h3><p>Module or instance parameter definition</p><p>An attribute describing a module parameter, or instance parameter
specification.</p><h4 id=parameters-13>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::TypeAttr</code></td><td></td></tr><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h2 id=type-constraint-definition>Type constraint definition</h2><h3 id=analog-type>analog type</h3><h3 id=a-passive-type-that-does-not-contain-analog>a passive type that does not contain analog</h3><h3 id=reset>Reset</h3><h3 id=asyncreset>AsyncReset</h3><h3 id=bundletype>BundleType</h3><h3 id=clock>clock</h3><h3 id=firrtltype>FIRRTLType</h3><h3 id=fvectortype>FVectorType</h3><h3 id=sint-or-uint-type>sint or uint type</h3><h3 id=uint1-sint1-or-analog1>UInt&lt;1>, SInt&lt;1>, or Analog&lt;1></h3><h3 id=a-passive-type-contain-no-flips>a passive type (contain no flips)</h3><h3 id=reset-1>Reset</h3><h3 id=sint-type>sint type</h3><h3 id=a-sized-type-contains-no-unifered-widths>a sized type (contains no unifered widths)</h3><h3 id=uint1-or-uint>UInt&lt;1> or UInt</h3><h3 id=uint-type>uint type</h3><h2>'firrtl' Dialect Docs</h2><ul><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/ title="The Elastic Silicon Interconnect dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - The Elastic Silicon Interconnect dialect</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/ title="FIRRTL Annotations">Next - FIRRTL Annotations <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class="active has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li></ul></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/>PyCDE</a></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>