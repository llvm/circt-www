<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'hw' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/HW/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'hw' Dialect</h1><p>This dialect defines the <code>hw</code> dialect, which is intended to be a generic
representation of HW outside of a particular use-case.</p><p><nav id=TableOfContents><ul><li><a href=#operation-definitions----structure>Operation Definitions &ndash; Structure</a><ul><li><a href=#hwgeneratorschema-circthwhwgeneratorschemaop><code>hw.generator.schema</code> (::circt::hw::HWGeneratorSchemaOp)</a></li><li><a href=#hwmoduleextern-circthwhwmoduleexternop><code>hw.module.extern</code> (::circt::hw::HWModuleExternOp)</a></li><li><a href=#hwmodulegenerated-circthwhwmodulegeneratedop><code>hw.module.generated</code> (::circt::hw::HWModuleGeneratedOp)</a></li><li><a href=#hwmodule-circthwhwmoduleop><code>hw.module</code> (::circt::hw::HWModuleOp)</a></li><li><a href=#hwhierpath-circthwhierpathop><code>hw.hierpath</code> (::circt::hw::HierPathOp)</a></li><li><a href=#hwinstance_choice-circthwinstancechoiceop><code>hw.instance_choice</code> (::circt::hw::InstanceChoiceOp)</a></li><li><a href=#hwinstance-circthwinstanceop><code>hw.instance</code> (::circt::hw::InstanceOp)</a></li><li><a href=#hwoutput-circthwoutputop><code>hw.output</code> (::circt::hw::OutputOp)</a></li><li><a href=#hwtriggered-circthwtriggeredop><code>hw.triggered</code> (::circt::hw::TriggeredOp)</a></li></ul></li><li><a href=#operation-definitions----miscellaneous>Operation Definitions &ndash; Miscellaneous</a><ul><li><a href=#hwbitcast-circthwbitcastop><code>hw.bitcast</code> (::circt::hw::BitcastOp)</a></li><li><a href=#hwconstant-circthwconstantop><code>hw.constant</code> (::circt::hw::ConstantOp)</a></li><li><a href=#hwenumcmp-circthwenumcmpop><code>hw.enum.cmp</code> (::circt::hw::EnumCmpOp)</a></li><li><a href=#hwenumconstant-circthwenumconstantop><code>hw.enum.constant</code> (::circt::hw::EnumConstantOp)</a></li><li><a href=#hwparamvalue-circthwparamvalueop><code>hw.param.value</code> (::circt::hw::ParamValueOp)</a></li><li><a href=#hwwire-circthwwireop><code>hw.wire</code> (::circt::hw::WireOp)</a></li></ul></li><li><a href=#operation-definitions----aggregates>Operation Definitions &ndash; Aggregates</a><ul><li><a href=#hwaggregate_constant-circthwaggregateconstantop><code>hw.aggregate_constant</code> (::circt::hw::AggregateConstantOp)</a></li><li><a href=#hwarray_concat-circthwarrayconcatop><code>hw.array_concat</code> (::circt::hw::ArrayConcatOp)</a></li><li><a href=#hwarray_create-circthwarraycreateop><code>hw.array_create</code> (::circt::hw::ArrayCreateOp)</a></li><li><a href=#hwarray_get-circthwarraygetop><code>hw.array_get</code> (::circt::hw::ArrayGetOp)</a></li><li><a href=#hwarray_slice-circthwarraysliceop><code>hw.array_slice</code> (::circt::hw::ArraySliceOp)</a></li><li><a href=#hwstruct_create-circthwstructcreateop><code>hw.struct_create</code> (::circt::hw::StructCreateOp)</a></li><li><a href=#hwstruct_explode-circthwstructexplodeop><code>hw.struct_explode</code> (::circt::hw::StructExplodeOp)</a></li><li><a href=#hwstruct_extract-circthwstructextractop><code>hw.struct_extract</code> (::circt::hw::StructExtractOp)</a></li><li><a href=#hwstruct_inject-circthwstructinjectop><code>hw.struct_inject</code> (::circt::hw::StructInjectOp)</a></li><li><a href=#hwunion_create-circthwunioncreateop><code>hw.union_create</code> (::circt::hw::UnionCreateOp)</a></li><li><a href=#hwunion_extract-circthwunionextractop><code>hw.union_extract</code> (::circt::hw::UnionExtractOp)</a></li></ul></li><li><a href=#operation-definitions----type-declarations>Operation Definitions &ndash; Type Declarations</a><ul><li><a href=#hwtype_scope-circthwtypescopeop><code>hw.type_scope</code> (::circt::hw::TypeScopeOp)</a></li><li><a href=#hwtypedecl-circthwtypedeclop><code>hw.typedecl</code> (::circt::hw::TypedeclOp)</a></li></ul></li><li><a href=#attribute-definitions>Attribute Definitions</a><ul><li><a href=#enumfieldattr>EnumFieldAttr</a></li><li><a href=#outputfileattr>OutputFileAttr</a></li><li><a href=#paramdeclattr>ParamDeclAttr</a></li><li><a href=#paramdeclrefattr>ParamDeclRefAttr</a></li><li><a href=#paramexprattr>ParamExprAttr</a></li><li><a href=#paramverbatimattr>ParamVerbatimAttr</a></li><li><a href=#innerrefattr>InnerRefAttr</a></li></ul></li><li><a href=#type-definitions>Type Definitions</a><ul><li><a href=#hwtype_scope-circthwtypescopeop-1><code>hw.type_scope</code> (::circt::hw::TypeScopeOp)</a></li><li><a href=#hwtypedecl-circthwtypedeclop-1><code>hw.typedecl</code> (::circt::hw::TypedeclOp)</a></li><li><a href=#arraytype>ArrayType</a></li><li><a href=#enumtype>EnumType</a></li><li><a href=#stringtype>StringType</a></li><li><a href=#inouttype>InOutType</a></li><li><a href=#inttype>IntType</a></li><li><a href=#moduletype>ModuleType</a></li><li><a href=#structtype>StructType</a></li><li><a href=#typealiastype>TypeAliasType</a></li><li><a href=#uniontype>UnionType</a></li><li><a href=#unpackedarraytype>UnpackedArrayType</a></li></ul></li><li><a href=#hwinstancelike-hwinstancelike>HWInstanceLike (<code>HWInstanceLike</code>)</a><ul><li><a href=#methods>Methods:</a></li></ul></li><li><a href=#hwmodulelike-hwmodulelike>HWModuleLike (<code>HWModuleLike</code>)</a><ul><li><a href=#methods-1>Methods:</a></li></ul></li><li><a href=#hwmutablemodulelike-hwmutablemodulelike>HWMutableModuleLike (<code>HWMutableModuleLike</code>)</a><ul><li><a href=#methods-2>Methods:</a></li></ul></li><li><a href=#innerrefuseropinterface-innerrefuseropinterface>InnerRefUserOpInterface (<code>InnerRefUserOpInterface</code>)</a><ul><li><a href=#methods-3>Methods:</a></li></ul></li><li><a href=#innersymbolopinterface-innersymbol>InnerSymbolOpInterface (<code>InnerSymbol</code>)</a><ul><li><a href=#methods-4>Methods:</a></li></ul></li><li><a href=#portlist-portlist>PortList (<code>PortList</code>)</a><ul><li><a href=#methods-5>Methods:</a></li></ul></li><li><a href=#fieldidtypeinterface-fieldidtypeinterface>FieldIDTypeInterface (<code>FieldIDTypeInterface</code>)</a><ul><li><a href=#methods-6>Methods:</a></li></ul></li></ul></nav><h2 id=operation-definitions----structure>Operation Definitions &ndash; Structure</h2><h3 id=hwgeneratorschema-circthwhwgeneratorschemaop><code>hw.generator.schema</code> (::circt::hw::HWGeneratorSchemaOp)</h3><p><em>HW Generator Schema declaration</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.generator.schema` $sym_name `,` $descriptor `,` $requiredAttrs attr-dict
</code></pre><p>The &ldquo;hw.generator.schema&rdquo; operation declares a kind of generated module by
declaring the schema of meta-data required.
A generated module instance of a schema is independent of the external
method of producing it. It is assumed that for well known schema instances,
multiple external tools might exist which can process it. Generator nodes
list attributes required by hw.module.generated instances.</p><p>For example:
generator.schema @MEMORY, &ldquo;Simple-Memory&rdquo;, [&ldquo;ports&rdquo;, &ldquo;write_latency&rdquo;, &ldquo;read_latency&rdquo;]
module.generated @mymem, @MEMORY(ports)
-> (ports) {write_latency=1, read_latency=1, ports=[&ldquo;read&rdquo;,&ldquo;write&rdquo;]}</p><p>Traits: <code>HasParent&lt;mlir::ModuleOp></code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>descriptor</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>requiredAttrs</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h3 id=hwmoduleextern-circthwhwmoduleexternop><code>hw.module.extern</code> (::circt::hw::HWModuleExternOp)</h3><p><em>HW external Module</em></p><p>The &ldquo;hw.module.extern&rdquo; operation represents an external reference to a
Verilog module, including a given name and a list of ports.</p><p>The &lsquo;verilogName&rsquo; attribute (when present) specifies the spelling of the
module name in Verilog we can use. TODO: This is a hack because we don&rsquo;t
have proper parameterization in the hw.dialect. We need a way to represent
parameterized types instead of just concrete types.</p><p>Traits: <code>HasParent&lt;mlir::ModuleOp></code>, <code>InnerSymbolTable</code></p><p>Interfaces: <code>HWModuleLike</code>, <code>HWMutableModuleLike</code>, <code>InstanceGraphModuleOpInterface</code>, <code>OpAsmOpInterface</code>, <code>PortList</code>, <code>Symbol</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>module_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of a module</td></tr><tr><td><code>per_port_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>port_locs</code></td><td>::mlir::ArrayAttr</td><td>location array attribute</td></tr><tr><td><code>parameters</code></td><td>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td><code>verilogName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=hwmodulegenerated-circthwhwmodulegeneratedop><code>hw.module.generated</code> (::circt::hw::HWModuleGeneratedOp)</h3><p><em>HW Generated Module</em></p><p>The &ldquo;hw.module.generated&rdquo; operation represents a reference to an external
module that will be produced by some external process.
This represents the name and list of ports to be generated.</p><p>The &lsquo;verilogName&rsquo; attribute (when present) specifies the spelling of the
module name in Verilog we can use. See hw.module for an explanation.</p><p>Traits: <code>HasParent&lt;mlir::ModuleOp></code>, <code>InnerSymbolTable</code>, <code>IsolatedFromAbove</code></p><p>Interfaces: <code>HWModuleLike</code>, <code>HWMutableModuleLike</code>, <code>InstanceGraphModuleOpInterface</code>, <code>OpAsmOpInterface</code>, <code>PortList</code>, <code>SymbolUserOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>generatorKind</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>module_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of a module</td></tr><tr><td><code>per_port_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>port_locs</code></td><td>::mlir::ArrayAttr</td><td>location array attribute</td></tr><tr><td><code>parameters</code></td><td>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td><code>verilogName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=hwmodule-circthwhwmoduleop><code>hw.module</code> (::circt::hw::HWModuleOp)</h3><p><em>HW Module</em></p><p>The &ldquo;hw.module&rdquo; operation represents a Verilog module, including a given
name, a list of ports, a list of parameters, and a body that represents the
connections within the module.</p><p>Traits: <code>Emittable</code>, <code>HasParent&lt;mlir::ModuleOp></code>, <code>InnerSymbolTable</code>, <code>IsolatedFromAbove</code>, <code>SingleBlockImplicitTerminator&lt;OutputOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>HWModuleLike</code>, <code>HWMutableModuleLike</code>, <code>InstanceGraphModuleOpInterface</code>, <code>OpAsmOpInterface</code>, <code>PortList</code>, <code>RegionKindInterface</code>, <code>Symbol</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>module_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of a module</td></tr><tr><td><code>per_port_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>result_locs</code></td><td>::mlir::ArrayAttr</td><td>location array attribute</td></tr><tr><td><code>parameters</code></td><td>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td><code>comment</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=hwhierpath-circthwhierpathop><code>hw.hierpath</code> (::circt::hw::HierPathOp)</h3><p><em>Hierarchical path specification</em></p><p>The &ldquo;hw.hierpath&rdquo; operation represents a path through the hierarchy.
This is used to specify namable things for use in other operations, for
example in verbatim substitution. Non-local annotations also use these.</p><p>Traits: <code>IsolatedFromAbove</code></p><p>Interfaces: <code>InnerRefUserOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>namepath</code></td><td>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></table><h3 id=hwinstance_choice-circthwinstancechoiceop><code>hw.instance_choice</code> (::circt::hw::InstanceChoiceOp)</h3><p><em>Represents an instance with a target-specific reference</em></p><p>This represents an instance to a module which is determined based on the
target through the ABI. Besides a default implementation, other targets can
be associated with a string, which will later determined which reference
is chosen.</p><p>For the purposes of analyses and transformations, it is assumed that any of
the targets is a possibility.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%b</span> <span class=p>=</span> hw<span class=p>.</span>instance_choice <span class=s>&#34;inst&#34;</span> sym
</span></span><span class=line><span class=cl>    <span class=nf>@TargetDefault</span> or
</span></span><span class=line><span class=cl>    <span class=nf>@TargetA</span> if <span class=s>&#34;A&#34;</span> or
</span></span><span class=line><span class=cl>    <span class=nf>@TargetB</span> if <span class=s>&#34;B&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span>a<span class=p>:</span> <span class=nv>%a</span><span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>b<span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</span></span></code></pre></div><p>Interfaces: <code>HWInstanceLike</code>, <code>InnerSymbolOpInterface</code>, <code>InstanceGraphInstanceOpInterface</code>, <code>InstanceOpInterface</code>, <code>OpAsmOpInterface</code>, <code>PortList</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>instanceName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>moduleNames</code></td><td>::mlir::ArrayAttr</td><td>flat symbol ref array attribute</td></tr><tr><td><code>optionName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>caseNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>argNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>resultNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>parameters</code></td><td>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=hwinstance-circthwinstanceop><code>hw.instance</code> (::circt::hw::InstanceOp)</h3><p><em>Create an instance of a module</em></p><p>This represents an instance of a module. The inputs and results are
the referenced module&rsquo;s inputs and outputs. The <code>argNames</code> and
<code>resultNames</code> attributes must match the referenced module.</p><p>Any parameters in the &ldquo;old&rdquo; format (slated to be removed) are stored in the
<code>oldParameters</code> dictionary.</p><p>Interfaces: <code>HWInstanceLike</code>, <code>InnerSymbolOpInterface</code>, <code>InstanceGraphInstanceOpInterface</code>, <code>OpAsmOpInterface</code>, <code>PortList</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>instanceName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>moduleName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>argNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>resultNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>parameters</code></td><td>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=hwoutput-circthwoutputop><code>hw.output</code> (::circt::hw::OutputOp)</h3><p><em>HW termination operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.output` attr-dict ($outputs^ `:` qualified(type($outputs)))?
</code></pre><p>&ldquo;hw.output&rdquo; marks the end of a region in the HW dialect and the values
to put on the output ports.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;HWModuleOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=hwtriggered-circthwtriggeredop><code>hw.triggered</code> (::circt::hw::TriggeredOp)</h3><p><em>A procedural region with a trigger condition</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.triggered` $event $trigger  `(` $inputs `)` `:` type($inputs) $body attr-dict
</code></pre><p>A procedural region that can be triggered by an event. The trigger
condition is a 1-bit value that is activated based on some event control
attribute.
The operation is <code>IsolatedFromAbove</code>, and thus requires values passed into
the trigger region to be explicitly passed in through the <code>inputs</code> list.</p><p>Traits: <code>IsolatedFromAbove</code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><h4 id=attributes-7>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>event</code></td><td>circt::hw::EventControlAttr</td><td>edge control trigger</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>trigger</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h2 id=operation-definitions----miscellaneous>Operation Definitions &ndash; Miscellaneous</h2><h3 id=hwbitcast-circthwbitcastop><code>hw.bitcast</code> (::circt::hw::BitcastOp)</h3><p><em>Reinterpret one value to another value of the same size and
potentially different type. See the <code>hw</code> dialect rationale document for
more details.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.bitcast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>Type wherein the bitwidth in hardware is known</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Type wherein the bitwidth in hardware is known</td></tr></tbody></table><h3 id=hwconstant-circthwconstantop><code>hw.constant</code> (::circt::hw::ConstantOp)</h3><p><em>Produce a constant value</em></p><p>The constant operation produces a constant value of standard integer type
without a sign.</p><pre tabindex=0><code>  %result = hw.constant 42 : t1
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code>, <code>FirstAttrDerivedResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-8>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a signless integer bitvector</td></tr></tbody></table><h3 id=hwenumcmp-circthwenumcmpop><code>hw.enum.cmp</code> (::circt::hw::EnumCmpOp)</h3><p><em>Compare two values of an enumeration</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.enum.cmp` $lhs `,` $rhs attr-dict `:` qualified(type($lhs)) `,` qualified(type($rhs))
</code></pre><p>This operation compares two values with the same canonical enumeration
type, returning 0 if they are different, and 1 if they are the same.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>%enumcmp</span> <span class=p>=</span> hw<span class=p>.</span>enum<span class=p>.</span>cmp <span class=nv>%A</span><span class=p>,</span> <span class=nv>%B</span> <span class=p>:</span> <span class=p>!</span>hw<span class=p>.</span>enum<span class=p>&lt;</span>A<span class=p>,</span> B<span class=p>,</span> C<span class=p>&gt;,</span> <span class=p>!</span>hw<span class=p>.</span>enum<span class=p>&lt;</span>A<span class=p>,</span> B<span class=p>,</span> C<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>a EnumType</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>a EnumType</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=hwenumconstant-circthwenumconstantop><code>hw.enum.constant</code> (::circt::hw::EnumConstantOp)</h3><p><em>Produce a constant enumeration value.</em></p><p>The enum.constant operation produces an enumeration value of the specified
enum value attribute.</p><pre tabindex=0><code>  %0 = hw.enum.constant A : !hw.enum&lt;A, B, C&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-9>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>field</code></td><td>::circt::hw::EnumFieldAttr</td><td>Enumeration field attribute</td></tr></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a EnumType</td></tr></tbody></table><h3 id=hwparamvalue-circthwparamvalueop><code>hw.param.value</code> (::circt::hw::ParamValueOp)</h3><p><em>Return the value of a parameter expression as an SSA value that may be used
by other ops.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.param.value` custom&lt;ParamValue&gt;($value, qualified(type($result))) attr-dict
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code>, <code>FirstAttrDerivedResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-10>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::Attribute</td><td>any attribute</td></tr></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element</td></tr></tbody></table><h3 id=hwwire-circthwwireop><code>hw.wire</code> (::circt::hw::WireOp)</h3><p><em>Assign a name or symbol to an SSA edge</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.wire` $input (`sym` $inner_sym^)? custom&lt;ImplicitSSAName&gt;($name) attr-dict
              `:` qualified(type($input))
</code></pre><p>An <code>hw.wire</code> is used to assign a human-readable name or a symbol for remote
references to an SSA edge. It takes a single operand and returns its value
unchanged as a result. The operation guarantees the following:</p><ul><li><p>If the wire has a symbol, the value of its operand remains observable
under that symbol within the IR.</p></li><li><p>If the wire has a name, the name is treated as a hint. If the wire
persists until code generation the resulting wire will have this name,
with a potential suffix to ensure uniqueness. If the wire is canonicalized
away, its name is propagated to its input operand as a name hint.</p></li><li><p>The users of its result will always observe the operand through the
operation itself, meaning that optimizations cannot bypass the wire. This
ensures that if the wire&rsquo;s value is <em>forced</em>, for example through a
Verilog force statement, the forced value will affect all users of the
wire in the output.</p></li></ul><p>Example:</p><pre tabindex=0><code>%1 = hw.wire %0 : i42
%2 = hw.wire %0 sym @mySym : i42
%3 = hw.wire %0 name &#34;myWire&#34; : i42
%myWire = hw.wire %0 : i42
</code></pre><p>Traits: <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>InferTypeOpInterface</code>, <code>InnerSymbolOpInterface</code>, <code>OpAsmOpInterface</code></p><h4 id=attributes-11>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h2 id=operation-definitions----aggregates>Operation Definitions &ndash; Aggregates</h2><h3 id=hwaggregate_constant-circthwaggregateconstantop><code>hw.aggregate_constant</code> (::circt::hw::AggregateConstantOp)</h3><p><em>Produce a constant aggregate value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.aggregate_constant` $fields attr-dict `:` type($result)
</code></pre><p>This operation produces a constant value of an aggregate type. Clock and
reset values are supported. For nested aggregates, embedded arrays are
used.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>%result</span> <span class=p>=</span> hw<span class=p>.</span>aggregate<span class=p>.</span><span class=kt>constant</span> <span class=p>[</span><span class=m>1</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i2</span><span class=p>,</span> <span class=m>3</span> <span class=p>:</span> <span class=k>i2</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>hw<span class=p>.</span>struct<span class=p>&lt;</span>a<span class=p>:</span> <span class=k>i8</span><span class=p>,</span> b<span class=p>:</span> <span class=k>i8</span><span class=p>,</span> c<span class=p>:</span> <span class=k>i8</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%result</span> <span class=p>=</span> hw<span class=p>.</span>aggregate<span class=p>.</span><span class=kt>constant</span> <span class=p>[</span><span class=m>1</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=p>[</span><span class=m>2</span> <span class=p>:</span> <span class=k>i2</span><span class=p>,</span> <span class=m>3</span> <span class=p>:</span> <span class=k>i2</span><span class=p>]]</span> <span class=p>:</span> <span class=p>!</span>hw<span class=p>.</span>struct<span class=p>&lt;</span>a<span class=p>:</span> <span class=k>i8</span><span class=p>,</span> b<span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=k>i8</span><span class=p>,</span> <span class=m>2</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-12>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fields</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>an ArrayType or StructType</td></tr></tbody></table><h3 id=hwarray_concat-circthwarrayconcatop><code>hw.array_concat</code> (::circt::hw::ArrayConcatOp)</h3><p><em>Concatenate some arrays</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.array_concat` $inputs attr-dict `:` custom&lt;ArrayConcatTypes&gt;(type($inputs), qualified(type($result)))
</code></pre><p>Creates an array by concatenating a variable set of arrays. One or more
values must be listed.</p><pre tabindex=0><code>// %a, %b, %c are hw arrays of i4 with sizes 2, 5, and 4 respectively.
%array = hw.array_concat %a, %b, %c : (2, 5, 4 x i4)
// %array is !hw.array&lt;11 x i4&gt;
</code></pre><p>See the HW-SV rationale document for details on operand ordering.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of an ArrayType</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>an ArrayType</td></tr></tbody></table><h3 id=hwarray_create-circthwarraycreateop><code>hw.array_create</code> (::circt::hw::ArrayCreateOp)</h3><p><em>Create an array from values</em></p><p>Creates an array from a variable set of values. One or more values must be
listed.</p><pre tabindex=0><code>// %a, %b, %c are all i4
%array = hw.array_create %a, %b, %c : i4
</code></pre><p>See the HW-SV rationale document for details on operand ordering.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of a type without inout</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>an ArrayType</td></tr></tbody></table><h3 id=hwarray_get-circthwarraygetop><code>hw.array_get</code> (::circt::hw::ArrayGetOp)</h3><p><em>Get the value in an array at the specified index</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.array_get` $input`[`$index`]` attr-dict `:` qualified(type($input)) `,` qualified(type($index))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>an ArrayType</td></tr><tr><td style=text-align:center><code>index</code></td><td>a signless integer bitvector</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a type without inout</td></tr></tbody></table><h3 id=hwarray_slice-circthwarraysliceop><code>hw.array_slice</code> (::circt::hw::ArraySliceOp)</h3><p><em>Get a range of values from an array</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.array_slice` $input`[`$lowIndex`]` attr-dict `:`
              `(` custom&lt;SliceTypes&gt;(type($input), qualified(type($lowIndex))) `)` `-&gt;` qualified(type($dst))
</code></pre><p>Extracts a sub-range from an array. The range is from <code>lowIndex</code> to
<code>lowIndex</code> + the number of elements in the return type, non-inclusive on
the high end. For instance,</p><pre tabindex=0><code>// Slices 16 elements starting at &#39;%offset&#39;.
%subArray = hw.slice %largerArray at %offset :
    (!hw.array&lt;1024xi8&gt;) -&gt; !hw.array&lt;16xi8&gt;
</code></pre><p>Would translate to the following SystemVerilog:</p><pre tabindex=0><code>logic [7:0][15:0] subArray = largerArray[offset +: 16];
</code></pre><p>Width of &lsquo;idx&rsquo; is defined to be the precise number of bits required to
index the &lsquo;input&rsquo; array. More precisely: for an input array of size M,
the width of &lsquo;idx&rsquo; is ceil(log2(M)). Lower and upper bound indexes which
are larger than the size of the &lsquo;input&rsquo; array results in undefined
behavior.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>an ArrayType</td></tr><tr><td style=text-align:center><code>lowIndex</code></td><td>a signless integer bitvector</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>an ArrayType</td></tr></tbody></table><h3 id=hwstruct_create-circthwstructcreateop><code>hw.struct_create</code> (::circt::hw::StructCreateOp)</h3><p><em>Create a struct from constituent parts.</em></p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>variadic of a type without inout</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a StructType</td></tr></tbody></table><h3 id=hwstruct_explode-circthwstructexplodeop><code>hw.struct_explode</code> (::circt::hw::StructExplodeOp)</h3><p><em>Expand a struct into its constituent parts.</em></p><pre tabindex=0><code>%result:2 = hw.struct_explode %input : !hw.struct&lt;foo: i19, bar: i7&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a StructType</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>variadic of a type without inout</td></tr></tbody></table><h3 id=hwstruct_extract-circthwstructextractop><code>hw.struct_extract</code> (::circt::hw::StructExtractOp)</h3><p><em>Extract a named field from a struct.</em></p><pre tabindex=0><code>%result = hw.struct_extract %input[&#34;field&#34;] : !hw.struct&lt;field: type&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-13>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fieldIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a StructType</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a type without inout</td></tr></tbody></table><h3 id=hwstruct_inject-circthwstructinjectop><code>hw.struct_inject</code> (::circt::hw::StructInjectOp)</h3><p><em>Inject a value into a named field of a struct.</em></p><pre tabindex=0><code>%result = hw.struct_inject %input[&#34;field&#34;], %newValue
    : !hw.struct&lt;field: type&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-14>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fieldIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a StructType</td></tr><tr><td style=text-align:center><code>newValue</code></td><td>a type without inout</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a StructType</td></tr></tbody></table><h3 id=hwunion_create-circthwunioncreateop><code>hw.union_create</code> (::circt::hw::UnionCreateOp)</h3><p><em>Create a union with the specified value.</em></p><p>Create a union with the value &lsquo;input&rsquo;, which can then be accessed via the
specified field.</p><pre tabindex=0><code>  %x = hw.constant 0 : i3
  %z = hw.union_create &#34;bar&#34;, %x : !hw.union&lt;bar: i3, baz: i8&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-15>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fieldIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a type without inout</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a UnionType</td></tr></tbody></table><h3 id=hwunion_extract-circthwunionextractop><code>hw.union_extract</code> (::circt::hw::UnionExtractOp)</h3><p><em>Get a union member.</em></p><p>Get the value of a union, interpreting it as the type of the specified
member field. Extracting a value belonging to a different field than the
union was initially created will result in undefined behavior.</p><pre tabindex=0><code>  %u = ...
  %v = hw.union_extract %u[&#34;foo&#34;] : !hw.union&lt;foo: i3, bar: i16&gt;
  // %v is of type &#39;i3&#39;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-16>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fieldIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a UnionType</td></tr></tbody></table><h4 id=results-18>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a type without inout</td></tr></tbody></table><h2 id=operation-definitions----type-declarations>Operation Definitions &ndash; Type Declarations</h2><h3 id=hwtype_scope-circthwtypescopeop><code>hw.type_scope</code> (::circt::hw::TypeScopeOp)</h3><p><em>Type declaration wrapper.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.type_scope` $sym_name $body attr-dict
</code></pre><p>An operation whose one body block contains type declarations. This op
provides a scope for type declarations at the top level of an MLIR module.
It is a symbol that may be looked up within the module, as well as a symbol
table itself, so type declarations may be looked up.</p><p>Traits: <code>Emittable</code>, <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>SingleBlock</code>, <code>SymbolTable</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-17>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=hwtypedecl-circthwtypedeclop><code>hw.typedecl</code> (::circt::hw::TypedeclOp)</h3><p><em>Type declaration.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.typedecl` $sym_name (`,` $verilogName^)? `:` $type attr-dict
</code></pre><p>Associate a symbolic name with a type.
Traits: <code>HasParent&lt;TypeScopeOp></code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-18>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>verilogName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h2 id=attribute-definitions>Attribute Definitions</h2><h3 id=enumfieldattr>EnumFieldAttr</h3><p>Enumeration field attribute</p><p>This attribute represents a field of an enumeration.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>#hw.enum.value</span><span class=p>&lt;</span>A<span class=p>,</span> <span class=p>!</span>hw<span class=p>.</span>enum<span class=p>&lt;</span>A<span class=p>,</span> B<span class=p>,</span> C<span class=p>&gt;&gt;</span>
</span></span></code></pre></div><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>field</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::TypeAttr</code></td><td></td></tr></tbody></table><h3 id=outputfileattr>OutputFileAttr</h3><p>Output file attribute</p><p>This attribute represents an output file for something which will be
printed. The <code>filename</code> string is the file to be output to. If <code>filename</code>
ends in a <code>/</code> it is considered an output directory.</p><p>When ExportVerilog runs, one of the files produced is a list of all other
files which are produced. The flag <code>excludeFromFileList</code> controls if this
file should be included in this list. If any <code>OutputFileAttr</code> referring to
the same file sets this to <code>true</code>, it will be included in the file list.
This option defaults to <code>false</code>.</p><p>For each file emitted by the verilog emitter, certain prelude output will
be included before the main content. The flag <code>includeReplicatedOps</code> can
be used to disable the addition of the prelude text. All <code>OutputFileAttr</code>s
referring to the same file must use a consistent setting for this value.
This option defaults to <code>true</code>.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>#hw.ouput_file</span><span class=p>&lt;</span><span class=s>&#34;/home/tester/t.sv&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>#hw.ouput_file</span><span class=p>&lt;</span><span class=s>&#34;t.sv&#34;</span><span class=p>,</span> excludeFromFileList<span class=p>,</span> includeReplicatedOps<span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>filename</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>excludeFromFilelist</td><td style=text-align:center><code>::mlir::BoolAttr</code></td><td></td></tr><tr><td style=text-align:center>includeReplicatedOps</td><td style=text-align:center><code>::mlir::BoolAttr</code></td><td></td></tr></tbody></table><h3 id=paramdeclattr>ParamDeclAttr</h3><p>Module or instance parameter definition</p><p>An attribute describing a module parameter, or instance parameter
specification.</p><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h3 id=paramdeclrefattr>ParamDeclRefAttr</h3><p>Is a reference to a parameter value.</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=paramexprattr>ParamExprAttr</h3><p>Parameter expression combining operands</p><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>opcode</td><td style=text-align:center><code>PEO</code></td><td></td></tr><tr><td style=text-align:center>operands</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::mlir::TypedAttr></code></td><td></td></tr><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=paramverbatimattr>ParamVerbatimAttr</h3><p>Represents text to emit directly to SystemVerilog for a parameter</p><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=innerrefattr>InnerRefAttr</h3><p>Refer to a name inside a module</p><p>This works like a symbol reference, but to a name inside a module.</p><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>moduleRef</td><td style=text-align:center><code>::mlir::FlatSymbolRefAttr</code></td><td></td></tr><tr><td style=text-align:center>name</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr></tbody></table><h2 id=type-definitions>Type Definitions</h2><h3 id=hwtype_scope-circthwtypescopeop-1><code>hw.type_scope</code> (::circt::hw::TypeScopeOp)</h3><p><em>Type declaration wrapper.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.type_scope` $sym_name $body attr-dict
</code></pre><p>An operation whose one body block contains type declarations. This op
provides a scope for type declarations at the top level of an MLIR module.
It is a symbol that may be looked up within the module, as well as a symbol
table itself, so type declarations may be looked up.</p><p>Traits: <code>Emittable</code>, <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>SingleBlock</code>, <code>SymbolTable</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-19>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=hwtypedecl-circthwtypedeclop-1><code>hw.typedecl</code> (::circt::hw::TypedeclOp)</h3><p><em>Type declaration.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.typedecl` $sym_name (`,` $verilogName^)? `:` $type attr-dict
</code></pre><p>Associate a symbolic name with a type.
Traits: <code>HasParent&lt;TypeScopeOp></code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-20>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>verilogName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=arraytype>ArrayType</h3><p>fixed-sized array</p><p>Fixed sized HW arrays are roughly similar to C arrays. On the wire (vs.
in a memory), arrays are always packed. Memory layout is not defined as
it does not need to be since in silicon there is not implicit memory
sharing.</p><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>sizeAttr</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h3 id=enumtype>EnumType</h3><p>HW Enum type</p><p>Represents an enumeration of values. Enums are interpreted as integers with
a synthesis-defined encoding.
!hw.enum&lt;field1, field2></p><h4 id=parameters-8>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>fields</td><td style=text-align:center><code>mlir::ArrayAttr</code></td><td></td></tr></tbody></table><h3 id=stringtype>StringType</h3><p>String type</p><p>Syntax: <code>!hw.string</code></p><p>Defines a string type for the hw-centric dialects</p><h3 id=inouttype>InOutType</h3><p>inout type</p><p>InOut type is used for model operations and values that have &ldquo;connection&rdquo;
semantics, instead of typical dataflow behavior. This is used for wires
and inout ports in Verilog.</p><h4 id=parameters-9>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=inttype>IntType</h3><p>parameterized-width integer</p><p>Parameterized integer types are equivalent to the MLIR standard integer
type: it is signless, and may be any width integer. This type represents
the case when the width is a parameter in the HW dialect sense.</p><h4 id=parameters-10>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>width</td><td style=text-align:center><code>::mlir::TypedAttr</code></td><td></td></tr></tbody></table><h3 id=moduletype>ModuleType</h3><p>Module Type</p><p>Module types have ports.</p><h4 id=parameters-11>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ports</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::circt::hw::ModulePort></code></td><td>port list</td></tr></tbody></table><h3 id=structtype>StructType</h3><p>HW struct type</p><p>Represents a structure of name, value pairs.
!hw.struct&lt;fieldName1: Type1, fieldName2: Type2></p><h4 id=parameters-12>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elements</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::circt::hw::StructType::FieldInfo></code></td><td>struct fields</td></tr></tbody></table><h3 id=typealiastype>TypeAliasType</h3><p>An symbolic reference to a type declaration</p><p>A TypeAlias is parameterized by a SymbolRefAttr, which points to a
TypedeclOp. The root reference should refer to a TypeScope within the same
outer ModuleOp, and the leaf reference should refer to a type within that
TypeScope. A TypeAlias is further parameterized by the inner type, which is
needed to be known at the time the type is parsed.</p><p>Upon construction, a TypeAlias stores the symbol reference and type, and
canonicalizes the type to resolve any nested type aliases. The canonical
type is also cached to avoid recomputing it when needed.</p><h4 id=parameters-13>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ref</td><td style=text-align:center><code>mlir::SymbolRefAttr</code></td><td></td></tr><tr><td style=text-align:center>innerType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>canonicalType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr></tbody></table><h3 id=uniontype>UnionType</h3><p>An untagged union of types</p><h4 id=parameters-14>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elements</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::circt::hw::UnionType::FieldInfo></code></td><td>union fields</td></tr></tbody></table><h3 id=unpackedarraytype>UnpackedArrayType</h3><p>SystemVerilog &lsquo;unpacked&rsquo; fixed-sized array</p><p>Unpacked arrays are a more flexible array representation than packed arrays,
and are typically used to model memories. See SystemVerilog Spec 7.4.2.</p><h4 id=parameters-15>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>sizeAttr</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h2 id=hwinstancelike-hwinstancelike>HWInstanceLike (<code>HWInstanceLike</code>)</h2><p>Provide common module information.</p><h3 id=methods>Methods:</h3><h2 id=hwmodulelike-hwmodulelike>HWModuleLike (<code>HWModuleLike</code>)</h2><p>Provide common module information.</p><h3 id=methods-1>Methods:</h3><h4 id=gethwmoduletype><code>getHWModuleType</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>::</span><span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>ModuleType</span> <span class=n>getHWModuleType</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the module type
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getallportattrs><code>getAllPortAttrs</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>getAllPortAttrs</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port Attributes. This will return either an empty array or an array of size numPorts.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=setallportattrs><code>setAllPortAttrs</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setAllPortAttrs</span><span class=p>(</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>attrs</span><span class=p>);</span>
</span></span></code></pre></div><p>Set the port Attributes
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=removeallportattrs><code>removeAllPortAttrs</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>removeAllPortAttrs</span><span class=p>();</span>
</span></span></code></pre></div><p>Remove the port Attributes
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getallportlocs><code>getAllPortLocs</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>SmallVector</span><span class=o>&lt;</span><span class=n>Location</span><span class=o>&gt;</span> <span class=n>getAllPortLocs</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the port Locations
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=setallportlocsattrs><code>setAllPortLocsAttrs</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setAllPortLocsAttrs</span><span class=p>(</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>locs</span><span class=p>);</span>
</span></span></code></pre></div><p>Set the port Locations
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=sethwmoduletype><code>setHWModuleType</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setHWModuleType</span><span class=p>(</span><span class=o>::</span><span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>ModuleType</span> <span class=n>type</span><span class=p>);</span>
</span></span></code></pre></div><p>Set the module type (and port names)
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=setallportnames><code>setAllPortNames</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setAllPortNames</span><span class=p>(</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>names</span><span class=p>);</span>
</span></span></code></pre></div><p>Set the port names
NOTE: This method <em>must</em> be implemented by the user.</p><h2 id=hwmutablemodulelike-hwmutablemodulelike>HWMutableModuleLike (<code>HWMutableModuleLike</code>)</h2><p>Provide methods to mutate a module.</p><h3 id=methods-2>Methods:</h3><h4 id=getportlookupinfo><code>getPortLookupInfo</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>::</span><span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>ModulePortLookupInfo</span> <span class=n>getPortLookupInfo</span><span class=p>();</span>
</span></span></code></pre></div><p>Get a handle to a utility class which provides by-name lookup of port indices. The returned object does <em>not</em> update if the module is mutated.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=modifyports><code>modifyPorts</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>modifyPorts</span><span class=p>(</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>unsigned</span><span class=p>,</span> <span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>PortInfo</span><span class=o>&gt;&gt;</span> <span class=n>insertInputs</span><span class=p>,</span> <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>unsigned</span><span class=p>,</span> <span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>PortInfo</span><span class=o>&gt;&gt;</span> <span class=n>insertOutputs</span><span class=p>,</span> <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=kt>unsigned</span><span class=o>&gt;</span> <span class=n>eraseInputs</span><span class=p>,</span> <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=kt>unsigned</span><span class=o>&gt;</span> <span class=n>eraseOutputs</span><span class=p>);</span>
</span></span></code></pre></div><p>Insert and remove input and output ports</p><h4 id=insertports><code>insertPorts</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>insertPorts</span><span class=p>(</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>unsigned</span><span class=p>,</span> <span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>PortInfo</span><span class=o>&gt;&gt;</span> <span class=n>insertInputs</span><span class=p>,</span> <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>unsigned</span><span class=p>,</span> <span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>PortInfo</span><span class=o>&gt;&gt;</span> <span class=n>insertOutputs</span><span class=p>);</span>
</span></span></code></pre></div><p>Insert ports into this module
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=eraseports><code>erasePorts</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>erasePorts</span><span class=p>(</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=kt>unsigned</span><span class=o>&gt;</span> <span class=n>eraseInputs</span><span class=p>,</span> <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=kt>unsigned</span><span class=o>&gt;</span> <span class=n>eraseOutputs</span><span class=p>);</span>
</span></span></code></pre></div><p>Erase ports from this module
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=appendoutputs><code>appendOutputs</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>appendOutputs</span><span class=p>(</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>StringAttr</span><span class=p>,</span> <span class=n>Value</span><span class=o>&gt;&gt;</span> <span class=n>outputs</span><span class=p>);</span>
</span></span></code></pre></div><p>Append output values to this module
NOTE: This method <em>must</em> be implemented by the user.</p><h2 id=innerrefuseropinterface-innerrefuseropinterface>InnerRefUserOpInterface (<code>InnerRefUserOpInterface</code>)</h2><p>This interface describes an operation that may use a <code>InnerRef</code>. This
interface allows for users of inner symbols to hook into verification and
other inner symbol related utilities that are either costly or otherwise
disallowed within a traditional operation.</p><h3 id=methods-3>Methods:</h3><h4 id=verifyinnerrefs><code>verifyInnerRefs</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>LogicalResult</span> <span class=n>verifyInnerRefs</span><span class=p>(</span><span class=o>::</span><span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>InnerRefNamespace</span><span class=o>&amp;</span><span class=n>ns</span><span class=p>);</span>
</span></span></code></pre></div><p>Verify the inner ref uses held by this operation.
NOTE: This method <em>must</em> be implemented by the user.</p><h2 id=innersymbolopinterface-innersymbol>InnerSymbolOpInterface (<code>InnerSymbol</code>)</h2><p>This interface describes an operation that may define an
<code>inner_sym</code>. An <code>inner_sym</code> operation resides
in arbitrarily-nested regions of a region that defines a
<code>InnerSymbolTable</code>.
Inner Symbols are different from normal symbols due to
MLIR symbol table resolution rules. Specifically normal
symbols are resolved by first going up to the closest
parent symbol table and resolving from there (recursing
down for complex symbol paths). In HW and SV, modules
define a symbol in a circuit or std.module symbol table.
For instances to be able to resolve the modules they
instantiate, the symbol use in an instance must resolve
in the top-level symbol table. If a module were a
symbol table, instances resolving a symbol would start from
their own module, never seeing other modules (since
resolution would start in the parent module of the
instance and be unable to go to the global scope).
The second problem arises from nesting. Symbols defining
ops must be immediate children of a symbol table. HW
and SV operations which define a inner_sym are grandchildren,
at least, of a symbol table and may be much further nested.
Lastly, ports need to define inner_sym, something not allowed
by normal symbols.</p><p>Any operation implementing an InnerSymbol may have the inner symbol be
optional and all methods should be robuse to the attribute not being
defined.</p><h3 id=methods-4>Methods:</h3><h4 id=getinnernameattr><code>getInnerNameAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>StringAttr</span> <span class=n>getInnerNameAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Returns the name of the top-level inner symbol defined by this operation, if present.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getinnername><code>getInnerName</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>::</span><span class=n>std</span><span class=o>::</span><span class=n>optional</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>StringRef</span><span class=o>&gt;</span> <span class=n>getInnerName</span><span class=p>();</span>
</span></span></code></pre></div><p>Returns the name of the top-level inner symbol defined by this operation, if present.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=setinnersymbol><code>setInnerSymbol</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setInnerSymbol</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>StringAttr</span> <span class=n>name</span><span class=p>);</span>
</span></span></code></pre></div><p>Sets the name of the top-level inner symbol defined by this operation to the specified string, dropping any symbols on fields.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=setinnersymbolattr><code>setInnerSymbolAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>setInnerSymbolAttr</span><span class=p>(</span><span class=o>::</span><span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>InnerSymAttr</span> <span class=n>sym</span><span class=p>);</span>
</span></span></code></pre></div><p>Sets the inner symbols defined by this operation.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getinnerref><code>getInnerRef</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>::</span><span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>InnerRefAttr</span> <span class=n>getInnerRef</span><span class=p>();</span>
</span></span></code></pre></div><p>Returns an InnerRef to this operation&rsquo;s top-level inner symbol, which must be present.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getinnersymattr><code>getInnerSymAttr</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>::</span><span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>InnerSymAttr</span> <span class=n>getInnerSymAttr</span><span class=p>();</span>
</span></span></code></pre></div><p>Returns the InnerSymAttr representing all inner symbols defined by this operation.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=supportsperfieldsymbols><code>supportsPerFieldSymbols</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=nf>supportsPerFieldSymbols</span><span class=p>();</span>
</span></span></code></pre></div><p>Returns whether per-field symbols are supported for this operation type.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=gettargetresultindex><code>getTargetResultIndex</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>static</span> <span class=n>std</span><span class=o>::</span><span class=n>optional</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span> <span class=n>getTargetResultIndex</span><span class=p>();</span>
</span></span></code></pre></div><p>Returns the index of the result the innner symbol targets, if applicable. Per-field symbols are resolved into this.
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=gettargetresult><code>getTargetResult</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>OpResult</span> <span class=nf>getTargetResult</span><span class=p>();</span>
</span></span></code></pre></div><p>Returns the result the innner symbol targets, if applicable. Per-field symbols are resolved into this.
NOTE: This method <em>must</em> be implemented by the user.</p><h2 id=portlist-portlist>PortList (<code>PortList</code>)</h2><p>Operations which produce a unified port list representation</p><h3 id=methods-5>Methods:</h3><h4 id=getportlist><code>getPortList</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>SmallVector</span><span class=o>&lt;::</span><span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>PortInfo</span><span class=o>&gt;</span> <span class=n>getPortList</span><span class=p>();</span>
</span></span></code></pre></div><p>Get port list
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getport><code>getPort</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>::</span><span class=n>circt</span><span class=o>::</span><span class=n>hw</span><span class=o>::</span><span class=n>PortInfo</span> <span class=n>getPort</span><span class=p>(</span><span class=n>size_t</span> <span class=n>idx</span><span class=p>);</span>
</span></span></code></pre></div><p>Get port list
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportidforinputid><code>getPortIdForInputId</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>size_t</span> <span class=nf>getPortIdForInputId</span><span class=p>(</span><span class=n>size_t</span> <span class=n>idx</span><span class=p>);</span>
</span></span></code></pre></div><p>Get the port a specific input
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getportidforoutputid><code>getPortIdForOutputId</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>size_t</span> <span class=nf>getPortIdForOutputId</span><span class=p>(</span><span class=n>size_t</span> <span class=n>idx</span><span class=p>);</span>
</span></span></code></pre></div><p>Get the port a specific output
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getnumports><code>getNumPorts</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>size_t</span> <span class=nf>getNumPorts</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the number of ports
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getnuminputports><code>getNumInputPorts</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>size_t</span> <span class=nf>getNumInputPorts</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the number of input ports
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getnumoutputports><code>getNumOutputPorts</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>size_t</span> <span class=nf>getNumOutputPorts</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the number of output ports
NOTE: This method <em>must</em> be implemented by the user.</p><h2 id=fieldidtypeinterface-fieldidtypeinterface>FieldIDTypeInterface (<code>FieldIDTypeInterface</code>)</h2><p>Common methods for types which can be indexed by a FieldID.
FieldID is a depth-first numbering of the elements of a type. For example:</p><pre tabindex=0><code>struct a  /* 0 */ {
  int b; /* 1 */
  struct c /* 2 */ {
    int d; /* 3 */
  }
}

int e; /* 0 */
</code></pre><h3 id=methods-6>Methods:</h3><h4 id=getmaxfieldid><code>getMaxFieldID</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=nf>getMaxFieldID</span><span class=p>();</span>
</span></span></code></pre></div><p>Get the maximum field ID for this type
NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getsubtypebyfieldid><code>getSubTypeByFieldID</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Type</span><span class=p>,</span> <span class=kt>uint64_t</span><span class=o>&gt;</span> <span class=n>getSubTypeByFieldID</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>fieldID</span><span class=p>);</span>
</span></span></code></pre></div><p>Get the sub-type of a type for a field ID, and the subfield&rsquo;s ID. Strip
off a single layer of this type and return the sub-type and a field ID
targeting the same field, but rebased on the sub-type.</p><p>The resultant type <em>may</em> not be a FieldIDTypeInterface if the resulting
fieldID is zero. This means that leaf types may be ground without
implementing an interface. An empty aggregate will also appear as a
zero.</p><p>NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=projecttochildfieldid><code>projectToChildFieldID</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=p>,</span> <span class=kt>bool</span><span class=o>&gt;</span> <span class=n>projectToChildFieldID</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>fieldID</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>index</span><span class=p>);</span>
</span></span></code></pre></div><p>Returns the effective field id when treating the index field as the
root of the type. Essentially maps a fieldID to a fieldID after a
subfield op. Returns the new id and whether the id is in the given
child.</p><p>NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getindexforfieldid><code>getIndexForFieldID</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=nf>getIndexForFieldID</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>fieldID</span><span class=p>);</span>
</span></span></code></pre></div><p>Returns the index (e.g. struct or vector element) for a given FieldID.
This returns the containing index in the case that the fieldID points to a
child field of a field.</p><p>NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getfieldid><code>getFieldID</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=nf>getFieldID</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>index</span><span class=p>);</span>
</span></span></code></pre></div><p>Return the fieldID of a given index (e.g. struct or vector element).
Field IDs start at 1, and are assigned
to each field in a recursive depth-first walk of all
elements. A field ID of 0 is used to reference the type itself.</p><p>NOTE: This method <em>must</em> be implemented by the user.</p><h4 id=getindexandsubfieldid><code>getIndexAndSubfieldID</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>uint64_t</span><span class=p>,</span> <span class=kt>uint64_t</span><span class=o>&gt;</span> <span class=n>getIndexAndSubfieldID</span><span class=p>(</span><span class=kt>uint64_t</span> <span class=n>fieldID</span><span class=p>);</span>
</span></span></code></pre></div><p>Find the index of the element that contains the given fieldID.
As well, rebase the fieldID to the element.</p><p>NOTE: This method <em>must</em> be implemented by the user.</p><h2>'hw' Dialect Docs</h2><ul><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/ title="Handshake Dialect Rationale"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Handshake Dialect Rationale</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/ title="HW Dialect Rationale">Next - HW Dialect Rationale <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class="active has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>