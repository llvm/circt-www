<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'hw' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/HW/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'hw' Dialect</h1><p>Types and operations for the hardware dialect
This dialect defines the <code>hw</code> dialect, which is intended to be a generic
representation of HW outside of a particular use-case.</p><p><nav id=TableOfContents><ul><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#hwarray_concat-circthwarrayconcatop><code>hw.array_concat</code> (::circt::hw::ArrayConcatOp)</a></li><li><a href=#hwarray_create-circthwarraycreateop><code>hw.array_create</code> (::circt::hw::ArrayCreateOp)</a></li><li><a href=#hwarray_get-circthwarraygetop><code>hw.array_get</code> (::circt::hw::ArrayGetOp)</a></li><li><a href=#hwarray_slice-circthwarraysliceop><code>hw.array_slice</code> (::circt::hw::ArraySliceOp)</a></li><li><a href=#hwbitcast-circthwbitcastop><code>hw.bitcast</code> (::circt::hw::BitcastOp)</a></li><li><a href=#hwconstant-circthwconstantop><code>hw.constant</code> (::circt::hw::ConstantOp)</a></li><li><a href=#hwenumconstant-circthwenumconstantop><code>hw.enum.constant</code> (::circt::hw::EnumConstantOp)</a></li><li><a href=#hwglobalref-circthwglobalrefop><code>hw.globalRef</code> (::circt::hw::GlobalRefOp)</a></li><li><a href=#hwgeneratorschema-circthwhwgeneratorschemaop><code>hw.generator.schema</code> (::circt::hw::HWGeneratorSchemaOp)</a></li><li><a href=#hwmoduleextern-circthwhwmoduleexternop><code>hw.module.extern</code> (::circt::hw::HWModuleExternOp)</a></li><li><a href=#hwmodulegenerated-circthwhwmodulegeneratedop><code>hw.module.generated</code> (::circt::hw::HWModuleGeneratedOp)</a></li><li><a href=#hwmodule-circthwhwmoduleop><code>hw.module</code> (::circt::hw::HWModuleOp)</a></li><li><a href=#hwinstance-circthwinstanceop><code>hw.instance</code> (::circt::hw::InstanceOp)</a></li><li><a href=#hwoutput-circthwoutputop><code>hw.output</code> (::circt::hw::OutputOp)</a></li><li><a href=#hwparamvalue-circthwparamvalueop><code>hw.param.value</code> (::circt::hw::ParamValueOp)</a></li><li><a href=#hwprobe-circthwprobeop><code>hw.probe</code> (::circt::hw::ProbeOp)</a></li><li><a href=#hwstruct_create-circthwstructcreateop><code>hw.struct_create</code> (::circt::hw::StructCreateOp)</a></li><li><a href=#hwstruct_explode-circthwstructexplodeop><code>hw.struct_explode</code> (::circt::hw::StructExplodeOp)</a></li><li><a href=#hwstruct_extract-circthwstructextractop><code>hw.struct_extract</code> (::circt::hw::StructExtractOp)</a></li><li><a href=#hwstruct_inject-circthwstructinjectop><code>hw.struct_inject</code> (::circt::hw::StructInjectOp)</a></li><li><a href=#hwtype_scope-circthwtypescopeop><code>hw.type_scope</code> (::circt::hw::TypeScopeOp)</a></li><li><a href=#hwtypedecl-circthwtypedeclop><code>hw.typedecl</code> (::circt::hw::TypedeclOp)</a></li><li><a href=#hwunion_create-circthwunioncreateop><code>hw.union_create</code> (::circt::hw::UnionCreateOp)</a></li><li><a href=#hwunion_extract-circthwunionextractop><code>hw.union_extract</code> (::circt::hw::UnionExtractOp)</a></li></ul></li><li><a href=#attribute-definition>Attribute definition</a><ul><li><a href=#enumfieldattr>EnumFieldAttr</a></li><li><a href=#filelistattr>FileListAttr</a></li><li><a href=#globalrefattr>GlobalRefAttr</a></li><li><a href=#innerrefattr>InnerRefAttr</a></li><li><a href=#outputfileattr>OutputFileAttr</a></li><li><a href=#paramdeclattr>ParamDeclAttr</a></li><li><a href=#paramdeclrefattr>ParamDeclRefAttr</a></li><li><a href=#paramexprattr>ParamExprAttr</a></li><li><a href=#paramverbatimattr>ParamVerbatimAttr</a></li></ul></li><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#an-arraytype>an ArrayType</a></li><li><a href=#a-enumtype>a EnumType</a></li><li><a href=#an-integer-bitvector-of-one-or-more-bits>an integer bitvector of one or more bits</a></li><li><a href=#a-type-without-inout>a type without inout</a></li><li><a href=#a-known-primitive-element>a known primitive element</a></li><li><a href=#inouttype>InOutType</a></li><li><a href=#a-structtype>a StructType</a></li><li><a href=#a-uniontype>a UnionType</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#arraytype>ArrayType</a></li><li><a href=#enumtype>EnumType</a></li><li><a href=#inouttype-1>InOutType</a></li><li><a href=#inttype>IntType</a></li><li><a href=#structtype>StructType</a></li><li><a href=#typealiastype>TypeAliasType</a></li><li><a href=#uniontype>UnionType</a></li><li><a href=#unpackedarraytype>UnpackedArrayType</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition</h2><h3 id=hwarray_concat-circthwarrayconcatop><code>hw.array_concat</code> (::circt::hw::ArrayConcatOp)</h3><p>Concatenate some arrays</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.array_concat` $inputs attr-dict `:` custom&lt;ArrayConcatTypes&gt;(type($inputs), qualified(type($result)))
</code></pre><p>Creates an array by concatenating a variable set of arrays. One or more
values must be listed.</p><pre tabindex=0><code>// %a, %b, %c are hw arrays of i4 with sizes 2, 5, and 4 respectively.
%array = hw.array_concat %a, %b, %c : (2, 5, 4 x i4)
// %array is !hw.array&lt;11 x i4&gt;
</code></pre><p>See the HW-SV rationale document for details on operand ordering.</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>an ArrayType</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>an ArrayType</td></tr></tbody></table><h3 id=hwarray_create-circthwarraycreateop><code>hw.array_create</code> (::circt::hw::ArrayCreateOp)</h3><p>Create an array from values</p><p>Creates an array from a variable set of values. One or more values must be
listed.</p><pre tabindex=0><code>// %a, %b, %c are all i4
%array = hw.array_create %a, %b, %c : i4
</code></pre><p>See the HW-SV rationale document for details on operand ordering.</p><p>Traits: SameTypeOperands</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>a type without inout</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>an ArrayType</td></tr></tbody></table><h3 id=hwarray_get-circthwarraygetop><code>hw.array_get</code> (::circt::hw::ArrayGetOp)</h3><p>Get the value in an array at the specified index</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.array_get` $input`[`$index`]` attr-dict `:` qualified(type($input))
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>an ArrayType</td></tr><tr><td style=text-align:center><code>index</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a type without inout</td></tr></tbody></table><h3 id=hwarray_slice-circthwarraysliceop><code>hw.array_slice</code> (::circt::hw::ArraySliceOp)</h3><p>Get a range of values from an array</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.array_slice` $input`[`$lowIndex`]` attr-dict `:`
              `(` custom&lt;SliceTypes&gt;(type($input), qualified(type($lowIndex))) `)` `-&gt;` qualified(type($dst))
</code></pre><p>Extracts a sub-range from an array. The range is from <code>lowIndex</code> to
<code>lowIndex</code> + the number of elements in the return type, non-inclusive on
the high end. For instance,</p><pre tabindex=0><code>// Slices 16 elements starting at &#39;%offset&#39;.
%subArray = hw.slice %largerArray at %offset :
    (!hw.array&lt;1024xi8&gt;) -&gt; !hw.array&lt;16xi8&gt;
</code></pre><p>Would translate to the following SystemVerilog:</p><pre tabindex=0><code>logic [7:0][15:0] subArray = largerArray[offset +: 16];
</code></pre><p>Width of &lsquo;idx&rsquo; is defined to be the precise number of bits required to
index the &lsquo;input&rsquo; array. More precisely: for an input array of size M,
the width of &lsquo;idx&rsquo; is ceil(log2(M)). Lower and upper bound indexes which
are larger than the size of the &lsquo;input&rsquo; array results in undefined
behavior.</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>an ArrayType</td></tr><tr><td style=text-align:center><code>lowIndex</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>an ArrayType</td></tr></tbody></table><h3 id=hwbitcast-circthwbitcastop><code>hw.bitcast</code> (::circt::hw::BitcastOp)</h3><pre><code>Reinterpret one value to another value of the same size and
potentially different type.  See the `hw` dialect rationale document for
more details.
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.bitcast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>Type wherein the bitwidth in hardware is known</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Type wherein the bitwidth in hardware is known</td></tr></tbody></table><h3 id=hwconstant-circthwconstantop><code>hw.constant</code> (::circt::hw::ConstantOp)</h3><p>Produce a constant value</p><p>The constant operation produces a constant value of standard integer type
without a sign.</p><pre tabindex=0><code>  %result = hw.constant 42 : t1
</code></pre><p>Traits: ConstantLike, FirstAttrDerivedResultType</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface), OpAsmOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=hwenumconstant-circthwenumconstantop><code>hw.enum.constant</code> (::circt::hw::EnumConstantOp)</h3><p>Produce a constant enumeration value.</p><p>The enum.constant operation produces an enumeration value of the specified
enum value attribute.</p><pre tabindex=0><code>  %0 = hw.enum.constant A : !hw.enum&lt;A, B, C&gt;
</code></pre><p>Traits: ConstantLike</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface), OpAsmOpInterface</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-1>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>field</code></td><td style=text-align:center>::circt::hw::EnumFieldAttr</td><td>Enumeration field attribute</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a EnumType</td></tr></tbody></table><h3 id=hwglobalref-circthwglobalrefop><code>hw.globalRef</code> (::circt::hw::GlobalRefOp)</h3><p>A global reference to uniquely identify eachinstance of an operation</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.globalRef` $sym_name $namepath attr-dict
</code></pre><p>This works like a symbol reference to an operation by specifying the
instance path to uniquely identify it globally.
It can be used to attach per instance metadata (non-local attributes).
This also lets components of the path point to a common entity.</p><p>Traits: IsolatedFromAbove</p><p>Interfaces: Symbol, SymbolUserOpInterface</p><h4 id=attributes-2>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>namepath</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></tbody></table><h3 id=hwgeneratorschema-circthwhwgeneratorschemaop><code>hw.generator.schema</code> (::circt::hw::HWGeneratorSchemaOp)</h3><p>HW Generator Schema declaration</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.generator.schema` $sym_name `,` $descriptor `,` $requiredAttrs attr-dict
</code></pre><p>The &ldquo;hw.generator.schema&rdquo; operation declares a kind of generated module by
declaring the schema of meta-data required.
A generated module instance of a schema is independent of the external
method of producing it. It is assumed that for well known schema instances,
multiple external tools might exist which can process it. Generator nodes
list attributes required by hw.module.generated instances.</p><p>For example:
generator.schema @MEMORY, &ldquo;Simple-Memory&rdquo;, [&ldquo;ports&rdquo;, &ldquo;write_latency&rdquo;, &ldquo;read_latency&rdquo;]
module.generated @mymem, @MEMORY(ports)
-> (ports) {write_latency=1, read_latency=1, ports=[&ldquo;read&rdquo;,&ldquo;write&rdquo;]}</p><p>Traits: HasParent
<a href=mlir::ModuleOp>mlir::ModuleOp</a></p><p>Interfaces: Symbol</p><h4 id=attributes-3>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>descriptor</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>requiredAttrs</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr></tbody></table><h3 id=hwmoduleextern-circthwhwmoduleexternop><code>hw.module.extern</code> (::circt::hw::HWModuleExternOp)</h3><p>HW external Module</p><p>The &ldquo;hw.module.extern&rdquo; operation represents an external reference to a
Verilog module, including a given name and a list of ports.</p><p>The &lsquo;verilogName&rsquo; attribute (when present) specifies the spelling of the
module name in Verilog we can use. TODO: This is a hack because we don&rsquo;t
have proper parameterization in the hw.dialect. We need a way to represent
parameterized types instead of just concrete types.</p><p>Traits: HasParent
<a href=mlir::ModuleOp>mlir::ModuleOp</a></p><p>Interfaces: FunctionOpInterface, HWModuleLike, OpAsmOpInterface, Symbol</p><h4 id=attributes-4>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>argNames</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td style=text-align:center><code>resultNames</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td style=text-align:center><code>parameters</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td style=text-align:center><code>verilogName</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=hwmodulegenerated-circthwhwmodulegeneratedop><code>hw.module.generated</code> (::circt::hw::HWModuleGeneratedOp)</h3><p>HW Generated Module</p><p>The &ldquo;hw.module.generated&rdquo; operation represents a reference to an external
module that will be produced by some external process.
This represents the name and list of ports to be generated.</p><p>The &lsquo;verilogName&rsquo; attribute (when present) specifies the spelling of the
module name in Verilog we can use. See hw.module for an explanation.</p><p>Traits: HasParent
<a href=mlir::ModuleOp>mlir::ModuleOp</a>, IsolatedFromAbove</p><p>Interfaces: FunctionOpInterface, HWModuleLike, OpAsmOpInterface, Symbol, SymbolUserOpInterface</p><h4 id=attributes-5>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>generatorKind</code></td><td style=text-align:center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td style=text-align:center><code>argNames</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td style=text-align:center><code>resultNames</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td style=text-align:center><code>parameters</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td style=text-align:center><code>verilogName</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=hwmodule-circthwhwmoduleop><code>hw.module</code> (::circt::hw::HWModuleOp)</h3><p>HW Module</p><p>The &ldquo;hw.module&rdquo; operation represents a Verilog module, including a given
name, a list of ports, a list of parameters, and a body that represents the
connections within the module.</p><p>Traits: HasParent
<a href=mlir::ModuleOp>mlir::ModuleOp</a>, IsolatedFromAbove, SingleBlockImplicitTerminator<outputop></p><p>Interfaces: FunctionOpInterface, HWModuleLike, OpAsmOpInterface, RegionKindInterface, Symbol</p><h4 id=attributes-6>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>argNames</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td style=text-align:center><code>resultNames</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td style=text-align:center><code>parameters</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td style=text-align:center><code>comment</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=hwinstance-circthwinstanceop><code>hw.instance</code> (::circt::hw::InstanceOp)</h3><p>Create an instance of a module</p><p>This represents an instance of a module. The inputs and results are
the referenced module&rsquo;s inputs and outputs. The <code>argNames</code> and
<code>resultNames</code> attributes must match the referenced module.</p><p>Any parameters in the &ldquo;old&rdquo; format (slated to be removed) are stored in the
<code>oldParameters</code> dictionary.</p><p>Interfaces: HWInstanceLike, OpAsmOpInterface, SymbolUserOpInterface</p><h4 id=attributes-7>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>instanceName</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>moduleName</code></td><td style=text-align:center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td style=text-align:center><code>argNames</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td style=text-align:center><code>resultNames</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td style=text-align:center><code>parameters</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>parameter array attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>any type</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>any type</td></tr></tbody></table><h3 id=hwoutput-circthwoutputop><code>hw.output</code> (::circt::hw::OutputOp)</h3><p>HW termination operation</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.output` attr-dict ($operands^ `:` qualified(type($operands)))?
</code></pre><p>&ldquo;hw.output&rdquo; marks the end of a region in the HW dialect and the values
to put on the output ports.</p><p>Traits: HasParent<hwmoduleop>, ReturnLike, Terminator</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=hwparamvalue-circthwparamvalueop><code>hw.param.value</code> (::circt::hw::ParamValueOp)</h3><pre><code>Return the value of a parameter expression as an SSA value that may be used
by other ops.
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.param.value` custom&lt;ParamValue&gt;($value, qualified(type($result))) attr-dict
</code></pre><p>Traits: ConstantLike, FirstAttrDerivedResultType</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-8>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td style=text-align:center>::mlir::Attribute</td><td>any attribute</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element</td></tr></tbody></table><h3 id=hwprobe-circthwprobeop><code>hw.probe</code> (::circt::hw::ProbeOp)</h3><p>Probe values for use in remote references</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.probe` $inner_sym attr-dict (`,` $operands^ `:` qualified(type($operands)))?
</code></pre><p>Captures values without binding to any accidental name. This allows
capturing names holding values of interest while allowing the name to
resolved only at emission time.</p><h4 id=attributes-9>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=hwstruct_create-circthwstructcreateop><code>hw.struct_create</code> (::circt::hw::StructCreateOp)</h3><p>Create a struct from constituent parts.</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a type without inout</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a StructType</td></tr></tbody></table><h3 id=hwstruct_explode-circthwstructexplodeop><code>hw.struct_explode</code> (::circt::hw::StructExplodeOp)</h3><p>Expand a struct into its constituent parts.</p><pre tabindex=0><code>%result:2 = hw.struct_explode %input : !hw.struct&lt;foo: i19, bar: i7&gt;
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a StructType</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a type without inout</td></tr></tbody></table><h3 id=hwstruct_extract-circthwstructextractop><code>hw.struct_extract</code> (::circt::hw::StructExtractOp)</h3><p>Extract a named field from a struct.</p><pre tabindex=0><code>%result = hw.struct_extract %input[&#34;field&#34;] : !hw.struct&lt;field: type&gt;
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-10>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>field</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a StructType</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a type without inout</td></tr></tbody></table><h3 id=hwstruct_inject-circthwstructinjectop><code>hw.struct_inject</code> (::circt::hw::StructInjectOp)</h3><p>Inject a value into a named field of a struct.</p><pre tabindex=0><code>%result = hw.struct_inject %input[&#34;field&#34;], %newValue
    : !hw.struct&lt;field: type&gt;
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-11>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>field</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a StructType</td></tr><tr><td style=text-align:center><code>newValue</code></td><td>a type without inout</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a StructType</td></tr></tbody></table><h3 id=hwtype_scope-circthwtypescopeop><code>hw.type_scope</code> (::circt::hw::TypeScopeOp)</h3><p>Type declaration wrapper.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.type_scope` $sym_name $body attr-dict
</code></pre><p>An operation whose one body block contains type declarations. This op
provides a scope for type declarations at the top level of an MLIR module.
It is a symbol that may be looked up within the module, as well as a symbol
table itself, so type declarations may be looked up.</p><p>Traits: NoRegionArguments, NoTerminator, SingleBlock, SymbolTable</p><p>Interfaces: Symbol</p><h4 id=attributes-12>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=hwtypedecl-circthwtypedeclop><code>hw.typedecl</code> (::circt::hw::TypedeclOp)</h3><p>Type declaration.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `hw.typedecl` $sym_name (`,` $verilogName^)? `:` $type attr-dict
</code></pre><p>Associate a symbolic name with a type.
Traits: HasParent<typescopeop></p><p>Interfaces: Symbol</p><h4 id=attributes-13>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>type</code></td><td style=text-align:center>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td style=text-align:center><code>verilogName</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=hwunion_create-circthwunioncreateop><code>hw.union_create</code> (::circt::hw::UnionCreateOp)</h3><p>Create a union with the specified value.</p><p>Create a union with the value &lsquo;input&rsquo;, which can then be accessed via the
specified field.</p><pre tabindex=0><code>  %x = hw.constant 0 : i3
  %z = hw.union_create &#34;bar&#34;, %x : !hw.union&lt;bar: i3, baz: i8&gt;
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-14>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>field</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a type without inout</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a UnionType</td></tr></tbody></table><h3 id=hwunion_extract-circthwunionextractop><code>hw.union_extract</code> (::circt::hw::UnionExtractOp)</h3><p>Get a union member.</p><p>Get the value of a union, interpreting it as the type of the specified
member field. Extracting a value belonging to a different field than the
union was initially created will result in undefined behavior.</p><pre tabindex=0><code>  %u = ...
  %v = hw.union_extract %u[&#34;foo&#34;] : !hw.union&lt;foo: i3, bar: i16&gt;
  // %v is of type &#39;i3&#39;
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-15>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>field</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a UnionType</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a type without inout</td></tr></tbody></table><h2 id=attribute-definition>Attribute definition</h2><h3 id=enumfieldattr>EnumFieldAttr</h3><p>Enumeration field attribute</p><p>This attribute represents a field of an enumeration.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>#hw.enum.value</span><span class=p>&lt;</span>A<span class=p>,</span> <span class=p>!</span>hw<span class=p>.</span>enum<span class=p>&lt;</span>A<span class=p>,</span> B<span class=p>,</span> C<span class=p>&gt;&gt;</span>
</span></span></code></pre></div><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>field</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::TypeAttr</code></td><td></td></tr></tbody></table><h3 id=filelistattr>FileListAttr</h3><p>Ouput filelist attribute</p><p>Syntax:</p><pre tabindex=0><code>!hw.output_filelist&lt;
  ::mlir::StringAttr   # filename
&gt;
</code></pre><p>This attribute represents an output filelist for something which will be
printed. The <code>filename</code> string is the file which the filename of the
operation to be output to.</p><p>When ExportVerilog runs, some of the files produced are lists of other files
which are produced. Each filelist exported contains entities&rsquo; output file
with <code>FileListAttr</code> marked.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>#hw.ouput_filelist</span><span class=p>&lt;</span><span class=s>&#34;/home/tester/t.F&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>#hw.ouput_filelist</span><span class=p>&lt;</span><span class=s>&#34;t.f&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>filename</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr></tbody></table><h3 id=globalrefattr>GlobalRefAttr</h3><p>Refer to a non-local symbol</p><p>Syntax:</p><pre tabindex=0><code>!hw.globalNameRef&lt;
  ::mlir::FlatSymbolRefAttr   # glblSym
&gt;
</code></pre><p>This works like a symbol reference, but to a global symbol with a possible
unique instance path.</p><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>glblSym</td><td style=text-align:center><code>::mlir::FlatSymbolRefAttr</code></td><td></td></tr></tbody></table><h3 id=innerrefattr>InnerRefAttr</h3><p>Refer to a name inside a module</p><p>This works like a symbol reference, but to a name inside a module.</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>moduleRef</td><td style=text-align:center><code>::mlir::FlatSymbolRefAttr</code></td><td></td></tr><tr><td style=text-align:center>name</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr></tbody></table><h3 id=outputfileattr>OutputFileAttr</h3><p>Ouput file attribute</p><p>This attribute represents an output file for something which will be
printed. The <code>filename</code> string is the file to be output to. If <code>filename</code>
ends in a <code>/</code> it is considered an output directory.</p><p>When ExportVerilog runs, one of the files produced is a list of all other
files which are produced. The flag <code>excludeFromFileList</code> controls if this
file should be included in this list. If any <code>OutputFileAttr</code> referring to
the same file sets this to <code>true</code>, it will be included in the file list.
This option defaults to <code>false</code>.</p><p>For each file emitted by the verilog emitter, certain prelude output will
be included before the main content. The flag <code>includeReplicatedOps</code> can
be used to disable the addition of the prelude text. All <code>OutputFileAttr</code>s
referring to the same file must use a consistent setting for this value.
This option defaults to <code>true</code>.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>#hw.ouput_file</span><span class=p>&lt;</span><span class=s>&#34;/home/tester/t.sv&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>#hw.ouput_file</span><span class=p>&lt;</span><span class=s>&#34;t.sv&#34;</span><span class=p>,</span> excludeFromFileList<span class=p>,</span> includeReplicatedOps<span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>filename</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>excludeFromFilelist</td><td style=text-align:center><code>::mlir::BoolAttr</code></td><td></td></tr><tr><td style=text-align:center>includeReplicatedOps</td><td style=text-align:center><code>::mlir::BoolAttr</code></td><td></td></tr></tbody></table><h3 id=paramdeclattr>ParamDeclAttr</h3><p>Module or instance parameter definition</p><p>An attribute describing a module parameter, or instance parameter
specification.</p><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::TypeAttr</code></td><td></td></tr><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h3 id=paramdeclrefattr>ParamDeclRefAttr</h3><p>Is a reference to a parameter value.</p><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=paramexprattr>ParamExprAttr</h3><p>Parameter expression combining operands</p><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>opcode</td><td style=text-align:center><code>PEO</code></td><td></td></tr><tr><td style=text-align:center>operands</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::mlir::Attribute></code></td><td></td></tr><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=paramverbatimattr>ParamVerbatimAttr</h3><p>Represents text to emit directly to SystemVerilog for a parameter</p><h4 id=parameters-8>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h2 id=type-constraint-definition>Type constraint definition</h2><h3 id=an-arraytype>an ArrayType</h3><h3 id=a-enumtype>a EnumType</h3><h3 id=an-integer-bitvector-of-one-or-more-bits>an integer bitvector of one or more bits</h3><h3 id=a-type-without-inout>a type without inout</h3><h3 id=a-known-primitive-element>a known primitive element</h3><h3 id=inouttype>InOutType</h3><h3 id=a-structtype>a StructType</h3><h3 id=a-uniontype>a UnionType</h3><h2 id=type-definition>Type definition</h2><h3 id=arraytype>ArrayType</h3><p>fixed-sized array</p><p>Fixed sized HW arrays are roughly similar to C arrays. On the wire (vs.
in a memory), arrays are always packed. Memory layout is not defined as
it does not need to be since in silicon there is not implicit memory
sharing.</p><h4 id=parameters-9>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>sizeAttr</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h3 id=enumtype>EnumType</h3><p>HW Enum type</p><p>Represents an enumeration of values. Enums are interpreted as integers with
a synthesis-defined encoding.
!hw.enum&lt;field1, field2></p><h4 id=parameters-10>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>fields</td><td style=text-align:center><code>mlir::ArrayAttr</code></td><td></td></tr></tbody></table><h3 id=inouttype-1>InOutType</h3><p>inout type</p><p>InOut type is used for model operations and values that have &ldquo;connection&rdquo;
semantics, instead of typical dataflow behavior. This is used for wires
and inout ports in Verilog.</p><h4 id=parameters-11>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=inttype>IntType</h3><p>parameterized-width integer</p><p>Parameterized integer types are equivalent to the MLIR standard integer
type: it is signless, and may be any width integer. This type represents
the case when the width is a parameter in the HW dialect sense.</p><h4 id=parameters-12>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>width</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h3 id=structtype>StructType</h3><p>HW struct type</p><p>Represents a structure of name, value pairs.
!hw.struct&lt;fieldName1: Type1, fieldName2: Type2></p><h4 id=parameters-13>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elements</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::circt::hw::StructType::FieldInfo></code></td><td>struct fields</td></tr></tbody></table><h3 id=typealiastype>TypeAliasType</h3><p>An symbolic reference to a type declaration</p><p>A TypeAlias is parameterized by a SymbolRefAttr, which points to a
TypedeclOp. The root reference should refer to a TypeScope within the same
outer ModuleOp, and the leaf reference should refer to a type within that
TypeScope. A TypeAlias is further parameterized by the inner type, which is
needed to be known at the time the type is parsed.</p><p>Upon construction, a TypeAlias stores the symbol reference and type, and
canonicalizes the type to resolve any nested type aliases. The canonical
type is also cached to avoid recomputing it when needed.</p><h4 id=parameters-14>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ref</td><td style=text-align:center><code>mlir::SymbolRefAttr</code></td><td></td></tr><tr><td style=text-align:center>innerType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>canonicalType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr></tbody></table><h3 id=uniontype>UnionType</h3><p>An untagged union of types</p><h4 id=parameters-15>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elements</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::circt::hw::UnionType::FieldInfo></code></td><td>union fields</td></tr></tbody></table><h3 id=unpackedarraytype>UnpackedArrayType</h3><p>SystemVerilog &lsquo;unpacked&rsquo; fixed-sized array</p><p>Unpacked arrays are a more flexible array representation than packed arrays,
and are typically used to model memories. See SystemVerilog Spec 7.4.2.</p><h4 id=parameters-16>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>sizeAttr</td><td style=text-align:center><code>::mlir::Attribute</code></td><td></td></tr></tbody></table><h2>'hw' Dialect Docs</h2><ul><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/ title="Handshake Dialect Rationale"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Handshake Dialect Rationale</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/ title="HW Dialect Rationale">Next - HW Dialect Rationale <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class="active has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li></ul></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/>PyCDE</a></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>