<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>HW Arith Dialect Rationale - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>HW Arith Dialect Rationale</h1><p>This document describes the various design points of the HWArith dialect, a
dialect that is used to represent bitwidth extending arithmetic. This follows in the
spirit of other
<a href=https://mlir.llvm.org/docs/Rationale/>MLIR Rationale docs</a>.</p><ul><li><a href=#hw-arith-dialect-rationale>HW Arith Dialect Rationale</a><ul><li><a href=#introduction>Introduction</a><ul><li><a href=#qa>Q&A</a></li></ul></li><li><a href=#bit-width-rules>Bit Width Rules</a></li><li><a href=#lowering>Lowering</a></li></ul></li></ul><h2 id=introduction>Introduction&nbsp;<a class=headline-hash href=#introduction>¶</a></h2><p>The <code>hwarith</code> dialect provides a collection of operations that define typical
integer arithmetic operations which are bitwidth extending. These semantics
are expressed through return type inference rules that, based on the types of an
operation and its input operands, infers the type of the result operand.
Importantly, for the initial implementation of this dialect, we do not allow
types with uninferred width in the IR. A user is expected to iteratively build
operations, expect operation return types, and use this to further construct IR.
This dialect is <strong>not</strong> intended to be a &ldquo;core&rdquo; RTL dialect which takes part in
RTL codegen, and instead mainly serves as a frontend target. The lifetime of the
operations should be considered short, and lowered to their <code>comb</code> counterparts
early in the compilation pipeline.</p><p>In general, the bit width inference rules are designed to model SystemVerilog
semantics. However, unlike SystemVerilog, the aim of this dialect is to provide
a strongly-typed hardware arithmetic library with the width inference rules for
every operator explained in a clear and understandable way to avoid ambiguity.</p><p>To serve this goal of being strongly typed, the operations of the dialect
explicitly do not accept signless types. As such, only <code>ui#</code>, <code>si#</code> types are
allowed. A casting operation is provided to serve signedness casting as well as
truncation and padding.</p><p>Below we try to capture some common questions on the capabilities of such a
dialect, and how we&rsquo;ve addressed/think about the issue.</p><h3 id=qa>Q&A&nbsp;<a class=headline-hash href=#qa>¶</a></h3><ul><li><strong>Q:</strong> Does this support n-ary operations?<ul><li>n-ary operations in this dialect would have to solve the issue of how
width rules in expressions such as the following are handled: <code>%0 = hwarith.add %0, %1, %2 : si6, si5, si4</code><br>In the short term, we envision this dialect to be considering strictly
binary operations. Defining width inference rules for these is simpler and
fits the immediate usecase. If, in the future, a need for n-ary operations
comes up and is motivated clearly (e.g. for optimization purposes), the
dialect should be adapted to support it. In this case, we expect n-ary
operation rules to be a superset of those defined for binary operations.</li></ul></li><li><strong>Q:</strong> Does this support 0-width operands?<ul><li>0-width values might arise from arithmetic rules which reduce the bit
width of an expression wrt. the operands to that expression. One case
where such rules <em>may</em> apply is in the implementation of modulo
operations.<br>We refrain from adding support at this point in time, since support for
0-width values in the remainder of the RTL dialects is, at time of writing,
lacking/undefined. Once support is added in these downstream dialects,
0-width support in <code>hwarith</code> should be reconsidered.</li></ul></li><li><strong>Q:</strong> Does this support width inferred types?<ul><li>Relying on width inference is relevant when referencing results of other
width-inferred value. Without this, a user/frontend must itself know and
apply width inference rules while generating the IR (either explicitly, or
implicitly, through op builders). Having width-inferred types will be
convenient not only for generating IR, but also to leave room for width
inference rules and optimizations to apply recursively. As an example:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> hwarith<span class=p>.</span>add <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>:</span> <span class=p>(</span>ui4<span class=p>,</span> ui4<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>un<span class=p>)</span> <span class=c>// %1 is an unsigned integer of inferred width
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%2</span> <span class=p>=</span> hwarith<span class=p>.</span>add <span class=nv>%c</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>(</span>ui3<span class=p>,</span> ui<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>un<span class=p>)</span>
</span></span></code></pre></div>We see merit in having inferred width types, but recognize that the work
required to get this right is non-trivial and will require significant
effort. Once need arises, and resources are available, we find width
inferred types to be a valuable contribution to the dialect, but it will not
be part of the initial implementation.</li><li><strong>Q:</strong> Does this support user-provided/alternative rules?<ul><li>Initially, we want to settle on a set of common-case rules which describe
the semantics required by the immediate users of the dialect, so this will
not be an immediate goal of the dialect.</li></ul></li><li><strong>Q:</strong> What about fixed point operations?<ul><li>Fixed point operations and values may eventually be relevant in an
<code>hwarith</code> context. However, the immediate needs of this dialect is to
provide bitwidth-extending arithmetic for integer values.</li></ul></li><li><strong>Q:</strong> What about floating point operations?<ul><li>As above, with the additional consideration that handling floating point
operations in hardware usually involves inferring external IP. Considering
how float operations are added to <code>hwarith</code> should only be considered
after the problem of operator libraries have been solved for CIRCT.</li></ul></li></ul><h2 id=bit-width-rules>Bit Width Rules&nbsp;<a class=headline-hash href=#bit-width-rules>¶</a></h2><p>The core capability of the dialect is the bit width inference rules implemented
for each operation. These define the semantics for how arithmetic overflow is to
be handled both with respect to the width and signedness of operation results,
as well as how this is communicated to a <code>comb</code> lowering.</p><h3 id=preliminaries>Preliminaries&nbsp;<a class=headline-hash href=#preliminaries>¶</a></h3><p>The MLIR <code>ui&lt;w></code> types represents values in the interval <em>[0, 2^w - 1]</em>. Its
signed counterpart, <code>si&lt;w></code>, represents values in the interval <em>[-2^(w-1),
2^(w-1) - 1]</em>. For example, <code>ui4</code> covers values between <em>0</em> and <em>15</em>, whereas
<code>si4</code> ranges from <em>-8</em> to <em>7</em>. For a given bit-width, the unsigned and the
signed type contain the same number of values, but the represented interval is
shifted by half the interval&rsquo;s size.</p><pre tabindex=0><code>         │                  
         ├──────────────┐   
         │     ui4      │   
 ┌───────┼──────┬───────┘   
 │     si4      │           
 └───────┼──────┘           
─────────┴─────────────────▶
-8       0      7      15   
</code></pre><p>We use the notation <code>UI_MIN&lt;w></code>, <code>UI_MAX&lt;w></code>, <code>SI_MIN&lt;w></code> and <code>SI_MAX&lt;w></code> to
denote the smallest and largest values representable by an unsigned/signed type
of the given bit-width. For example, <code>UI_MAX&lt;4></code> = <em>15</em>, and <code>SI_MIN&lt;4></code> = <em>-8</em>.</p><p>The following relations for all <code>w > 0</code> are handy:</p><pre tabindex=0><code>UI_MIN&lt;w&gt;     = 0
2 * UI_MAX&lt;w&gt; = 2^(w+1) - 2
UI_MAX&lt;w+1&gt;   = 2 * UI_MAX&lt;w&gt; + 1 

SI_MIN&lt;w&gt;     &lt; 0
2 * SI_MIN&lt;w&gt; = -2^w
SI_MIN&lt;w+1&gt;   = 2 * SI_MIN&lt;w&gt;
2 * SI_MAX&lt;w&gt; = 2^w - 2
SI_MAX&lt;w+1&gt;   = 2 * SI_MAX&lt;w&gt; + 1
</code></pre><p>The following result type inference rules are chosen to prevent a loss of
precision and sign information associated with over- and underflows. The
reasoning usually takes the smallest and largest possible result values into
account. For example, if the result can be negative, then the result type must
be signed.</p><h3 id=addition>Addition&nbsp;<a class=headline-hash href=#addition>¶</a></h3><h4 id=overview>Overview&nbsp;<a class=headline-hash href=#overview>¶</a></h4><table><thead><tr><th></th><th style=text-align:left>LHS type</th><th style=text-align:left>RHS type</th><th style=text-align:left>Result type</th></tr></thead><tbody><tr><td>(U)</td><td style=text-align:left><code>ui&lt;a></code></td><td style=text-align:left><code>ui&lt;b></code></td><td style=text-align:left><code>ui&lt;r></code>, <em>r</em> = max(<em>a</em>, <em>b</em>) + 1</td></tr><tr><td>(S)</td><td style=text-align:left><code>si&lt;a></code></td><td style=text-align:left><code>si&lt;b></code></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = max(<em>a</em>, <em>b</em>) + 1</td></tr><tr><td>(M)</td><td style=text-align:left><code>ui&lt;a></code></td><td style=text-align:left><code>si&lt;b></code></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = <em>a</em> + 2 <strong>if</strong> <em>a</em> ≥ <em>b</em></td></tr><tr><td></td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = <em>b</em> + 1 <strong>if</strong> <em>a</em> &lt; <em>b</em></td></tr><tr><td>(M)</td><td style=text-align:left><code>si&lt;a></code></td><td style=text-align:left><code>ui&lt;b></code></td><td style=text-align:left>Same as <code>ui&lt;b> + si&lt;a></code></td></tr></tbody></table><h4 id=unsigned-addition-u>Unsigned addition (U)&nbsp;<a class=headline-hash href=#unsigned-addition-u>¶</a></h4><p>Result value range: <code>[0 + 0, UI_MAX&lt;a> + UI_MAX&lt;b>]</code></p><p>W.l.o.g., let <code>ui&lt;b></code> be the wider type. Then the following inequalities hold:</p><pre tabindex=0><code>UI_MAX&lt;b&gt; &lt; UI_MAX&lt;a&gt; + UI_MAX&lt;b&gt; ≤ 2 * UI_MAX&lt;b&gt; ≤ UI_MAX&lt;b+1&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> hwarith<span class=p>.</span>add <span class=nv>%10</span><span class=p>,</span> <span class=nv>%11</span> <span class=p>:</span> <span class=p>(</span>ui3<span class=p>,</span> ui4<span class=p>)</span> <span class=p>-&gt;</span> ui5
</span></span></code></pre></div><h4 id=signed-addition-s>Signed addition (S)&nbsp;<a class=headline-hash href=#signed-addition-s>¶</a></h4><p>Result value range: <code>[SI_MIN&lt;a> + SI_MIN&lt;b>, SI_MAX&lt;a> + SI_MAX&lt;b>]</code></p><p>We apply the same reasoning as in (U). W.l.o.g., let <code>si&lt;b></code> be the wider type.
Then the following inequalities hold:</p><pre tabindex=0><code>SI_MIN&lt;b&gt; &gt; SI_MIN&lt;a&gt; + SI_MIN&lt;b&gt; ≥ 2 * SI_MIN&lt;b&gt; ≥ SI_MIN&lt;b+1&gt;
SI_MAX&lt;b&gt; &lt; SI_MAX&lt;a&gt; + SI_MAX&lt;b&gt; ≤ 2 * SI_MAX&lt;b&gt; ≤ SI_MAX&lt;b+1&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> hwarith<span class=p>.</span>add <span class=nv>%12</span><span class=p>,</span> <span class=nv>%13</span> <span class=p>:</span> <span class=p>(</span>si3<span class=p>,</span> si3<span class=p>)</span> <span class=p>-&gt;</span> si4
</span></span></code></pre></div><h4 id=mixed-addition-m>Mixed addition (M)&nbsp;<a class=headline-hash href=#mixed-addition-m>¶</a></h4><p>The result type must be signed, as the addition of a positive and a negative
value may yield a negative result. Due to commutativity, we only consider
<code>ui&lt;a> + si&lt;b></code>. We distinguish two situations:</p><ul><li><p><code>a ≥ b</code>, i.e. the unsigned operand&rsquo;s width is greater or equal the signed
operand&rsquo;s width.</p><p>The smallest signed type to represent all values of <code>ui&lt;a></code> is <code>si&lt;a+1></code>.
We know that <code>a + 1 > b</code>, and derive from (S) that the result type must be
<code>si&lt;(a+1) + 1></code> = <code>si&lt;a+2></code>.</p></li><li><p><code>a &lt; b</code>, i.e. the unsigned operand&rsquo;s width is strictly less than the signed
operand&rsquo;s width.</p><p>As <code>a + 1 ≤ b</code>, the result via (S) is <code>si&lt;b+1></code>.</p></li></ul><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> hwarith<span class=p>.</span>add <span class=nv>%14</span><span class=p>,</span> <span class=nv>%15</span> <span class=p>:</span> <span class=p>(</span>ui3<span class=p>,</span> si4<span class=p>)</span> <span class=p>-&gt;</span> si5
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> hwarith<span class=p>.</span>add <span class=nv>%16</span><span class=p>,</span> <span class=nv>%17</span> <span class=p>:</span> <span class=p>(</span>si4<span class=p>,</span> ui6<span class=p>)</span> <span class=p>-&gt;</span> si8
</span></span></code></pre></div><h3 id=subtraction>Subtraction&nbsp;<a class=headline-hash href=#subtraction>¶</a></h3><h4 id=overview-1>Overview&nbsp;<a class=headline-hash href=#overview-1>¶</a></h4><table><thead><tr><th></th><th style=text-align:left>LHS type</th><th style=text-align:left>RHS type</th><th style=text-align:left>Result type</th></tr></thead><tbody><tr><td>(U)</td><td style=text-align:left><code>ui&lt;a></code></td><td style=text-align:left><code>ui&lt;b></code></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = max(<em>a</em>, <em>b</em>) + 1</td></tr><tr><td>(S)</td><td style=text-align:left><code>si&lt;a></code></td><td style=text-align:left><code>si&lt;b></code></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = max(<em>a</em>, <em>b</em>) + 1</td></tr><tr><td>(M)</td><td style=text-align:left><code>ui&lt;a></code></td><td style=text-align:left><code>si&lt;b></code></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = <em>a</em> + 2 <strong>if</strong> <em>a</em> ≥ <em>b</em></td></tr><tr><td></td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = <em>b</em> + 1 <strong>if</strong> <em>a</em> &lt; <em>b</em></td></tr><tr><td>(M)</td><td style=text-align:left><code>si&lt;a></code></td><td style=text-align:left><code>ui&lt;b></code></td><td style=text-align:left>Same as <code>ui&lt;b> - si&lt;a></code></td></tr></tbody></table><h4 id=unsigned-subtraction-u>Unsigned subtraction (U)&nbsp;<a class=headline-hash href=#unsigned-subtraction-u>¶</a></h4><p>Result value range: <code>[0 - UI_MAX&lt;b>, UI_MAX&lt;a> - 0]</code></p><p>As the result can be negative, the result type must be signed. <code>-UI_MAX&lt;b></code> is
covered by <code>si&lt;b+1></code>, and <code>UI_MAX&lt;a></code> is covered by <code>si&lt;a+1></code>, so the narrowest
type capable of representing both extremal values is <code>si&lt;r></code> with
<em>r</em> = max(<em>a</em>, <em>b</em>) + 1.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> hwarith<span class=p>.</span>sub <span class=nv>%10</span><span class=p>,</span> <span class=nv>%11</span> <span class=p>:</span> <span class=p>(</span>ui3<span class=p>,</span> ui4<span class=p>)</span> <span class=p>-&gt;</span> si5
</span></span></code></pre></div><h4 id=signed-subtraction-s>Signed subtraction (S)&nbsp;<a class=headline-hash href=#signed-subtraction-s>¶</a></h4><p>Result value range: <code>[SI_MIN&lt;a> - SI_MAX&lt;b>, SI_MAX&lt;a> - SI_MIN&lt;b>]</code></p><p>We rewrite the value range and then apply the same reasoning as for the
<a href=#signed-addition-S>signed addition</a>:</p><pre tabindex=0><code>  [SI_MIN&lt;a&gt; - SI_MAX&lt;b&gt;, SI_MAX&lt;a&gt; - SI_MIN&lt;b&gt;]
= [SI_MIN&lt;a&gt; + -2^(b-1) + 1, SI_MAX&lt;a&gt; + 2^(b-1)]
= [SI_MIN&lt;a&gt; + SI_MIN&lt;b&gt; + 1, SI_MAX&lt;a&gt; + SI_MAX&lt;b&gt; + 1]
</code></pre><p>W.l.o.g., let <code>si&lt;b></code> be the wider type. Then the following inequalities hold:</p><pre tabindex=0><code>SI_MIN&lt;b&gt; &gt; SI_MIN&lt;a&gt; + SI_MIN&lt;b&gt; + 1 ≥ 2 * SI_MIN&lt;b&gt; + 1 ≥ SI_MIN&lt;b+1&gt;
SI_MAX&lt;b&gt; &lt; SI_MAX&lt;a&gt; + SI_MAX&lt;b&gt; + 1 ≤ 2 * SI_MAX&lt;b&gt; + 1 ≤ SI_MAX&lt;b+1&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> hwarith<span class=p>.</span>sub <span class=nv>%12</span><span class=p>,</span> <span class=nv>%13</span> <span class=p>:</span> <span class=p>(</span>si3<span class=p>,</span> si3<span class=p>)</span> <span class=p>-&gt;</span> si4
</span></span></code></pre></div><h3 id=mixed-subtraction-m>Mixed subtraction (M)&nbsp;<a class=headline-hash href=#mixed-subtraction-m>¶</a></h3><p>See
<a href=#mixed-addition-M>mixed addition</a>.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> hwarith<span class=p>.</span>sub <span class=nv>%14</span><span class=p>,</span> <span class=nv>%15</span> <span class=p>:</span> <span class=p>(</span>ui3<span class=p>,</span> si4<span class=p>)</span> <span class=p>-&gt;</span> si5
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> hwarith<span class=p>.</span>sub <span class=nv>%16</span><span class=p>,</span> <span class=nv>%17</span> <span class=p>:</span> <span class=p>(</span>si4<span class=p>,</span> ui6<span class=p>)</span> <span class=p>-&gt;</span> si8
</span></span></code></pre></div><h3 id=multiplication>Multiplication&nbsp;<a class=headline-hash href=#multiplication>¶</a></h3><h4 id=overview-2>Overview&nbsp;<a class=headline-hash href=#overview-2>¶</a></h4><table><thead><tr><th></th><th style=text-align:left>LHS type</th><th style=text-align:left>RHS type</th><th style=text-align:left>Result type</th></tr></thead><tbody><tr><td>(U)</td><td style=text-align:left><code>ui&lt;a></code></td><td style=text-align:left><code>ui&lt;b></code></td><td style=text-align:left><code>ui&lt;r></code>, <em>r</em> = <em>a</em> + <em>b</em></td></tr><tr><td>(S)</td><td style=text-align:left><code>si&lt;a></code></td><td style=text-align:left><code>si&lt;b></code></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = <em>a</em> + <em>b</em></td></tr><tr><td>(M)</td><td style=text-align:left><code>ui&lt;a></code></td><td style=text-align:left><code>si&lt;b></code></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = <em>a</em> + <em>b</em></td></tr><tr><td>(M)</td><td style=text-align:left><code>si&lt;a></code></td><td style=text-align:left><code>ui&lt;b></code></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = <em>a</em> + <em>b</em></td></tr></tbody></table><h4 id=unsigned-multiplication-u>Unsigned multiplication (U)&nbsp;<a class=headline-hash href=#unsigned-multiplication-u>¶</a></h4><p>Result value range: <code>[0 * 0, UI_MAX&lt;a> * UI_MAX&lt;b>]</code></p><p>The result type must be at least <em>a</em> + *b bits wide:</p><pre tabindex=0><code>UI_MAX&lt;a&gt; * UI_MAX&lt;b&gt; = (2^a - 1) * (2^b - 1)
                      = 2^(a + b) - 2^a - 2^b + 1 
                      ≤ 2^(a + b) - 1 = UI_MAX&lt;a+b&gt;
</code></pre><p>The result type cannot be smaller than <code>ui&lt;a+b></code>, as the following
counter-example shows:</p><pre tabindex=0><code>UI_MAX&lt;3&gt; * UI_MAX&lt;4&gt; = 7 * 15 = 105 &gt; UI_MAX&lt;3+4-1&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> hwarith<span class=p>.</span>mul <span class=nv>%10</span><span class=p>,</span> <span class=nv>%11</span> <span class=p>:</span> <span class=p>(</span>ui3<span class=p>,</span> ui4<span class=p>)</span> <span class=p>-&gt;</span> ui7
</span></span></code></pre></div><h4 id=signed-multiplication-s>Signed multiplication (S)&nbsp;<a class=headline-hash href=#signed-multiplication-s>¶</a></h4><p>Result value range:
<code>[min(SI_MIN&lt;a> * SI_MAX&lt;b>, SI_MAX&lt;a> * SI_MIN&lt;b>), SI_MAX&lt;a> * SI_MAX&lt;b>]</code></p><p>With the same reasoning as in (U), we know that <code>si&lt;a+b></code> is the narrowest type
to accommodate <code>SI_MAX&lt;a> * SI_MAX&lt;b></code>. This type also covers the negative
extremal value (w.l.o.g. let <code>si&lt;b></code> be the wider type here):</p><pre tabindex=0><code>SI_MIN&lt;a&gt; * SI_MAX&lt;b&gt; = -2^(a-1) * (2^(b-1) - 1)
                      = -2^(a + b - 2) + 2^(a-1)
                      ≥ -2^(a + b - 1) = SI_MIN&lt;a+b&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> hwarith<span class=p>.</span>mul <span class=nv>%12</span><span class=p>,</span> <span class=nv>%13</span> <span class=p>:</span> <span class=p>(</span>si3<span class=p>,</span> si3<span class=p>)</span> <span class=p>-&gt;</span> si6
</span></span></code></pre></div><h4 id=mixed-multiplication-m>Mixed multiplication (M)&nbsp;<a class=headline-hash href=#mixed-multiplication-m>¶</a></h4><p>The result type must be signed. Let us consider <code>ui&lt;a> * si&lt;b></code>; the flipped
case <code>si&lt;a> * ui&lt;b></code> follows analogously.</p><p>Result value range: <code>[UI_MAX&lt;a> * SI_MIN&lt;b>, UI_MAX&lt;a> * SI_MAX&lt;b>]</code></p><p>Analogously to the previous cases, the result type must be at least <em>a</em> + <em>b</em>
bits wide:</p><pre tabindex=0><code>UI_MAX&lt;a&gt; * SI_MIN&lt;b&gt; = (2^a - 1) * -2^(b-1)
                      = -2^(a + b - 1) + 2^(b-1)
                      ≥ 2^(a + b - 1) = SI_MIN&lt;a+b&gt;

UI_MAX&lt;a&gt; * SI_MAX&lt;b&gt; = (2^a - 1) * (2^(b-1) - 1)
                      = 2^(a + b - 1) - 2^a - 2^(b-1) + 1
                      ≤ 2^(a + b - 1) - 1 = SI_MAX&lt;a+b&gt;
</code></pre><p>Again, we cannot choose a narrower type according to the following
counter-example:</p><pre tabindex=0><code>UI_MAX&lt;3&gt; * SI_MAX&lt;4&gt; = 7 * 7 = 49 ≥ SI_MAX&lt;3+4-1&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> hwarith<span class=p>.</span>mul <span class=nv>%14</span><span class=p>,</span> <span class=nv>%15</span> <span class=p>:</span> <span class=p>(</span>si3<span class=p>,</span> ui5<span class=p>)</span> <span class=p>-&gt;</span> si8
</span></span></code></pre></div><h3 id=division>Division&nbsp;<a class=headline-hash href=#division>¶</a></h3><h4 id=overview-3>Overview&nbsp;<a class=headline-hash href=#overview-3>¶</a></h4><table><thead><tr><th></th><th style=text-align:left>LHS type</th><th style=text-align:left>RHS type</th><th style=text-align:left>Result type</th></tr></thead><tbody><tr><td>(U)</td><td style=text-align:left><code>ui&lt;a></code></td><td style=text-align:left><code>ui&lt;b></code></td><td style=text-align:left><code>ui&lt;r></code>, <em>r</em> = <em>a</em></td></tr><tr><td>(S)</td><td style=text-align:left><code>si&lt;a></code></td><td style=text-align:left><code>si&lt;b></code></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = <em>a</em> + 1</td></tr><tr><td>(M1)</td><td style=text-align:left><code>ui&lt;a></code></td><td style=text-align:left><code>si&lt;b></code></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = <em>a</em> + 1</td></tr><tr><td>(M2)</td><td style=text-align:left><code>si&lt;a></code></td><td style=text-align:left><code>ui&lt;b></code></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = <em>a</em></td></tr></tbody></table><h4 id=unsigned-division-u>Unsigned division (U)&nbsp;<a class=headline-hash href=#unsigned-division-u>¶</a></h4><p>Result value range: <code>[0 / 1, UI_MAX&lt;a> / 1]</code></p><p>The result is also less or equal the dividend, so the result type is <code>ui&lt;a></code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> hwarith<span class=p>.</span>div <span class=nv>%10</span><span class=p>,</span> <span class=nv>%11</span> <span class=p>:</span> <span class=p>(</span>ui3<span class=p>,</span> ui4<span class=p>)</span> <span class=p>-&gt;</span> ui3
</span></span></code></pre></div><h4 id=signed-division-s>Signed division (S)&nbsp;<a class=headline-hash href=#signed-division-s>¶</a></h4><p>Result value range: <code>[SI_MIN&lt;a> / 1, SI_MIN&lt;a> / -1]</code></p><p><code>- SI_MIN&lt;a></code> is not covered by <code>si&lt;a></code>, so we have to widen the result type to
<code>si&lt;a+1></code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> hwarith<span class=p>.</span>div <span class=nv>%12</span><span class=p>,</span> <span class=nv>%13</span> <span class=p>:</span> <span class=p>(</span>si3<span class=p>,</span> si3<span class=p>)</span> <span class=p>-&gt;</span> si4
</span></span></code></pre></div><h4 id=division-with-signed-divisor-m1>Division with signed divisor (M1)&nbsp;<a class=headline-hash href=#division-with-signed-divisor-m1>¶</a></h4><p>If at least one operand is signed, then the result type must be signed as well.</p><p>Result value range: <code>[UI_MAX&lt;a> / -1, UI_MAX&lt;a> / 1]</code></p><p>The result type must be <code>si&lt;a+1></code> in order to accommodate <code>UI_MAX&lt;a></code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> hwarith<span class=p>.</span>div <span class=nv>%14</span><span class=p>,</span> <span class=nv>%15</span> <span class=p>:</span> <span class=p>(</span>ui3<span class=p>,</span> si4<span class=p>)</span> <span class=p>-&gt;</span> si4
</span></span></code></pre></div><h4 id=division-with-signed-dividend-m2>Division with signed dividend (M2)&nbsp;<a class=headline-hash href=#division-with-signed-dividend-m2>¶</a></h4><p>If at least one operand is signed, then the result type must be signed as well.</p><p>Result value range: <code>[SI_MIN&lt;a> / 1, SI_MAX&lt;a> / 1]</code>]</p><p>The type of the dividend, <code>si&lt;a></code>, already covers the entire result value range.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> hwarith<span class=p>.</span>div <span class=nv>%16</span><span class=p>,</span> <span class=nv>%17</span> <span class=p>:</span> <span class=p>(</span>si4<span class=p>,</span> ui6<span class=p>)</span> <span class=p>-&gt;</span> si4
</span></span></code></pre></div><h3 id=casting>Casting&nbsp;<a class=headline-hash href=#casting>¶</a></h3><p>Casting between signless and sign-aware types is essential for <code>HWArith</code> to
coexist and interact with core dialects such as <code>HW</code> and <code>Comb</code>. Defining
casting rules can be split into two sub-problems: bit-extension and truncation.
Truncation to a type with identical or smaller bitwidth is simply implemented
by extracting the least significant bits of the operand. Hence, it is identical
for sign-aware and signless types. Bit-extension on the other hand needs to
consider the signedness of the operand to preserve the operand&rsquo;s value. As
signless types do not express such information by design, no bit-extension can
be performed. Values of type <code>si&lt;w></code> or <code>ui&lt;w></code> are sign-extended or
zero-extended, respectively, regardless of the target&rsquo;s signedness or lack
thereof. Thus, when casting in <code>HWArith</code>, first the bitwidth is adjusted to the
target size, then in a second step the signedness is changed in a bitcast
manner.</p><p>To visualize this behavior study the following example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> hwarith<span class=p>.</span>cast <span class=nv>%10</span> <span class=p>:</span> <span class=p>(</span>ui3<span class=p>)</span> <span class=p>-&gt;</span> ui5
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> hwarith<span class=p>.</span>cast <span class=nv>%1</span> <span class=p>:</span> <span class=p>(</span>ui5<span class=p>)</span> <span class=p>-&gt;</span> si5
</span></span><span class=line><span class=cl><span class=c>// ^-- both casts can be combined into one equivalent cast:
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> hwarith<span class=p>.</span>cast <span class=nv>%10</span> <span class=p>:</span> <span class=p>(</span>ui3<span class=p>)</span> <span class=p>-&gt;</span> si5
</span></span><span class=line><span class=cl><span class=c>// ^-- this would be lowered to something like this:
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%zero_padding</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i2</span>
</span></span><span class=line><span class=cl><span class=nv>%0_lowered</span> <span class=p>=</span> comb<span class=p>.</span>concat <span class=nv>%zero_padding</span><span class=p>,</span> <span class=nv>%10</span> <span class=p>:</span> <span class=k>i2</span><span class=p>,</span> <span class=k>i3</span>
</span></span></code></pre></div><p>As an alternative to the proposed <em>all-in-one</em> cast op, we considered
implementing a set of ops with distinct concerns, for example, an op for
bitcasting between types of the same bitwidth, an op to implementing the
truncation and two ops for the different bit extension types. Yet, considering
that <code>HWArith</code> is currently intended as a short-lived dialect, being immediately
lowered to <code>comb</code>, no obvious benefits emerge. This could also significantly
increase the code redundancy during IR generation as well as when lowering to
<code>comb</code>.</p><h4 id=overview-4>Overview&nbsp;<a class=headline-hash href=#overview-4>¶</a></h4><table><thead><tr><th></th><th style=text-align:left>Input type</th><th style=text-align:left>Result type</th><th style=text-align:left>Behavior</th></tr></thead><tbody><tr><td>(U)</td><td style=text-align:left><code>ui&lt;a></code></td><td style=text-align:left><code>ui&lt;b></code>/<code>si&lt;b></code>/<code>i&lt;b></code></td><td style=text-align:left>zero-extension <strong>if</strong> <em>b</em> ≥ <em>a</em></td></tr><tr><td></td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>truncation <strong>if</strong> <em>b</em> &lt; <em>a</em></td></tr><tr><td>(S)</td><td style=text-align:left><code>si&lt;a></code></td><td style=text-align:left><code>ui&lt;b></code>/<code>si&lt;b></code>/<code>i&lt;b></code></td><td style=text-align:left>sign-extension <strong>if</strong> <em>b</em> ≥ <em>a</em></td></tr><tr><td></td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left>truncation <strong>if</strong> <em>b</em> &lt; <em>a</em></td></tr><tr><td>(I)</td><td style=text-align:left><code>i&lt;a></code></td><td style=text-align:left><code>ui&lt;b></code>/<code>si&lt;b></code></td><td style=text-align:left>truncation <strong>if</strong> <em>b</em> <strong>≤</strong> <em>a</em></td></tr><tr><td></td><td style=text-align:left><code>i&lt;a></code></td><td style=text-align:left><code>ui&lt;b></code>/<code>si&lt;b></code></td><td style=text-align:left>prohibited<sup>†</sup> <strong>if</strong> <em>b</em> > <em>a</em></td></tr></tbody></table><p>†) prohibited because of the ambiguity whether a sign or a zero extension is
required.</p><h4 id=examples>Examples&nbsp;<a class=headline-hash href=#examples>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> hwarith<span class=p>.</span>cast <span class=nv>%10</span> <span class=p>:</span> <span class=p>(</span>ui3<span class=p>)</span> <span class=p>-&gt;</span> si5 <span class=c>// (U)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%1</span> <span class=p>=</span> hwarith<span class=p>.</span>cast <span class=nv>%11</span> <span class=p>:</span> <span class=p>(</span>si3<span class=p>)</span> <span class=p>-&gt;</span> si4 <span class=c>// (S)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%2</span> <span class=p>=</span> hwarith<span class=p>.</span>cast <span class=nv>%12</span> <span class=p>:</span> <span class=p>(</span>si7<span class=p>)</span> <span class=p>-&gt;</span> ui4 <span class=c>// (S)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%3</span> <span class=p>=</span> hwarith<span class=p>.</span>cast <span class=nv>%13</span> <span class=p>:</span> <span class=p>(</span><span class=k>i7</span><span class=p>)</span> <span class=p>-&gt;</span> si5  <span class=c>// (I)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%3</span> <span class=p>=</span> hwarith<span class=p>.</span>cast <span class=nv>%13</span> <span class=p>:</span> <span class=p>(</span>si14<span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i4</span> <span class=c>// (S)
</span></span></span></code></pre></div><h3 id=comparison>Comparison&nbsp;<a class=headline-hash href=#comparison>¶</a></h3><p>In order to compare two sign-aware operands, a common type must first be found
that is able to preserve the values of the two operands. Once determined, the
operands are casted to this comparison type as specified in the
<a href=#casting>casting section</a>. To simplify the use as well as the IR generation
of the dialect, the necessary casting steps are hidden from the user and
applied during the lowering. Thus, the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> hwarith<span class=p>.</span>cast <span class=nv>%0</span> <span class=p>:</span> <span class=p>(</span>si3<span class=p>)</span> <span class=p>-&gt;</span> si6
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> hwarith<span class=p>.</span>cast <span class=nv>%1</span> <span class=p>:</span> <span class=p>(</span>ui5<span class=p>)</span> <span class=p>-&gt;</span> si6
</span></span><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> hwarith<span class=p>.</span>icmp lt <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> si6<span class=p>,</span> si6
</span></span></code></pre></div><p>can be simplified to:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> hwarith<span class=p>.</span>icmp lt <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> si3<span class=p>,</span> ui5
</span></span></code></pre></div><p>Note that the result of the comparison is <em>always</em> of type <code>ui1</code>, regardless of
the operands. So if the <code>i1</code> type is needed, the result must be cast
accordingly.</p><h4 id=overview-5>Overview&nbsp;<a class=headline-hash href=#overview-5>¶</a></h4><table><thead><tr><th></th><th style=text-align:left>LHS type</th><th style=text-align:left>RHS type</th><th style=text-align:left>Comparison type</th><th style=text-align:left>Result type</th></tr></thead><tbody><tr><td>(U)</td><td style=text-align:left><code>ui&lt;a></code></td><td style=text-align:left><code>ui&lt;b></code></td><td style=text-align:left><code>ui&lt;r></code>, <em>r</em> = max(<em>a</em>, <em>b</em>)</td><td style=text-align:left><code>ui1</code></td></tr><tr><td>(S)</td><td style=text-align:left><code>si&lt;a></code></td><td style=text-align:left><code>si&lt;b></code></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = max(<em>a</em>, <em>b</em>)</td><td style=text-align:left><code>ui1</code></td></tr><tr><td>(M)</td><td style=text-align:left><code>ui&lt;a></code></td><td style=text-align:left><code>si&lt;b></code></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = <em>a</em> + 1 <strong>if</strong> <em>a</em> ≥ <em>b</em></td><td style=text-align:left><code>ui1</code></td></tr><tr><td></td><td style=text-align:left></td><td style=text-align:left></td><td style=text-align:left><code>si&lt;r></code>, <em>r</em> = <em>b</em> <strong>if</strong> <em>a</em> &lt; <em>b</em></td><td style=text-align:left><code>ui1</code></td></tr><tr><td>(M)</td><td style=text-align:left><code>si&lt;a></code></td><td style=text-align:left><code>ui&lt;b></code></td><td style=text-align:left>Same as <code>ui&lt;b> si&lt;a></code></td><td style=text-align:left><code>ui1</code></td></tr></tbody></table><h4 id=examples-1>Examples&nbsp;<a class=headline-hash href=#examples-1>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> hwarith<span class=p>.</span>icmp lt <span class=nv>%10</span><span class=p>,</span> <span class=nv>%11</span> <span class=p>:</span> ui5<span class=p>,</span> ui6 <span class=c>// (U)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%1</span> <span class=p>=</span> hwarith<span class=p>.</span>icmp lt <span class=nv>%12</span><span class=p>,</span> <span class=nv>%13</span> <span class=p>:</span> si3<span class=p>,</span> si4 <span class=c>// (S)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%2</span> <span class=p>=</span> hwarith<span class=p>.</span>icmp lt <span class=nv>%12</span><span class=p>,</span> <span class=nv>%11</span> <span class=p>:</span> si3<span class=p>,</span> ui6 <span class=c>// (M)
</span></span></span></code></pre></div><h3 id=additional-operators>Additional operators&nbsp;<a class=headline-hash href=#additional-operators>¶</a></h3><p><strong>TODO</strong>: elaborate once operators are provided.</p><ul><li><code>hwarith.mod %0, %1 : (#l0, #l1) -> (#l2)</code>:</li></ul><h2 id=lowering>Lowering&nbsp;<a class=headline-hash href=#lowering>¶</a></h2><p>The general lowering style of the dialect operations consists of padding the
operands of an operation based on an operation rule, and subsequently feeding
these operands to the corresponding <code>comb</code> operator.</p><p>For instance, given <code>%res = hwarith.add %lhs, %rhs</code> and a rule stating <code>w(res)</code>
= <code>max(w(lhs), w(rhs)) + 1</code> the lowering would be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%res</span> <span class=p>=</span> hwarith<span class=p>.</span>add <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=p>(</span>ui3<span class=p>,</span> ui4<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>ui5<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// lowers to
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%z2</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i2</span>
</span></span><span class=line><span class=cl><span class=nv>%z1</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%lhs_padded</span> <span class=p>=</span> comb<span class=p>.</span>concat <span class=nv>%z2</span><span class=p>,</span> <span class=nv>%lhs</span> <span class=p>:</span> <span class=k>i2</span><span class=p>,</span> <span class=k>i3</span>
</span></span><span class=line><span class=cl><span class=nv>%rhs_padded</span> <span class=p>=</span> comb<span class=p>.</span>concat <span class=nv>%z1</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i4</span>
</span></span><span class=line><span class=cl><span class=nv>%res</span> <span class=p>=</span> comb<span class=p>.</span>add <span class=nv>%lhs_padded</span><span class=p>,</span> <span class=nv>%rhs_padded</span> <span class=p>:</span> <span class=k>i5</span>
</span></span></code></pre></div><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/HWArith/ title="'hwarith' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'hwarith' Dialect</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/Ibis/ title="'ibis' Dialect">Next - 'ibis' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark opened">-</span></a><ul class=sub-menu><li class=active><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>