<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Handshake Dialect Rationale - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>Handshake Dialect Rationale</h1><p><nav id=TableOfContents><ul><li><a href=#principle>Principle</a></li><li><a href=#choice-of-mlir>Choice of MLIR</a></li><li><a href=#ir-representation>IR Representation</a></li><li><a href=#conventions>Conventions</a></li><li><a href=#talks-resources-and-related-publications>Talks, Resources and Related Publications</a></li><li><a href=#operation-definitions>Operation definitions</a></li><li><a href=#operations>Operations</a><ul><li><a href=#handshakebr-circthandshakebranchop><code>handshake.br</code> (::circt::handshake::BranchOp)</a></li><li><a href=#handshakebuffer-circthandshakebufferop><code>handshake.buffer</code> (::circt::handshake::BufferOp)</a></li><li><a href=#handshakecond_br-circthandshakeconditionalbranchop><code>handshake.cond_br</code> (::circt::handshake::ConditionalBranchOp)</a></li><li><a href=#handshakeconstant-circthandshakeconstantop><code>handshake.constant</code> (::circt::handshake::ConstantOp)</a></li><li><a href=#handshakecontrol_merge-circthandshakecontrolmergeop><code>handshake.control_merge</code> (::circt::handshake::ControlMergeOp)</a></li><li><a href=#handshakeextmemory-circthandshakeexternalmemoryop><code>handshake.extmemory</code> (::circt::handshake::ExternalMemoryOp)</a></li><li><a href=#handshakefork-circthandshakeforkop><code>handshake.fork</code> (::circt::handshake::ForkOp)</a></li><li><a href=#handshakefunc-circthandshakefuncop><code>handshake.func</code> (::circt::handshake::FuncOp)</a></li><li><a href=#handshakeinstance-circthandshakeinstanceop><code>handshake.instance</code> (::circt::handshake::InstanceOp)</a></li><li><a href=#handshakejoin-circthandshakejoinop><code>handshake.join</code> (::circt::handshake::JoinOp)</a></li><li><a href=#handshakelazy_fork-circthandshakelazyforkop><code>handshake.lazy_fork</code> (::circt::handshake::LazyForkOp)</a></li><li><a href=#handshakeload-circthandshakeloadop><code>handshake.load</code> (::circt::handshake::LoadOp)</a></li><li><a href=#handshakememory-circthandshakememoryop><code>handshake.memory</code> (::circt::handshake::MemoryOp)</a></li><li><a href=#handshakemerge-circthandshakemergeop><code>handshake.merge</code> (::circt::handshake::MergeOp)</a></li><li><a href=#handshakemux-circthandshakemuxop><code>handshake.mux</code> (::circt::handshake::MuxOp)</a></li><li><a href=#handshakenever-circthandshakeneverop><code>handshake.never</code> (::circt::handshake::NeverOp)</a></li><li><a href=#handshakepack-circthandshakepackop><code>handshake.pack</code> (::circt::handshake::PackOp)</a></li><li><a href=#handshakereturn-circthandshakereturnop><code>handshake.return</code> (::circt::handshake::ReturnOp)</a></li><li><a href=#handshakesink-circthandshakesinkop><code>handshake.sink</code> (::circt::handshake::SinkOp)</a></li><li><a href=#handshakesource-circthandshakesourceop><code>handshake.source</code> (::circt::handshake::SourceOp)</a></li><li><a href=#handshakestore-circthandshakestoreop><code>handshake.store</code> (::circt::handshake::StoreOp)</a></li><li><a href=#handshakesync-circthandshakesyncop><code>handshake.sync</code> (::circt::handshake::SyncOp)</a></li><li><a href=#handshakeunpack-circthandshakeunpackop><code>handshake.unpack</code> (::circt::handshake::UnpackOp)</a></li></ul></li><li><a href=#attributes-6>Attributes</a><ul><li><a href=#buffertypeenumattr>BufferTypeEnumAttr</a></li></ul></li></ul></nav><p>This document also explains in a high-level manner how different components are
organized, the principles behind them and the conventions we followed.
The document assume that you have basic understanding of
<a href=https://en.wikipedia.org/wiki/Asynchronous_circuit>asynchronous digital circuits</a>
at the behavioral level of abstraction.</p><h2 id=principle>Principle&nbsp;<a class=headline-hash href=#principle>¶</a></h2><p>Handshake/dataflow IR describes independent, unsynchronized processes
communicating data through First-in First-out (FIFO) communication channels.
This can be implemented in many ways, such as using synchronous logic, or with
processors.</p><h2 id=choice-of-mlir>Choice of MLIR&nbsp;<a class=headline-hash href=#choice-of-mlir>¶</a></h2><p>MLIR is a common infrastructure to build your own specific IR to target
different architectures and needs. We use MLIR because of its extensibility. We
can apply the various transformations and optimization of MLIR on this IR. We
can also lower the std MLIR produced by different frontends to Handshake IR.</p><pre><code> TensorFlow     LLVM       Pytorch
      |           |           | 
 |-----------------------------------|    
 |   MLIR                            |
 |         -----------------         |
 |         | opt/transform |         |
 |         -----------------         |
 |                                   |
 |         -----------------         |
 |         | opt/transform |         |
 |         -----------------         |
 |                                   |
 |-----------------------------------|
    |        |        |             | 
   GPU      LLVM    Affine     **Dataflow**
</code></pre><h2 id=ir-representation>IR Representation&nbsp;<a class=headline-hash href=#ir-representation>¶</a></h2><p>Simple Handshake IR snippet for an add function looks like this -</p><pre tabindex=0><code>handshake.func @simple_addi(%arg0: index, %arg1: index, %arg2: none, ...) -&gt; (index, none) {
        %0 = addi %arg0, %arg1 : index
        handshake.return %0, %arg2 : index, none
}
</code></pre><p>It accepts two input streams (modeled as MLIR operands) and produces one
output stream (modeled as an MLIR result).</p><h2 id=conventions>Conventions&nbsp;<a class=headline-hash href=#conventions>¶</a></h2><p>The Handshake dialect adopts the following conventions for IR:</p><ul><li>The prefix for all Handshake types and operations are <code>handshake.</code>.</li></ul><h2 id=talks-resources-and-related-publications>Talks, Resources and Related Publications&nbsp;<a class=headline-hash href=#talks-resources-and-related-publications>¶</a></h2><ul><li>(10/2022)
<a href=https://www.research-collection.ethz.ch/bitstream/handle/20.500.11850/578713/1/Ulmann_Christian.pdf>Multi-Level Rewriting for Stream Processing to RTL compilation (M.Sc. Thesis) - Christian Ulmann</a></li><li>(03/2022)
<a href=https://capra.cs.cornell.edu/latte22/paper/2.pdf>HLS from PyTorch to System Verilog with MLIR and CIRCT (Workshop paper) - Mike Urbach, Morten Borup Petersen</a></li><li>(01/2022)
<a href=https://infoscience.epfl.ch/record/292189>A Dynamically Scheduled HLS Flow in MLIR (M.Sc. Thesis) - Morten Borup Petersen</a></li><li>(06/2020) MLIR Handshake Dialect-
<a href="https://drive.google.com/file/d/1UYQAfHrzcsdXUZ93bHPTPNwrscwx89M-/view?usp=sharing">slides</a> by Stephen Neuendorffer (Xilinx) + Lana Josipović (EPFL)</li></ul><h2 id=operation-definitions>Operation definitions&nbsp;<a class=headline-hash href=#operation-definitions>¶</a></h2><p>Types and operations for the handshake dialect
This dialect defined the <code>handshake</code> dialect, modeling dataflow circuits.
Handshake/dataflow IR is describes independent, unsynchronized processes
communicating data through First-in First-out (FIFO) communication channels.</p><p><nav id=TableOfContents><ul><li><a href=#principle>Principle</a></li><li><a href=#choice-of-mlir>Choice of MLIR</a></li><li><a href=#ir-representation>IR Representation</a></li><li><a href=#conventions>Conventions</a></li><li><a href=#talks-resources-and-related-publications>Talks, Resources and Related Publications</a></li><li><a href=#operation-definitions>Operation definitions</a></li><li><a href=#operations>Operations</a><ul><li><a href=#handshakebr-circthandshakebranchop><code>handshake.br</code> (::circt::handshake::BranchOp)</a></li><li><a href=#handshakebuffer-circthandshakebufferop><code>handshake.buffer</code> (::circt::handshake::BufferOp)</a></li><li><a href=#handshakecond_br-circthandshakeconditionalbranchop><code>handshake.cond_br</code> (::circt::handshake::ConditionalBranchOp)</a></li><li><a href=#handshakeconstant-circthandshakeconstantop><code>handshake.constant</code> (::circt::handshake::ConstantOp)</a></li><li><a href=#handshakecontrol_merge-circthandshakecontrolmergeop><code>handshake.control_merge</code> (::circt::handshake::ControlMergeOp)</a></li><li><a href=#handshakeextmemory-circthandshakeexternalmemoryop><code>handshake.extmemory</code> (::circt::handshake::ExternalMemoryOp)</a></li><li><a href=#handshakefork-circthandshakeforkop><code>handshake.fork</code> (::circt::handshake::ForkOp)</a></li><li><a href=#handshakefunc-circthandshakefuncop><code>handshake.func</code> (::circt::handshake::FuncOp)</a></li><li><a href=#handshakeinstance-circthandshakeinstanceop><code>handshake.instance</code> (::circt::handshake::InstanceOp)</a></li><li><a href=#handshakejoin-circthandshakejoinop><code>handshake.join</code> (::circt::handshake::JoinOp)</a></li><li><a href=#handshakelazy_fork-circthandshakelazyforkop><code>handshake.lazy_fork</code> (::circt::handshake::LazyForkOp)</a></li><li><a href=#handshakeload-circthandshakeloadop><code>handshake.load</code> (::circt::handshake::LoadOp)</a></li><li><a href=#handshakememory-circthandshakememoryop><code>handshake.memory</code> (::circt::handshake::MemoryOp)</a></li><li><a href=#handshakemerge-circthandshakemergeop><code>handshake.merge</code> (::circt::handshake::MergeOp)</a></li><li><a href=#handshakemux-circthandshakemuxop><code>handshake.mux</code> (::circt::handshake::MuxOp)</a></li><li><a href=#handshakenever-circthandshakeneverop><code>handshake.never</code> (::circt::handshake::NeverOp)</a></li><li><a href=#handshakepack-circthandshakepackop><code>handshake.pack</code> (::circt::handshake::PackOp)</a></li><li><a href=#handshakereturn-circthandshakereturnop><code>handshake.return</code> (::circt::handshake::ReturnOp)</a></li><li><a href=#handshakesink-circthandshakesinkop><code>handshake.sink</code> (::circt::handshake::SinkOp)</a></li><li><a href=#handshakesource-circthandshakesourceop><code>handshake.source</code> (::circt::handshake::SourceOp)</a></li><li><a href=#handshakestore-circthandshakestoreop><code>handshake.store</code> (::circt::handshake::StoreOp)</a></li><li><a href=#handshakesync-circthandshakesyncop><code>handshake.sync</code> (::circt::handshake::SyncOp)</a></li><li><a href=#handshakeunpack-circthandshakeunpackop><code>handshake.unpack</code> (::circt::handshake::UnpackOp)</a></li></ul></li><li><a href=#attributes-6>Attributes</a><ul><li><a href=#buffertypeenumattr>BufferTypeEnumAttr</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><h3 id=handshakebr-circthandshakebranchop><code>handshake.br</code> (::circt::handshake::BranchOp)&nbsp;<a class=headline-hash href=#handshakebr-circthandshakebranchop>¶</a></h3><p><em>Branch operation</em></p><p>The branch operation represents an unconditional
branch. The single data input is propagated to the single
successor. The input must be triggered by some predecessor to
avoid continous triggering of a successor block.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> br <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>GeneralOpInterface</code>, <code>InferTypeOpInterface</code>, <code>NamedIOInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SOSTInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataOperand</code></td><td>any type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataResult</code></td><td>any type</td></tr></tbody></table><h3 id=handshakebuffer-circthandshakebufferop><code>handshake.buffer</code> (::circt::handshake::BufferOp)&nbsp;<a class=headline-hash href=#handshakebuffer-circthandshakebufferop>¶</a></h3><p><em>Buffer operation</em></p><p>The buffer operation represents a buffer operation. $slots
must be an unsigned integer larger than 0. $bufferType=BufferTypeEnum::seq indicates a
nontransparent buffer, while $bufferType=BufferTypeEnum::fifo indicates a transparent
buffer.</p><p>An &lsquo;initValues&rsquo; attribute containing a list of integer values may be provided.
The list must be of the same length as the number of slots. This will
initialize the buffer with the given values upon reset.
For now, only sequential buffers are allowed to have initial values.
@todo: How to support different init types? these have to be stored (and
retrieved) as attributes, hence they must be of a known type.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasClock</code>, <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>GeneralOpInterface</code>, <code>InferTypeOpInterface</code>, <code>NamedIOInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SOSTInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>slots</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 1</td></tr><tr><td><code>bufferType</code></td><td>::circt::handshake::BufferTypeEnumAttr</td><td>BufferOp seq or fifo</td></tr><tr><td><code>initValues</code></td><td>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>any type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=handshakecond_br-circthandshakeconditionalbranchop><code>handshake.cond_br</code> (::circt::handshake::ConditionalBranchOp)&nbsp;<a class=headline-hash href=#handshakecond_br-circthandshakeconditionalbranchop>¶</a></h3><p><em>Conditional branch operation</em></p><p>The cbranch operation represents a conditional
branch. The data input is propagated to one of the two outputs
based on the condition input.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%true</span><span class=p>,</span> <span class=nv>%false</span> <span class=p>=</span> conditional_branch <span class=nv>%cond</span><span class=p>,</span> <span class=nv>%data</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>InferTypeOpInterface</code>, <code>NamedIOInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>conditionOperand</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>dataOperand</code></td><td>any type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>trueResult</code></td><td>any type</td></tr><tr><td style=text-align:center><code>falseResult</code></td><td>any type</td></tr></tbody></table><h3 id=handshakeconstant-circthandshakeconstantop><code>handshake.constant</code> (::circt::handshake::ConstantOp)&nbsp;<a class=headline-hash href=#handshakeconstant-circthandshakeconstantop>¶</a></h3><p><em>Constant operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `handshake.constant` $ctrl attr-dict `:` qualified(type($result))
</code></pre><p>The const has a constant value. When triggered by its
single <code>ctrl</code> input, it sends the constant value to its single
successor.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=kt>constant</span> <span class=nv>%ctrl</span> <span class=p>{</span><span class=nl>value =</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>GeneralOpInterface</code>, <code>NamedIOInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::TypedAttr</td><td>TypedAttr instance</td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ctrl</code></td><td>none type</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=handshakecontrol_merge-circthandshakecontrolmergeop><code>handshake.control_merge</code> (::circt::handshake::ControlMergeOp)&nbsp;<a class=headline-hash href=#handshakecontrol_merge-circthandshakecontrolmergeop>¶</a></h3><p><em>Control merge operation</em></p><p>The control_merge operation represents a
(nondeterministic) control merge. Any input is propagated to the
first output and the index of the propagated input is sent to the
second output. The number of inputs corresponds to the number of
predecessor blocks.</p><p>Example:</p><pre tabindex=0><code>%0, %idx = control_merge %a, %b, %c {attributes} : i32, index
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasClock</code>, <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>MergeLikeOpInterface</code>, <code>NamedIOInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SOSTInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataOperands</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr><tr><td style=text-align:center><code>index</code></td><td>any type</td></tr></tbody></table><h3 id=handshakeextmemory-circthandshakeexternalmemoryop><code>handshake.extmemory</code> (::circt::handshake::ExternalMemoryOp)&nbsp;<a class=headline-hash href=#handshakeextmemory-circthandshakeexternalmemoryop>¶</a></h3><p><em>External memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `handshake.extmemory` `[` `ld` `=` $ldCount `,` `st` `=`  $stCount `]` `(` $memref `:` qualified(type($memref)) `)` `(` $inputs `)` attr-dict `:` functional-type($inputs, $outputs)
</code></pre><p>An ExternalMemoryOp represents a wrapper around a memref input to a
handshake function. The semantics of the load/store operands are identical
to what is decribed for MemoryOp. The only difference is that the first
operand to this operand is a <code>memref</code> value.
Upon lowering to FIRRTL, a handshake interface will be created in the
top-level component for each load- and store which connected to this memory.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>handshake<span class=p>.</span><span class=kt>func</span> <span class=nf>@main</span><span class=p>(</span><span class=nv>%i</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%v</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%mem</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=nv>%ctrl</span><span class=p>:</span> none<span class=p>)</span> <span class=p>-&gt;</span> none <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%stCtrl</span> <span class=p>=</span> extmemory<span class=p>[</span><span class=nl>ld =</span> <span class=m>0</span><span class=p>,</span> <span class=nl>st =</span> <span class=m>1</span><span class=p>](</span><span class=nv>%mem</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>i32</span><span class=p>&gt;)(</span><span class=nv>%vout</span><span class=p>,</span> <span class=nv>%addr</span><span class=p>)</span> <span class=p>{</span><span class=nl>id =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>none<span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nv>%vout</span><span class=p>,</span> <span class=nv>%addr</span> <span class=p>=</span> store<span class=p>(</span><span class=nv>%v</span><span class=p>,</span> <span class=nv>%i</span><span class=p>,</span> <span class=nv>%ctrl</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> none<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>NamedIOInterface</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>ldCount</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>stCount</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=handshakefork-circthandshakeforkop><code>handshake.fork</code> (::circt::handshake::ForkOp)&nbsp;<a class=headline-hash href=#handshakefork-circthandshakeforkop>¶</a></h3><p><em>Fork operation</em></p><p>The fork operation represents a fork operation. A
single input is replicated to N outputs and distributed to each
output as soon as the corresponding successor is available.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span><span class=p>:</span><span class=nl>2 =</span> fork <span class=p>[</span><span class=m>2</span><span class=p>]</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasClock</code>, <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>GeneralOpInterface</code>, <code>NamedIOInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SOSTInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>any type</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=handshakefunc-circthandshakefuncop><code>handshake.func</code> (::circt::handshake::FuncOp)&nbsp;<a class=headline-hash href=#handshakefunc-circthandshakefuncop>¶</a></h3><p><em>Handshake dialect function.</em></p><p>The func operation represents a handshaked function.
This is almost exactly like a standard FuncOp, except that it has
some extra verification conditions. In particular, each Value must
only have a single use.</p><p>Traits: <code>HasClock</code>, <code>IsolatedFromAbove</code></p><p>Interfaces: <code>CallableOpInterface</code>, <code>FineGrainedDataflowRegionOpInterface</code>, <code>FunctionOpInterface</code>, <code>OpAsmOpInterface</code>, <code>RegionKindInterface</code>, <code>Symbol</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h3 id=handshakeinstance-circthandshakeinstanceop><code>handshake.instance</code> (::circt::handshake::InstanceOp)&nbsp;<a class=headline-hash href=#handshakeinstance-circthandshakeinstanceop>¶</a></h3><p><em>Module instantiate operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `handshake.instance` $module `(` $opOperands `)` attr-dict `:` functional-type($opOperands, results)
</code></pre><p>The <code>instance</code> operation represents the instantiation of a module. This
is similar to a function call, except that different instances of the
same module are guaranteed to have their own distinct state.
The instantiated module is encoded as a symbol reference attribute named
&ldquo;module&rdquo;. An instance operation takes a control input as its last argument
and returns a control output as its last result.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span><span class=p>:</span><span class=nl>2 =</span> handshake<span class=p>.</span>instance <span class=nf>@my_add</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%ctrl</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>f32</span><span class=p>,</span> none<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> none<span class=p>)</span>
</span></span></code></pre></div><p>Traits: <code>HasClock</code>, <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>CallOpInterface</code>, <code>ControlInterface</code>, <code>NamedIOInterface</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>module</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>opOperands</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>variadic of any type</td></tr></tbody></table><h3 id=handshakejoin-circthandshakejoinop><code>handshake.join</code> (::circt::handshake::JoinOp)&nbsp;<a class=headline-hash href=#handshakejoin-circthandshakejoinop>¶</a></h3><p><em>Join operation</em></p><p>A control-only synchronizer. Produces a valid output when all
inputs become available.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> join <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> none
</span></span></code></pre></div><p>Traits: <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>GeneralOpInterface</code>, <code>InferTypeOpInterface</code>, <code>NamedIOInterface</code></p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>none type</td></tr></tbody></table><h3 id=handshakelazy_fork-circthandshakelazyforkop><code>handshake.lazy_fork</code> (::circt::handshake::LazyForkOp)&nbsp;<a class=headline-hash href=#handshakelazy_fork-circthandshakelazyforkop>¶</a></h3><p><em>Lazy fork operation</em></p><p>The lazy_fork operation represents a lazy fork operation.
A single input is replicated to N outputs and distributed to each
output when all successors are available.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span><span class=p>:</span><span class=nl>2 =</span> lazy_fork <span class=p>[</span><span class=m>2</span><span class=p>]</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ControlInterface</code>, <code>NamedIOInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SOSTInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>any type</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=handshakeload-circthandshakeloadop><code>handshake.load</code> (::circt::handshake::LoadOp)&nbsp;<a class=headline-hash href=#handshakeload-circthandshakeloadop>¶</a></h3><p><em>Load operation</em></p><p>Load memory port, sends load requests to MemoryOp. From dataflow
predecessor, receives address indices and a control-only value
which signals completion of all previous memory accesses which
target the same memory. When all inputs are received, the load
sends the address indices to MemoryOp. When the MemoryOp returns
a piece of data, the load sends it to its dataflow successor.</p><p>Operands: address indices (from predecessor), data (from MemoryOp), control-only input.
Results: data (to successor), address indices (to MemoryOp).</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%dataToSucc</span><span class=p>,</span> <span class=nv>%addr1ToMem</span><span class=p>,</span> <span class=nv>%addr2ToMem</span> <span class=p>=</span> load <span class=p>[</span><span class=nv>%addr1</span><span class=p>,</span> <span class=nv>%addr2</span><span class=p>]</span> <span class=nv>%dataFromMem</span><span class=p>,</span> <span class=nv>%ctrl</span> <span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i16</span><span class=p>,</span> <span class=k>index</span>
</span></span></code></pre></div><p>Traits: <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>NamedIOInterface</code></p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addresses</code></td><td>variadic of any type</td></tr><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr><tr><td style=text-align:center><code>ctrl</code></td><td>none type</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataResult</code></td><td>any type</td></tr><tr><td style=text-align:center><code>addressResults</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=handshakememory-circthandshakememoryop><code>handshake.memory</code> (::circt::handshake::MemoryOp)&nbsp;<a class=headline-hash href=#handshakememory-circthandshakememoryop>¶</a></h3><p><em>Memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `handshake.memory` `[` `ld` `=` $ldCount `,` `st` `=`  $stCount `]` `(` $inputs `)` attr-dict `:` $memRefType `,` functional-type($inputs, $outputs)
</code></pre><p>Each MemoryOp represents an independent memory or memory region (BRAM or external memory).
It receives memory access requests from load and store operations. For every request,
it returns data (for load) and a data-less token indicating completion.
The memory op represents a flat, unidimensional memory.
Operands: all stores (stdata1, staddr1, stdata2, staddr2, &mldr;), then all loads (ldaddr1, ldaddr2,&mldr;)
Outputs: all load outputs, ordered the same as
load data (lddata1, lddata2, &mldr;), followed by all none outputs,
ordered as operands (stnone1, stnone2,&mldr;ldnone1, ldnone2,&mldr;)</p><p>Traits: <code>HasClock</code>, <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>MemoryOpInterface</code>, <code>NamedIOInterface</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>ldCount</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>stCount</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>memRefType</code></td><td>::mlir::TypeAttr</td><td>memref type attribute</td></tr><tr><td><code>lsq</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=handshakemerge-circthandshakemergeop><code>handshake.merge</code> (::circt::handshake::MergeOp)&nbsp;<a class=headline-hash href=#handshakemerge-circthandshakemergeop>¶</a></h3><p><em>Merge operation</em></p><p>The merge operation represents a (nondeterministic)
merge operation. Any input is propagated to the single output. The
number of inputs corresponds to the number of predecessor
blocks.</p><p>Example:</p><pre tabindex=0><code>%0 = merge %a, %b, %c : i32
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>MergeLikeOpInterface</code>, <code>NamedIOInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SOSTInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataOperands</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=handshakemux-circthandshakemuxop><code>handshake.mux</code> (::circt::handshake::MuxOp)&nbsp;<a class=headline-hash href=#handshakemux-circthandshakemuxop>¶</a></h3><p><em>Mux operation</em></p><p>The mux operation represents a(deterministic) merge operation.
Operands: select, data0, data1, data2, &mldr;</p><p>The &lsquo;select&rsquo; operand is received from ControlMerge of the same
block and it represents the index of the data operand that the mux
should propagate to its single output. The number of data inputs
corresponds to the number of predecessor blocks.</p><p>The mux operation is intended solely for control+dataflow selection.
For purely dataflow selection, use the &lsquo;select&rsquo; operation instead.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> mux <span class=nv>%select</span> <span class=p>[</span><span class=nv>%data0</span><span class=p>,</span> <span class=nv>%data1</span><span class=p>,</span> <span class=nv>%data2</span><span class=p>]</span> <span class=p>{</span>attributes<span class=p>}:</span> <span class=k>index</span><span class=p>,</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>InferTypeOpInterface</code>, <code>MergeLikeOpInterface</code>, <code>NamedIOInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>selectOperand</code></td><td>any type</td></tr><tr><td style=text-align:center><code>dataOperands</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=handshakenever-circthandshakeneverop><code>handshake.never</code> (::circt::handshake::NeverOp)&nbsp;<a class=headline-hash href=#handshakenever-circthandshakeneverop>¶</a></h3><p><em>Never operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `handshake.never` attr-dict `:` qualified(type($result))
</code></pre><p>The never operation represents disconnected data
source. The source never sets any &lsquo;valid&rsquo; signal which will
never trigger the successor at any point in time.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ControlInterface</code>, <code>NamedIOInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=handshakepack-circthandshakepackop><code>handshake.pack</code> (::circt::handshake::PackOp)&nbsp;<a class=headline-hash href=#handshakepack-circthandshakepackop>¶</a></h3><p><em>Packs a tuple</em></p><p>The <code>pack</code> operation constructs a tuple from separate values.
The number of operands corresponds to the number of tuple elements.
Similar to <code>join</code>, the output is ready when all inputs are ready.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tuple</span> <span class=p>=</span> handshake<span class=p>.</span>pack <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>{</span>attributes<span class=p>}</span> <span class=p>:</span> tuple<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> <span class=k>i64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>GeneralOpInterface</code>, <code>NamedIOInterface</code></p><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Fixed-sized collection of other types</td></tr></tbody></table><h3 id=handshakereturn-circthandshakereturnop><code>handshake.return</code> (::circt::handshake::ReturnOp)&nbsp;<a class=headline-hash href=#handshakereturn-circthandshakereturnop>¶</a></h3><p><em>Handshake dialect return.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `handshake.return` attr-dict ($opOperands^ `:` type($opOperands))?
</code></pre><p>The return operation represents a handshaked
function. This is almost exactly like a standard ReturnOp, except
that it exists in a handshake.func. It has the same operands as
standard ReturnOp which it replaces and an additional control -
only operand(exit point of control - only network).</p><p>Traits: <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code>, <code>Terminator</code></p><p>Interfaces: <code>ControlInterface</code>, <code>NamedIOInterface</code></p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>opOperands</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=handshakesink-circthandshakesinkop><code>handshake.sink</code> (::circt::handshake::SinkOp)&nbsp;<a class=headline-hash href=#handshakesink-circthandshakesinkop>¶</a></h3><p><em>Sink operation</em></p><p>The sink operation discards any data that arrives at its
input.The sink has no successors and it can continuously consume data.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>sink <span class=nv>%data</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>NamedIOInterface</code>, <code>SOSTInterface</code></p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>any type</td></tr></tbody></table><h3 id=handshakesource-circthandshakesourceop><code>handshake.source</code> (::circt::handshake::SourceOp)&nbsp;<a class=headline-hash href=#handshakesource-circthandshakesourceop>¶</a></h3><p><em>Source operation</em></p><p>The source operation represents continuous token
source. The source continously sets a &lsquo;valid&rsquo; signal which the
successor can consume at any point in time.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ControlInterface</code>, <code>NamedIOInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SOSTInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=handshakestore-circthandshakestoreop><code>handshake.store</code> (::circt::handshake::StoreOp)&nbsp;<a class=headline-hash href=#handshakestore-circthandshakestoreop>¶</a></h3><p><em>Store operation</em></p><p>Store memory port, sends store requests to MemoryOp. From dataflow
predecessors, receives address indices, data, and a control-only
value which signals completion of all previous memory accesses
which target the same memory. When all inputs are received, the
store sends the address and data to MemoryOp.</p><p>Operands: address indices, data, control-only input.
Results: data and address indices (sent to MemoryOp).
Types: data type followed by address type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%dataToMem</span><span class=p>,</span> <span class=nv>%addrToMem</span> <span class=p>=</span> store <span class=p>[</span><span class=nv>%addr1</span><span class=p>,</span> <span class=nv>%addr2</span><span class=p>]</span> <span class=nv>%dataFromPred</span> <span class=p>,</span> <span class=nv>%ctrl</span> <span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i16</span><span class=p>,</span> <span class=k>index</span>
</span></span></code></pre></div><p>Traits: <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>GeneralOpInterface</code>, <code>NamedIOInterface</code></p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addresses</code></td><td>variadic of any type</td></tr><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr><tr><td style=text-align:center><code>ctrl</code></td><td>none type</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dataResult</code></td><td>any type</td></tr><tr><td style=text-align:center><code>addressResult</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=handshakesync-circthandshakesyncop><code>handshake.sync</code> (::circt::handshake::SyncOp)&nbsp;<a class=headline-hash href=#handshakesync-circthandshakesyncop>¶</a></h3><p><em>Sync operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `handshake.sync` $operands attr-dict `:` type($operands)
</code></pre><p>Synchronizes an arbitrary set of inputs. Synchronization implies applying
join semantics in between all in- and output ports.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%aSynced</span><span class=p>,</span> <span class=nv>%bSynced</span><span class=p>,</span> <span class=nv>%cSynced</span> <span class=p>=</span> sync <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> none
</span></span></code></pre></div><p>Traits: <code>HasClock</code>, <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>GeneralOpInterface</code>, <code>NamedIOInterface</code></p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=handshakeunpack-circthandshakeunpackop><code>handshake.unpack</code> (::circt::handshake::UnpackOp)&nbsp;<a class=headline-hash href=#handshakeunpack-circthandshakeunpackop>¶</a></h3><p><em>Unpacks a tuple</em></p><p>The <code>unpack</code> operation assigns each value of a tuple to a separate
value for further processing. The number of results corresponds
to the number of tuple elements.
Similar to <code>fork</code>, each output is distributed as soon as the corresponding
successor is ready.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>=</span> handshake<span class=p>.</span>unpack <span class=nv>%tuple</span> <span class=p>{</span>attributes<span class=p>}</span> <span class=p>:</span> tuple<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> <span class=k>i64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>HasClock</code>, <code>HasParentInterface&lt;FineGrainedDataflowRegionOpInterface></code></p><p>Interfaces: <code>ControlInterface</code>, <code>ExecutableOpInterface</code>, <code>GeneralOpInterface</code>, <code>NamedIOInterface</code></p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>Fixed-sized collection of other types</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h2 id=attributes-6>Attributes&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h2><h3 id=buffertypeenumattr>BufferTypeEnumAttr&nbsp;<a class=headline-hash href=#buffertypeenumattr>¶</a></h3><p>BufferOp seq or fifo</p><p>Syntax:</p><pre tabindex=0><code>#handshake.buffer_type_enum&lt;
  ::BufferTypeEnum   # value
&gt;
</code></pre><p>Enum cases:</p><ul><li>seq (<code>seq</code>)</li><li>fifo (<code>fifo</code>)</li></ul><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::BufferTypeEnum</code></td><td>an enum of type BufferTypeEnum</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/Handshake/ title="'handshake' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'handshake' Dialect</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/HW/ title="'hw' Dialect">Next - 'hw' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark opened">-</span></a><ul class=sub-menu><li class=active><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>