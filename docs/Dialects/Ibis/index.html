<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'ibis' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/Ibis/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'ibis' Dialect</h1><p>Types and operations for Ibis dialect
The <code>ibis</code> dialect is intended to support porting and eventual open sourcing
of an internal hardware development language.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#ibiscall-circtibiscallop><code>ibis.call</code> (::circt::ibis::CallOp)</a></li><li><a href=#ibisclass-circtibisclassop><code>ibis.class</code> (::circt::ibis::ClassOp)</a></li><li><a href=#ibiscontainerinner-circtibisinnercontainerop><code>ibis.container.inner</code> (::circt::ibis::InnerContainerOp)</a></li><li><a href=#ibiscontainerinstance-circtibiscontainerinstanceop><code>ibis.container.instance</code> (::circt::ibis::ContainerInstanceOp)</a></li><li><a href=#ibiscontainerouter-circtibisoutercontainerop><code>ibis.container.outer</code> (::circt::ibis::OuterContainerOp)</a></li><li><a href=#ibisget_port-circtibisgetportop><code>ibis.get_port</code> (::circt::ibis::GetPortOp)</a></li><li><a href=#ibisget_var-circtibisgetvarop><code>ibis.get_var</code> (::circt::ibis::GetVarOp)</a></li><li><a href=#ibisinstance-circtibisinstanceop><code>ibis.instance</code> (::circt::ibis::InstanceOp)</a></li><li><a href=#ibismethod-circtibismethodop><code>ibis.method</code> (::circt::ibis::MethodOp)</a></li><li><a href=#ibismethoddf-circtibisdataflowmethodop><code>ibis.method.df</code> (::circt::ibis::DataflowMethodOp)</a></li><li><a href=#ibispath-circtibispathop><code>ibis.path</code> (::circt::ibis::PathOp)</a></li><li><a href=#ibispipelineheader-circtibispipelineheaderop><code>ibis.pipeline.header</code> (::circt::ibis::PipelineHeaderOp)</a></li><li><a href=#ibisportinput-circtibisinputportop><code>ibis.port.input</code> (::circt::ibis::InputPortOp)</a></li><li><a href=#ibisportoutput-circtibisoutputportop><code>ibis.port.output</code> (::circt::ibis::OutputPortOp)</a></li><li><a href=#ibisportread-circtibisportreadop><code>ibis.port.read</code> (::circt::ibis::PortReadOp)</a></li><li><a href=#ibisportwrite-circtibisportwriteop><code>ibis.port.write</code> (::circt::ibis::PortWriteOp)</a></li><li><a href=#ibisreturn-circtibisreturnop><code>ibis.return</code> (::circt::ibis::ReturnOp)</a></li><li><a href=#ibissblock-circtibisstaticblockop><code>ibis.sblock</code> (::circt::ibis::StaticBlockOp)</a></li><li><a href=#ibissblockdc-circtibisdcblockop><code>ibis.sblock.dc</code> (::circt::ibis::DCBlockOp)</a></li><li><a href=#ibissblockinlinebegin-circtibisinlinestaticblockbeginop><code>ibis.sblock.inline.begin</code> (::circt::ibis::InlineStaticBlockBeginOp)</a></li><li><a href=#ibissblockinlineend-circtibisinlinestaticblockendop><code>ibis.sblock.inline.end</code> (::circt::ibis::InlineStaticBlockEndOp)</a></li><li><a href=#ibissblockisolated-circtibisisolatedstaticblockop><code>ibis.sblock.isolated</code> (::circt::ibis::IsolatedStaticBlockOp)</a></li><li><a href=#ibissblockreturn-circtibisblockreturnop><code>ibis.sblock.return</code> (::circt::ibis::BlockReturnOp)</a></li><li><a href=#ibisthis-circtibisthisop><code>ibis.this</code> (::circt::ibis::ThisOp)</a></li><li><a href=#ibisvar-circtibisvarop><code>ibis.var</code> (::circt::ibis::VarOp)</a></li><li><a href=#ibiswireinput-circtibisinputwireop><code>ibis.wire.input</code> (::circt::ibis::InputWireOp)</a></li><li><a href=#ibiswireoutput-circtibisoutputwireop><code>ibis.wire.output</code> (::circt::ibis::OutputWireOp)</a></li></ul></li><li><a href=#attributes-20>Attributes</a><ul><li><a href=#pathstepattr>PathStepAttr</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#portreftype>PortRefType</a></li><li><a href=#scopereftype>ScopeRefType</a></li></ul></li></ul></nav><h2 id=operations>Operations</h2><h3 id=ibiscall-circtibiscallop><code>ibis.call</code> (::circt::ibis::CallOp)</h3><p><em>Ibis method call</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.call` $callee `(` $operands `)` attr-dict `:` functional-type($operands, results)
</code></pre><p>Dispatch a call to an Ibis method.</p><p>Interfaces: <code>CallOpInterface</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>callee</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>variadic of any type</td></tr></tbody></table><h3 id=ibisclass-circtibisclassop><code>ibis.class</code> (::circt::ibis::ClassOp)</h3><p><em>Ibis class</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.class` $sym_name attr-dict-with-keyword $body
</code></pre><p>Ibis has the notion of a class which can contain methods and member
variables.</p><p>In the low-level Ibis representation, the ClassOp becomes a container for
<code>ibis.port</code>s, <code>ibis.container</code>s, and contain logic for member variables.</p><p>Traits: <code>HasParent&lt;mlir::ModuleOp></code>, <code>InnerSymbolTable</code>, <code>IsolatedFromAbove</code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>InstanceGraphModuleOpInterface</code>, <code>RegionKindInterface</code>, <code>ScopeOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=ibiscontainerinner-circtibisinnercontainerop><code>ibis.container.inner</code> (::circt::ibis::InnerContainerOp)</h3><p><em>Ibis container</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.container.inner` $inner_sym attr-dict-with-keyword $body
</code></pre><p>An ibis container describes a collection of logic nested within an Ibis
class. We have two container types (ops): one for the outermost containers
and one for the nested containers (inner). The outer container is a symbol
and sits in the symbol table at the top level. So as to not violate the
symbol table rules, the inner container is an InnerSymbol and is contained
in the InnerSymbolTable that the outer container defines.</p><p>Traits: <code>IsolatedFromAbove</code>, <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>ContainerOpInterface</code>, <code>InnerSymbolOpInterface</code>, <code>InstanceGraphModuleOpInterface</code>, <code>RegionKindInterface</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h3 id=ibiscontainerinstance-circtibiscontainerinstanceop><code>ibis.container.instance</code> (::circt::ibis::ContainerInstanceOp)</h3><p><em>Ibis container instance</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.container.instance` $inner_sym `,` $targetName attr-dict
              custom&lt;ScopeRefFromName&gt;(type($scopeRef), ref($targetName))
</code></pre><p>Instantiates an Ibis container.</p><p>Interfaces: <code>HasCustomSSAName</code>, <code>InnerSymbolOpInterface</code>, <code>InstanceGraphInstanceOpInterface</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td><code>targetName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>scopeRef</code></td><td></td></tr></tbody></table><h3 id=ibiscontainerouter-circtibisoutercontainerop><code>ibis.container.outer</code> (::circt::ibis::OuterContainerOp)</h3><p><em>Ibis container</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.container.outer` $sym_name attr-dict-with-keyword $body
</code></pre><p>An ibis container describes a collection of logic nested within an Ibis
class. We have two container types (ops): one for the outermost containers
and one for the nested containers (inner). The outer container is a symbol
and sits in the symbol table at the top level. So as to not violate the
symbol table rules, the inner container is an InnerSymbol and is contained
in the InnerSymbolTable that the outer container defines.</p><p>Traits: <code>InnerSymbolTable</code>, <code>IsolatedFromAbove</code>, <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>ContainerOpInterface</code>, <code>InstanceGraphModuleOpInterface</code>, <code>RegionKindInterface</code>, <code>ScopeOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=ibisget_port-circtibisgetportop><code>ibis.get_port</code> (::circt::ibis::GetPortOp)</h3><p><em>Ibis get port</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.get_port` $instance `,` $portSymbol `:` qualified(type($instance)) `-&gt;`
              qualified(type($port)) attr-dict
</code></pre><p>Given an Ibis class reference, returns a port of said class. The port
is specified by the symbol name of the port in the referenced class.</p><p>Importantly, the user must specify how they intend to use the op, by
specifying the direction of the portref type that this op is generated with.
If the request port is to be read from, the type must be <code>!ibis.portref&lt;out T></code>
and if the port is to be written to, the type must be <code>!ibis.portref&lt;in T></code>.
This is to ensure that the usage is reflected in the get_port type which in
turn is used by the tunneling passes to create the proper ports through the
hierarchy.</p><p>This implies that the portref direction of the get_port op is independent of
the actual direction of the target port, and only the inner portref type
must match.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InnerRefUserOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>portSymbol</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>instance</code></td><td></td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>port</code></td><td></td></tr></tbody></table><h3 id=ibisget_var-circtibisgetvarop><code>ibis.get_var</code> (::circt::ibis::GetVarOp)</h3><p><em>Dereferences an ibis member variable through a scoperef</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.get_var` $instance `,` $varName attr-dict `:` qualified(type($instance)) `-&gt;` qualified(type($var))
</code></pre><p>Interfaces: <code>HasCustomSSAName</code>, <code>InnerRefUserOpInterface</code></p><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>varName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>instance</code></td><td></td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>var</code></td><td>memref of any type values</td></tr></tbody></table><h3 id=ibisinstance-circtibisinstanceop><code>ibis.instance</code> (::circt::ibis::InstanceOp)</h3><p><em>Ibis class instance</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.instance` $inner_sym `,` $targetName attr-dict
              custom&lt;ScopeRefFromName&gt;(type($scopeRef), ref($targetName))
</code></pre><p>Instantiates an Ibis class.</p><p>Interfaces: <code>HasCustomSSAName</code>, <code>InnerSymbolOpInterface</code>, <code>InstanceGraphInstanceOpInterface</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-7>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td><code>targetName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>scopeRef</code></td><td></td></tr></tbody></table><h3 id=ibismethod-circtibismethodop><code>ibis.method</code> (::circt::ibis::MethodOp)</h3><p><em>Ibis method</em></p><p>Ibis methods are a lot like software functions: a list of named arguments
and unnamed return values with imperative control flow.</p><p>Traits: <code>AutomaticAllocationScope</code>, <code>HasParent&lt;ClassOp></code>, <code>IsolatedFromAbove</code></p><p>Interfaces: <code>InnerSymbolOpInterface</code>, <code>MethodLikeOpInterface</code>, <code>OpAsmOpInterface</code></p><h4 id=attributes-8>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type</td></tr><tr><td><code>argNames</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h3 id=ibismethoddf-circtibisdataflowmethodop><code>ibis.method.df</code> (::circt::ibis::DataflowMethodOp)</h3><p><em>Ibis dataflow method</em></p><p>Ibis dataflow methods share the same interface as an <code>ibis.method</code> but
without imperative CFG-based control flow. Instead, this method implements a
graph region, and control flow is expected to be defined by dataflow operations.</p><p>Traits: <code>HasParent&lt;ClassOp></code>, <code>IsolatedFromAbove</code>, <code>SingleBlockImplicitTerminator&lt;ibis::ReturnOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>FineGrainedDataflowRegionOpInterface</code>, <code>InnerSymbolOpInterface</code>, <code>MethodLikeOpInterface</code>, <code>RegionKindInterface</code></p><h4 id=attributes-9>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type</td></tr><tr><td><code>argNames</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h3 id=ibispath-circtibispathop><code>ibis.path</code> (::circt::ibis::PathOp)</h3><p><em>Ibis path</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.path` $path attr-dict
</code></pre><p>The <code>ibis.path</code> operation describes an instance hierarchy path relative to
the current scope. The path is specified by a list of either parent or
child identifiers (navigating up or down the hierarchy, respectively).</p><p>Scopes along the path are optionally typed, however, An <code>ibis.path</code> must
lways terminate in a fully typed specifier, i.e. never an <code>!ibis.scoperef&lt;></code>.</p><p>The operation returns a single <code>!ibis.scoperef</code>-typed value representing
the scope at the end of the path.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-10>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>path</code></td><td>::mlir::ArrayAttr</td><td>Path step array attribute</td></tr></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>instance</code></td><td></td></tr></tbody></table><h3 id=ibispipelineheader-circtibispipelineheaderop><code>ibis.pipeline.header</code> (::circt::ibis::PipelineHeaderOp)</h3><p><em>Ibis pipeline header operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.pipeline.header` attr-dict
</code></pre><p>This operation defines the hardware-like values used to drive a pipeline,
such as clock and reset.
This is an intermediate operation, meaning that it&rsquo;s strictly used to
facilitate progressive lowering of ibis static blocks to scheduled pipelines.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>reset</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>go</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>stall</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=ibisportinput-circtibisinputportop><code>ibis.port.input</code> (::circt::ibis::InputPortOp)</h3><p><em>Ibis input port</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.port.input` $inner_sym `:` $type attr-dict
</code></pre><p>Traits: <code>HasParent&lt;ClassOp, OuterContainerOp, InnerContainerOp></code></p><p>Interfaces: <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>InnerSymbolOpInterface</code>, <code>PortOpInterface</code></p><h4 id=attributes-11>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>type attribute of any type</td></tr></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>port</code></td><td></td></tr></tbody></table><h3 id=ibisportoutput-circtibisoutputportop><code>ibis.port.output</code> (::circt::ibis::OutputPortOp)</h3><p><em>Ibis output port</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.port.output` $inner_sym `:` $type attr-dict
</code></pre><p>Traits: <code>HasParent&lt;ClassOp, OuterContainerOp, InnerContainerOp></code></p><p>Interfaces: <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>InnerSymbolOpInterface</code>, <code>PortOpInterface</code></p><h4 id=attributes-12>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>type attribute of any type</td></tr></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>port</code></td><td></td></tr></tbody></table><h3 id=ibisportread-circtibisportreadop><code>ibis.port.read</code> (::circt::ibis::PortReadOp)</h3><p><em>Ibis port read</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.port.read` $port attr-dict `:` qualified(type($port))
</code></pre><p>Read the value of a port reference.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>port</code></td><td></td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>any type</td></tr></tbody></table><h3 id=ibisportwrite-circtibisportwriteop><code>ibis.port.write</code> (::circt::ibis::PortWriteOp)</h3><p><em>Ibis port write</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.port.write` $port `,` $value attr-dict `:` qualified(type($port))
</code></pre><p>Write a value to a port reference.</p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>port</code></td><td></td></tr><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h3 id=ibisreturn-circtibisreturnop><code>ibis.return</code> (::circt::ibis::ReturnOp)</h3><p><em>Ibis method terminator</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.return` ($retValues^)? attr-dict (`:` type($retValues)^)?
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;MethodOp, DataflowMethodOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>retValues</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=ibissblock-circtibisstaticblockop><code>ibis.sblock</code> (::circt::ibis::StaticBlockOp)</h3><p><em>Ibis block</em></p><p>The <code>ibis.sblock</code> operation defines a block wherein a group of operations
are expected to be statically scheduleable.
The operation is not isolated from above to facilitate ease of construction.
However, once a program has been constructed and lowered to a sufficient
level, the user may run <code>--ibis-argify-blocks</code> to effectively isolate the
block from above, by converting SSA values referenced through dominanes into
arguments of the block</p><p>The block may contain additional attributes to specify constraints on
the block further down the compilation pipeline.</p><p>Traits: <code>AutomaticAllocationScope</code>, <code>SingleBlockImplicitTerminator&lt;BlockReturnOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>BlockOpInterface</code></p><h4 id=attributes-13>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>maxThreads</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 1</td></tr></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=ibissblockdc-circtibisdcblockop><code>ibis.sblock.dc</code> (::circt::ibis::DCBlockOp)</h3><p><em>DC-interfaced Ibis block</em></p><p>The <code>ibis.sblock.dc</code> operation is like an <code>ibis.sblock</code> operation with
a few differences, being:</p><ol><li>The operation is DC-interfaced, meaning that all arguments and results
are dc-value typed.</li><li>The operation is IsolatedFromAbove.</li></ol><p>Traits: <code>AutomaticAllocationScope</code>, <code>IsolatedFromAbove</code>, <code>SingleBlockImplicitTerminator&lt;BlockReturnOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>BlockOpInterface</code></p><h4 id=attributes-14>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>maxThreads</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 1</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=ibissblockinlinebegin-circtibisinlinestaticblockbeginop><code>ibis.sblock.inline.begin</code> (::circt::ibis::InlineStaticBlockBeginOp)</h3><p><em>Ibis inline static block begin marker</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.sblock.inline.begin` attr-dict
</code></pre><p>The <code>ibis.sblock.inline.begin</code> operation is a marker that indicates the
begin of an inline static block.
The operation is used to maintain <code>ibis.sblocks</code> while in the Ibis inline
phase (to facilitate e.g. mem2reg).</p><p>The operation:</p><ol><li>denotes the begin of the sblock</li><li>carries whatever attributes that the source <code>ibis.sblock</code> carried.</li><li>is considered side-effectfull.</li></ol><p>Traits: <code>HasParent&lt;MethodOp></code></p><h3 id=ibissblockinlineend-circtibisinlinestaticblockendop><code>ibis.sblock.inline.end</code> (::circt::ibis::InlineStaticBlockEndOp)</h3><p><em>Ibis inline static block end marker</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.sblock.inline.end` attr-dict
</code></pre><p>The <code>ibis.sblock.inline.end</code> operation is a marker that indicates the
end of an inline static block.
The operation is used to maintain <code>ibis.sblocks</code> while in the Ibis inline
phase (to facilitate e.g. mem2reg).</p><p>Traits: <code>HasParent&lt;MethodOp></code></p><h3 id=ibissblockisolated-circtibisisolatedstaticblockop><code>ibis.sblock.isolated</code> (::circt::ibis::IsolatedStaticBlockOp)</h3><p><em>Ibis isolated block</em></p><p>The <code>ibis.sblock.isolated</code> operation is like an <code>ibis.sblock</code> operation
but with an IsolatedFromAbove condition, meaning that all arguments and
results are passed through the block as arguments and results.</p><p>Traits: <code>AutomaticAllocationScope</code>, <code>IsolatedFromAbove</code>, <code>SingleBlockImplicitTerminator&lt;BlockReturnOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>BlockOpInterface</code></p><h4 id=attributes-15>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>maxThreads</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 1</td></tr></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>outputs</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=ibissblockreturn-circtibisblockreturnop><code>ibis.sblock.return</code> (::circt::ibis::BlockReturnOp)</h3><p><em>Ibis static block terminator</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.sblock.return` ($retValues^)? attr-dict (`:` type($retValues)^)?
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;StaticBlockOp, IsolatedStaticBlockOp, DCBlockOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>retValues</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=ibisthis-circtibisthisop><code>ibis.this</code> (::circt::ibis::ThisOp)</h3><p><em>Return a handle to the current scope <code>!ibis.scoperef</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.this` $scopeName attr-dict custom&lt;ScopeRefFromName&gt;(type($thisRef), ref($scopeName))
</code></pre><p>Interfaces: <code>HasCustomSSAName</code>, <code>InnerRefUserOpInterface</code></p><h4 id=attributes-16>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scopeName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>thisRef</code></td><td></td></tr></tbody></table><h3 id=ibisvar-circtibisvarop><code>ibis.var</code> (::circt::ibis::VarOp)</h3><p><em>Ibis variable definition</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.var` $inner_sym `:` $type attr-dict
</code></pre><p>Defines an Ibis class member variable. The variable is typed with a
<code>memref.memref</code> type, and may define either a singleton or uni-dimensional
array of values.
<code>ibis.var</code> defines a symbol within the encompassing class scope which can
be dereferenced through a <code>!ibis.scoperef</code> value of the parent class.</p><p>Interfaces: <code>InnerSymbolOpInterface</code></p><h4 id=attributes-17>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any memref type</td></tr></table><h3 id=ibiswireinput-circtibisinputwireop><code>ibis.wire.input</code> (::circt::ibis::InputWireOp)</h3><p><em>Ibis input wire</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.wire.input` $inner_sym `:` qualified(type($output)) attr-dict
</code></pre><p>An input wire defines an <code>ibis.portref&lt;in T></code> port alongside a value
of type <code>T</code> which represents the value to-be-written to the wire.</p><p>Traits: <code>HasParent&lt;ClassOp, OuterContainerOp, InnerContainerOp></code></p><p>Interfaces: <code>HasCustomSSAName</code>, <code>InnerSymbolOpInterface</code>, <code>PortOpInterface</code></p><h4 id=attributes-18>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>port</code></td><td></td></tr><tr><td style=text-align:center><code>output</code></td><td>any type</td></tr></tbody></table><h3 id=ibiswireoutput-circtibisoutputwireop><code>ibis.wire.output</code> (::circt::ibis::OutputWireOp)</h3><p><em>Ibis output wire</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ibis.wire.output` $inner_sym `,` $input `:` qualified(type($input)) attr-dict
</code></pre><p>An output wire defines an <code>ibis.portref&lt;out T></code> port that can be read.
The operation takes an input value of type <code>T</code> which represents the value
on the output portref.</p><p>Traits: <code>HasParent&lt;ClassOp, OuterContainerOp, InnerContainerOp></code></p><p>Interfaces: <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>InnerSymbolOpInterface</code>, <code>PortOpInterface</code></p><h4 id=attributes-19>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>port</code></td><td></td></tr></tbody></table><h2 id=attributes-20>Attributes</h2><h3 id=pathstepattr>PathStepAttr</h3><p>Syntax:</p><pre tabindex=0><code>#ibis.step&lt;
  PathDirection,   # direction
  ::mlir::Type,   # type
  mlir::FlatSymbolRefAttr   # child
&gt;
</code></pre><p>Used to describe a single step in a path</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>direction</td><td style=text-align:center><code>PathDirection</code></td><td></td></tr><tr><td style=text-align:center>type</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>child</td><td style=text-align:center><code>mlir::FlatSymbolRefAttr</code></td><td></td></tr></tbody></table><h2 id=types>Types</h2><h3 id=portreftype>PortRefType</h3><p>Syntax:</p><pre tabindex=0><code>!ibis.portref&lt;
  TypeAttr,   # portTypeAttr
  ibis::Direction   # direction
&gt;
</code></pre><p>A reference to an Ibis port.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>portTypeAttr</td><td style=text-align:center><code>TypeAttr</code></td><td></td></tr><tr><td style=text-align:center>direction</td><td style=text-align:center><code>ibis::Direction</code></td><td></td></tr></tbody></table><h3 id=scopereftype>ScopeRefType</h3><p>Syntax:</p><pre tabindex=0><code>!ibis.scoperef&lt;
  mlir::FlatSymbolRefAttr   # scopeRef
&gt;
</code></pre><p>A reference to an Ibis scope. May be either a reference to a specific
scope (given a <code>$scopeName</code> argument) or an opaque reference.</p><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>scopeRef</td><td style=text-align:center><code>mlir::FlatSymbolRefAttr</code></td><td></td></tr></tbody></table><h2>'ibis' Dialect Docs</h2><ul><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/ title="HW Arith Dialect Rationale"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - HW Arith Dialect Rationale</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/ title="`ibis` Dialect Rationale">Next - `ibis` Dialect Rationale <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class="active has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>