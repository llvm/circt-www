<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'llhd' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/LLHD/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'llhd' Dialect</h1><p>A low-level hardware description dialect in MLIR.</p><p><nav id=TableOfContents><ul><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#llhdcon-circtllhdconnectop><code>llhd.con</code> (::circt::llhd::ConnectOp)</a></li><li><a href=#llhdconstant_time-circtllhdconstanttimeop><code>llhd.constant_time</code> (::circt::llhd::ConstantTimeOp)</a></li><li><a href=#llhddrv-circtllhddrvop><code>llhd.drv</code> (::circt::llhd::DrvOp)</a></li><li><a href=#llhdentity-circtllhdentityop><code>llhd.entity</code> (::circt::llhd::EntityOp)</a></li><li><a href=#llhdhalt-circtllhdhaltop><code>llhd.halt</code> (::circt::llhd::HaltOp)</a></li><li><a href=#llhdinst-circtllhdinstop><code>llhd.inst</code> (::circt::llhd::InstOp)</a></li><li><a href=#llhdload-circtllhdloadop><code>llhd.load</code> (::circt::llhd::LoadOp)</a></li><li><a href=#llhdoutput-circtllhdoutputop><code>llhd.output</code> (::circt::llhd::OutputOp)</a></li><li><a href=#llhdprb-circtllhdprbop><code>llhd.prb</code> (::circt::llhd::PrbOp)</a></li><li><a href=#llhdproc-circtllhdprocop><code>llhd.proc</code> (::circt::llhd::ProcOp)</a></li><li><a href=#llhdptrarray_get-circtllhdptrarraygetop><code>llhd.ptr.array_get</code> (::circt::llhd::PtrArrayGetOp)</a></li><li><a href=#llhdptrarray_slice-circtllhdptrarraysliceop><code>llhd.ptr.array_slice</code> (::circt::llhd::PtrArraySliceOp)</a></li><li><a href=#llhdptrextract-circtllhdptrextractop><code>llhd.ptr.extract</code> (::circt::llhd::PtrExtractOp)</a></li><li><a href=#llhdptrstruct_extract-circtllhdptrstructextractop><code>llhd.ptr.struct_extract</code> (::circt::llhd::PtrStructExtractOp)</a></li><li><a href=#llhdreg-circtllhdregop><code>llhd.reg</code> (::circt::llhd::RegOp)</a></li><li><a href=#llhdshl-circtllhdshlop><code>llhd.shl</code> (::circt::llhd::ShlOp)</a></li><li><a href=#llhdshr-circtllhdshrop><code>llhd.shr</code> (::circt::llhd::ShrOp)</a></li><li><a href=#llhdsigarray_get-circtllhdsigarraygetop><code>llhd.sig.array_get</code> (::circt::llhd::SigArrayGetOp)</a></li><li><a href=#llhdsigarray_slice-circtllhdsigarraysliceop><code>llhd.sig.array_slice</code> (::circt::llhd::SigArraySliceOp)</a></li><li><a href=#llhdsigextract-circtllhdsigextractop><code>llhd.sig.extract</code> (::circt::llhd::SigExtractOp)</a></li><li><a href=#llhdsig-circtllhdsigop><code>llhd.sig</code> (::circt::llhd::SigOp)</a></li><li><a href=#llhdsigstruct_extract-circtllhdsigstructextractop><code>llhd.sig.struct_extract</code> (::circt::llhd::SigStructExtractOp)</a></li><li><a href=#llhdstore-circtllhdstoreop><code>llhd.store</code> (::circt::llhd::StoreOp)</a></li><li><a href=#llhdvar-circtllhdvarop><code>llhd.var</code> (::circt::llhd::VarOp)</a></li><li><a href=#llhdwait-circtllhdwaitop><code>llhd.wait</code> (::circt::llhd::WaitOp)</a></li></ul></li><li><a href=#attribute-definition>Attribute definition</a><ul><li><a href=#timeattr>TimeAttr</a></li></ul></li><li><a href=#type-constraint-definition>Type constraint definition</a><ul><li><a href=#llhd-time-type>LLHD time type</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#ptrtype>PtrType</a></li><li><a href=#sigtype>SigType</a></li><li><a href=#timetype>TimeType</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition&nbsp;<a class=headline-hash href=#operation-definition>¶</a></h2><h3 id=llhdcon-circtllhdconnectop><code>llhd.con</code> (::circt::llhd::ConnectOp)&nbsp;<a class=headline-hash href=#llhdcon-circtllhdconnectop>¶</a></h3><p>Connect two signals.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.con` operands attr-dict `:` qualified(type($lhs))
</code></pre><p>The <code>con</code> instruction connects two signals such that they essentially become
one signal. All driven values on one signal will be reflected on the other.</p><p>Traits: HasParent<entityop>, SameTypeOperands</p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLHD sig type of an integer bitvector of one or more bits or an ArrayType or a StructType values</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLHD sig type of an integer bitvector of one or more bits or an ArrayType or a StructType values</td></tr></tbody></table><h3 id=llhdconstant_time-circtllhdconstanttimeop><code>llhd.constant_time</code> (::circt::llhd::ConstantTimeOp)&nbsp;<a class=headline-hash href=#llhdconstant_time-circtllhdconstanttimeop>¶</a></h3><p>Introduce a new time constant.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.constant_time` $value attr-dict
</code></pre><p>The <code>llhd.constant_time</code> instruction introduces a new constant time value as
an SSA-operator.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span><span class=kt>constant</span>_time <span class=nv>#llhd.time</span><span class=p>&lt;</span><span class=m>1</span>ns<span class=p>,</span> <span class=m>2</span>d<span class=p>,</span> <span class=m>3</span>d<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: ConstantLike</p><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td style=text-align:center>llhd::TimeAttr</td><td>time attribute</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LLHD time type</td></tr></tbody></table><h3 id=llhddrv-circtllhddrvop><code>llhd.drv</code> (::circt::llhd::DrvOp)&nbsp;<a class=headline-hash href=#llhddrv-circtllhddrvop>¶</a></h3><p>Drive a value into a signal.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.drv` $signal `,` $value `after` $time ( `if` $enable^ )? attr-dict `:`
              qualified(type($signal))
</code></pre><p>The <code>llhd.drv</code> operation drives a new value onto a signal. A time
operand also has to be passed, which specifies the frequency at which
the drive will be performed. An optional enable value can be passed as
last argument. In this case the drive will only be performed if the
value is 1. In case no enable signal is passed the drive will always be
performed. This operation does not define any new SSA operands.</p><p>Syntax:</p><pre tabindex=0><code>drv-op ::= `llhd.drv` ssa-signal `,` ssa-const `after` ssa-time
  (`if` ssa-enable)? `:` !llhd.sig&lt;const-type&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%init</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%en</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>0</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%time</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=nv>#llhd.time</span><span class=p>&lt;</span><span class=m>1</span>ns<span class=p>,</span> <span class=m>0</span>d<span class=p>,</span> <span class=m>0</span>e<span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>time
</span></span><span class=line><span class=cl><span class=nv>%sig</span> <span class=p>=</span> llhd<span class=p>.</span>sig <span class=nv>%init</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%new</span> <span class=p>=</span> llhd<span class=p>.</span>not <span class=nv>%init</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>llhd<span class=p>.</span>drv <span class=nv>%sig</span><span class=p>,</span> <span class=nv>%new</span> after <span class=nv>%time</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>llhd<span class=p>.</span>drv <span class=nv>%sig</span><span class=p>,</span> <span class=nv>%new</span> after <span class=nv>%time</span> if <span class=nv>%en</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>signal</code></td><td>LLHD sig type of an integer bitvector of one or more bits or an ArrayType or a StructType values</td></tr><tr><td style=text-align:center><code>value</code></td><td>an integer bitvector of one or more bits or an ArrayType or a StructType</td></tr><tr><td style=text-align:center><code>time</code></td><td>LLHD time type</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=llhdentity-circtllhdentityop><code>llhd.entity</code> (::circt::llhd::EntityOp)&nbsp;<a class=headline-hash href=#llhdentity-circtllhdentityop>¶</a></h3><p>Create an entity.</p><p>The <code>llhd.entity</code> operation defines a new entity unit. An entity
represents the data-flow description of how a circuit&rsquo;s output values
change in reaction to changing input values.
An entity contains one region with a single block and an implicit
<code>TerminatorOp</code> terminator. Both the block name and terminator are
omitted in the custom syntax. No further blocks and control-flow are
legal inside an entity.</p><p>Syntax:</p><pre tabindex=0><code>entity-op ::= `llhd.entity` entity-symbol `(` arg-list `)` `-&gt;`
  `(` out-list `)` attr-dict entity-region
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llhd<span class=p>.</span>entity <span class=nf>@Foo</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>0</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  <span class=nv>%toggle</span> <span class=p>=</span> llhd<span class=p>.</span>sig <span class=nv>%0</span> <span class=p>:</span> <span class=k>i1</span> <span class=p>-&gt;</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>prb <span class=nv>%toggle</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  <span class=nv>%2</span> <span class=p>=</span> llhd<span class=p>.</span>not <span class=nv>%1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  <span class=nv>%dt</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=nv>#llhd.time</span><span class=p>&lt;</span><span class=m>1</span>ns<span class=p>,</span> <span class=m>0</span>d<span class=p>,</span> <span class=m>0</span>e<span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>time
</span></span><span class=line><span class=cl>  llhd<span class=p>.</span>drv <span class=nv>%toggle</span><span class=p>,</span> <span class=nv>%2</span><span class=p>,</span> <span class=nv>%dt</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;,</span> <span class=k>i1</span><span class=p>,</span> <span class=p>!</span>llhd<span class=p>.</span>time
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: IsolatedFromAbove, NoTerminator, SingleBlock</p><p>Interfaces: CallableOpInterface, FunctionOpInterface, Symbol</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ins</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h3 id=llhdhalt-circtllhdhaltop><code>llhd.halt</code> (::circt::llhd::HaltOp)&nbsp;<a class=headline-hash href=#llhdhalt-circtllhdhaltop>¶</a></h3><p>Terminates execution of a process.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.halt` attr-dict
</code></pre><p>The <code>halt</code> instruction terminates execution of a process. All processes
must halt eventually or consist of an infinite loop.</p><ul><li>This is a terminator instruction</li><li>This instruction is only allowed in processes (<code>llhd.proc</code>).</li></ul><p>Syntax:</p><pre tabindex=0><code>halt-op ::= `llhd.halt`
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llhd<span class=p>.</span>halt
</span></span></code></pre></div><p>Traits: HasParent<procop>, Terminator</p><h3 id=llhdinst-circtllhdinstop><code>llhd.inst</code> (::circt::llhd::InstOp)&nbsp;<a class=headline-hash href=#llhdinst-circtllhdinstop>¶</a></h3><p>Instantiates a process or entity.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.inst` $name $callee `(` $inputs `)` `-&gt;` `(` $outputs `)` attr-dict `:`
              functional-type($inputs, $outputs)
</code></pre><p>Instantiates a process or entity and thus allows to build hierarchies.
Can only be used within an entity. An instance defines a unique name
within the entity it resides in.</p><p>Syntax:</p><pre tabindex=0><code>inst-op ::= `llhd.inst` inst-name symbol-name `(` ssa-input-list `)` `-&gt;`
  `(` ssa-output-list `)` attr-dict `:`
  functional-type(ssa-input-list, ssa-output-list)
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llhd<span class=p>.</span>inst <span class=s>&#34;foo&#34;</span> <span class=nf>@empty</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>llhd<span class=p>.</span>inst <span class=s>&#34;bar&#34;</span> <span class=nf>@proc_symbol</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=nv>%out0</span><span class=p>)</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>llhd<span class=p>.</span>inst <span class=s>&#34;baz&#34;</span> <span class=nf>@entity_symbol</span><span class=p>(</span><span class=nv>%in0</span><span class=p>,</span> <span class=nv>%in1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=nv>%out0</span><span class=p>,</span> <span class=nv>%out1</span><span class=p>)</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>(!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i16</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>(!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;,</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i4</span><span class=p>&gt;)</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments, HasParent<entityop></p><p>Interfaces: CallOpInterface</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>callee</code></td><td style=text-align:center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>LLHD sig type of an integer bitvector of one or more bits or an ArrayType or a StructType values</td></tr><tr><td style=text-align:center><code>outputs</code></td><td>LLHD sig type of an integer bitvector of one or more bits or an ArrayType or a StructType values</td></tr></tbody></table><h3 id=llhdload-circtllhdloadop><code>llhd.load</code> (::circt::llhd::LoadOp)&nbsp;<a class=headline-hash href=#llhdload-circtllhdloadop>¶</a></h3><p>Load a value.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.load` $pointer attr-dict `:` qualified(type($pointer))
</code></pre><p>The <code>llhd.load</code> operation loads a value from a memory region given by
<code>pointer</code>.</p><p><strong>Examples:</strong></p><pre tabindex=0><code>%int = llhd.const 0 : i32
%arr = llhd.array_uniform %int : !llhd.array&lt;3xi32&gt;
%iPtr = llhd.var %int : i32
%arrPtr = llhd.var %arr : !llhd.array&lt;3xi32&gt;

%iLd = llhd.load %iPtr : !llhd.ptr&lt;i32&gt;
%arrLd = llhd.load %arrPtr : !llhd.ptr&lt;!llhd.array&lt;3xi32&gt;&gt;
</code></pre><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>LLHD pointer type of an integer bitvector of one or more bits or an ArrayType or a StructType values</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>an integer bitvector of one or more bits or an ArrayType or a StructType</td></tr></tbody></table><h3 id=llhdoutput-circtllhdoutputop><code>llhd.output</code> (::circt::llhd::OutputOp)&nbsp;<a class=headline-hash href=#llhdoutput-circtllhdoutputop>¶</a></h3><p>Introduce a new signal and drive a value onto it.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.output` ( $name^ )? $value `after` $time attr-dict `:` qualified(type($value))
</code></pre><p>The <code>llhd.output</code> operation introduces a new signal and continuously
drives a the given value onto it after a given time-delay. The same
value is used to initialize the signal in the same way as the &lsquo;init&rsquo;
value in <code>llhd.sig</code>. An optional name can be given to the created signal.
This shows up, e.g., in the simulation trace.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%value</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%time</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=nv>#llhd.time</span><span class=p>&lt;</span><span class=m>1</span>ns<span class=p>,</span> <span class=m>0</span>d<span class=p>,</span> <span class=m>0</span>e<span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>time
</span></span><span class=line><span class=cl><span class=nv>%sig</span> <span class=p>=</span> llhd<span class=p>.</span>output <span class=s>&#34;sigName&#34;</span> <span class=nv>%value</span> after <span class=nv>%time</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// is equivalent to
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>%value</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%time</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=nv>#llhd.time</span><span class=p>&lt;</span><span class=m>1</span>ns<span class=p>,</span> <span class=m>0</span>d<span class=p>,</span> <span class=m>0</span>e<span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>time
</span></span><span class=line><span class=cl><span class=nv>%sig</span> <span class=p>=</span> llhd<span class=p>.</span>sig <span class=s>&#34;sigName&#34;</span> <span class=nv>%value</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>llhd<span class=p>.</span>drv <span class=nv>%sig</span><span class=p>,</span> <span class=nv>%value</span> after <span class=nv>%time</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>an integer bitvector of one or more bits or an ArrayType or a StructType</td></tr><tr><td style=text-align:center><code>time</code></td><td>LLHD time type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LLHD sig type of an integer bitvector of one or more bits or an ArrayType or a StructType values</td></tr></tbody></table><h3 id=llhdprb-circtllhdprbop><code>llhd.prb</code> (::circt::llhd::PrbOp)&nbsp;<a class=headline-hash href=#llhdprb-circtllhdprbop>¶</a></h3><p>Probe a signal.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.prb` $signal attr-dict `:` qualified(type($signal))
</code></pre><p>The <code>llhd.prb</code> instruction probes a signal and returns the value it
currently carries as a new SSA operand. The result type is always
the type carried by the signal.</p><p>Syntax:</p><pre tabindex=0><code>prb-op ::= ssa-id `=` `llhd.prb` ssa-sig attr-dict `:` !llhd.sig&lt;type&gt;
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%const_i1</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%sig_i1</span> <span class=p>=</span> llhd<span class=p>.</span>sig <span class=nv>%const_i1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%prbd</span> <span class=p>=</span> llhd<span class=p>.</span>prb <span class=nv>%sig_i1</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>signal</code></td><td>LLHD sig type of an integer bitvector of one or more bits or an ArrayType or a StructType values</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>an integer bitvector of one or more bits or an ArrayType or a StructType</td></tr></tbody></table><h3 id=llhdproc-circtllhdprocop><code>llhd.proc</code> (::circt::llhd::ProcOp)&nbsp;<a class=headline-hash href=#llhdproc-circtllhdprocop>¶</a></h3><p>Create a process</p><p>A <code>llhd.proc</code> represents control-flow in a timed fashion. It allows a
procedural description of how a circuit&rsquo;s output signals change in
reaction to changing input signals. It has a region with arbitrarily
many basic blocks. The first block is the entry block and cannot be
targeted by the terminators. It uses <code>llhd.wait</code> as a terminator to add
timed control-flow. Immediate control-flow with <code>br</code> or <code>cond_br</code> is
also possible. Every process must either contain an infinite loop or
terminate with the <code>llhd.halt</code> terminator.</p><p>How does a process compare to functions and entities?</p><table><thead><tr><th>Unit</th><th>Paradigm</th><th>Timing</th><th>Models</th></tr></thead><tbody><tr><td>Function</td><td>control-flow</td><td>immediate</td><td>Computation in zero time</td></tr><tr><td>Process</td><td>control-flow</td><td>timed</td><td>Behavioral circuit description</td></tr><tr><td>Entity</td><td>data-flow</td><td>timed</td><td>Structural circuit description</td></tr></tbody></table><p>Syntax:</p><pre tabindex=0><code>proc-op ::= `llhd.proc` proc-symbol `(` ssa-input-list `)` `-&gt;`
  `(` ssa-output-list `)` attr-dict `{` proc-region `}`
</code></pre><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llhd<span class=p>.</span>proc <span class=nf>@example</span><span class=p>(</span><span class=nv>%in0</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;,</span> <span class=nv>%in1</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span> <span class=p>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>%out2</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  br <span class=nl>^bb1
</span></span></span><span class=line><span class=cl><span class=nl>^bb1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  llhd<span class=p>.</span>halt
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: IsolatedFromAbove</p><p>Interfaces: CallableOpInterface, FunctionOpInterface, Symbol</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ins</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></tbody></table><h3 id=llhdptrarray_get-circtllhdptrarraygetop><code>llhd.ptr.array_get</code> (::circt::llhd::PtrArrayGetOp)&nbsp;<a class=headline-hash href=#llhdptrarray_get-circtllhdptrarraygetop>¶</a></h3><p>Extract an element from a pointer to an array.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.ptr.array_get` $input `[` $index `]` attr-dict `:` qualified(type($input))
</code></pre><p>The <code>llhd.ptr.array_get</code> operation allows to access the element of the
<code>$input</code> operand at position <code>$index</code>. A new pointer aliasing the element
will be returned.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Returns a !llhd.ptr&lt;i8&gt;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>ptr<span class=p>.</span>array_get <span class=nv>%arr</span><span class=p>[</span><span class=nv>%index</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>ptr<span class=p>&lt;!</span>hw<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>i8</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>LLHD pointer type of an ArrayType values</td></tr><tr><td style=text-align:center><code>index</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LLHD pointer type of a type without inout values</td></tr></tbody></table><h3 id=llhdptrarray_slice-circtllhdptrarraysliceop><code>llhd.ptr.array_slice</code> (::circt::llhd::PtrArraySliceOp)&nbsp;<a class=headline-hash href=#llhdptrarray_slice-circtllhdptrarraysliceop>¶</a></h3><p>Get a range of consecutive values from a pointer to an array</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.ptr.array_slice` $input `at` $lowIndex attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>llhd.ptr.array_slice</code> operation allows to access a sub-range of the
<code>$input</code> operand, starting at the index given by the <code>$lowIndex</code>
operand. The resulting slice length is defined by the result type.
Returns a pointer aliasing the elements of the slice.</p><p>Width of &rsquo;lowIndex&rsquo; is defined to be the precise number of bits required to
index the &lsquo;input&rsquo; array. More precisely: for an input array of size M,
the width of &rsquo;lowIndex&rsquo; is ceil(log2(M)). Lower and upper bound indexes
which are larger than the size of the &lsquo;input&rsquo; array results in undefined
behavior.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> llhd<span class=p>.</span>ptr<span class=p>.</span>array_slice <span class=nv>%input</span> at <span class=nv>%lowIndex</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>(!</span>llhd<span class=p>.</span>ptr<span class=p>&lt;!</span>hw<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>i8</span><span class=p>&gt;&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>llhd<span class=p>.</span>ptr<span class=p>&lt;!</span>hw<span class=p>.</span>array<span class=p>&lt;</span><span class=m>2x</span><span class=k>i8</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>LLHD pointer type of an ArrayType values</td></tr><tr><td style=text-align:center><code>lowIndex</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LLHD pointer type of an ArrayType values</td></tr></tbody></table><h3 id=llhdptrextract-circtllhdptrextractop><code>llhd.ptr.extract</code> (::circt::llhd::PtrExtractOp)&nbsp;<a class=headline-hash href=#llhdptrextract-circtllhdptrextractop>¶</a></h3><p>Extract a range of bits from an integer pointer</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.ptr.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>llhd.ptr.extract</code> operation allows to access a range of bits
of the <code>$input</code> operand, starting at the index given by the <code>$lowBit</code>
operand. The result length is defined by the result type.</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>LLHD pointer type of an integer bitvector of one or more bits values</td></tr><tr><td style=text-align:center><code>lowBit</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LLHD pointer type of an integer bitvector of one or more bits values</td></tr></tbody></table><h3 id=llhdptrstruct_extract-circtllhdptrstructextractop><code>llhd.ptr.struct_extract</code> (::circt::llhd::PtrStructExtractOp)&nbsp;<a class=headline-hash href=#llhdptrstruct_extract-circtllhdptrstructextractop>¶</a></h3><p>Extract a field from a pointer to a struct.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.ptr.struct_extract` $input `[` $field `]` attr-dict `:` qualified(type($input))
</code></pre><p>The <code>llhd.ptr.struct_extract</code> operation allows access to the field of the
<code>$input</code> operand given by its name via the <code>$field</code> attribute.
A new pointer aliasing the field will be returned.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Returns a !llhd.ptr&lt;i8&gt;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>ptr<span class=p>.</span>struct_extract <span class=nv>%struct</span><span class=p>[</span><span class=s>&#34;foo&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>ptr<span class=p>&lt;!</span>hw<span class=p>.</span>struct<span class=p>&lt;</span>foo<span class=p>:</span> <span class=k>i8</span><span class=p>,</span> bar<span class=p>:</span> <span class=k>i16</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>field</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>LLHD pointer type of a StructType values</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LLHD pointer type of a type without inout values</td></tr></tbody></table><h3 id=llhdreg-circtllhdregop><code>llhd.reg</code> (::circt::llhd::RegOp)&nbsp;<a class=headline-hash href=#llhdreg-circtllhdregop>¶</a></h3><p>Represents a storage element</p><p>This instruction represents a storage element. It drives its output onto
the &lsquo;signal&rsquo; value. An arbitrary amount of triggers can be added to the
storage element. However, at least one is required. They are quadruples
consisting of the new value to be stored if the trigger applies, the
mode and trigger value which specify when this trigger has to be applied
as well as a delay. Optionally, each triple may also have a gate
condition, in this case the trigger only applies if the gate is one. If
multiple triggers apply the left-most in the list takes precedence.</p><p>There are five modes available:</p><table><thead><tr><th>Mode</th><th>Meaning</th></tr></thead><tbody><tr><td>&ldquo;low&rdquo;</td><td>Storage element stores <code>value</code> while the <code>trigger</code> is low. Models active-low resets and low-transparent latches.</td></tr><tr><td>&ldquo;high&rdquo;</td><td>Storage element stores <code>value</code> while the <code>trigger</code> is high. Models active-high resets and high-transparent latches.</td></tr><tr><td>&ldquo;rise&rdquo;</td><td>Storage element stores <code>value</code> upon the rising edge of the <code>trigger</code>. Models rising-edge flip-flops.</td></tr><tr><td>&ldquo;fall&rdquo;</td><td>Storage element stores <code>value</code> upon the falling edge of the <code>trigger</code>. Models falling-edge flip-flops.</td></tr><tr><td>&ldquo;both&rdquo;</td><td>Storage element stores <code>value</code> upon the a rising or a falling edge of the <code>trigger</code>. Models dual-edge flip-flops.</td></tr></tbody></table><p>This instruction may only be used in an LLHD entity.</p><p>Syntax:</p><pre tabindex=0><code>reg-op ::= `llhd.reg` signal-ssa-value
  ( `,` `(` value-ssa-value `,` mode-string trigger-ssa-value `after`
  delay-ssa-value ( `if` gate-ssa-value )? `:` value-type )+
  attr-dict `:` signal-type
</code></pre><p>Examples:</p><p>A rising, falling, and dual-edge triggered flip-flop:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%D</span><span class=p>,</span> <span class=s>&#34;rise&#34;</span> <span class=nv>%CLK</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%D</span><span class=p>,</span> <span class=s>&#34;fall&#34;</span> <span class=nv>%CLK</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%D</span><span class=p>,</span> <span class=s>&#34;both&#34;</span> <span class=nv>%CLK</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>A rising-edge triggered flip-flop with active-low reset:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%init</span><span class=p>,</span> <span class=s>&#34;low&#34;</span> <span class=nv>%RSTB</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;),</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>%D</span><span class=p>,</span> <span class=s>&#34;rise&#34;</span> <span class=nv>%CLK</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>A rising-edge triggered enable flip-flop with active-low reset:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%init</span><span class=p>,</span> <span class=s>&#34;low&#34;</span> <span class=nv>%RSTB</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;),</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>%D</span><span class=p>,</span> <span class=s>&#34;rise&#34;</span> <span class=nv>%CLK</span> after <span class=nv>%T</span> if <span class=nv>%EN</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>A transparent-low and transparent-high latch:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%D</span><span class=p>,</span> <span class=s>&#34;low&#34;</span> <span class=nv>%CLK</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%D</span><span class=p>,</span> <span class=s>&#34;high&#34;</span> <span class=nv>%CLK</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>An SR latch:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>0</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>llhd<span class=p>.</span>reg <span class=nv>%Q</span><span class=p>,</span> <span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=s>&#34;high&#34;</span> <span class=nv>%R</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;),</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=s>&#34;high&#34;</span> <span class=nv>%S</span> after <span class=nv>%T</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments, HasParent<entityop></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>modes</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>reg mode array attribute</td></tr><tr><td style=text-align:center><code>gateMask</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>64-bit integer array attribute</td></tr></tbody></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>signal</code></td><td>LLHD sig type of an integer bitvector of one or more bits or an ArrayType or a StructType values</td></tr><tr><td style=text-align:center><code>values</code></td><td>an integer bitvector of one or more bits or an ArrayType or a StructType or LLHD sig type of an integer bitvector of one or more bits or an ArrayType or a StructType values</td></tr><tr><td style=text-align:center><code>triggers</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>delays</code></td><td>LLHD time type</td></tr><tr><td style=text-align:center><code>gates</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=llhdshl-circtllhdshlop><code>llhd.shl</code> (::circt::llhd::ShlOp)&nbsp;<a class=headline-hash href=#llhdshl-circtllhdshlop>¶</a></h3><p>Shifts a value to the left by a given amount.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.shl` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>The type of the base value and the hidden value must be the same, but
may differ in the number of bits or elements. The result always has the
same type (including width) of the base value.
The instruction is transparent to signals and pointers. For example,
passing a signal as argument will shift the underlying value and return
a signal to the shifted value.
Allowed (underlying) types are signless integers, nine-valued-logic values
and arrays. The shift amount has to be a signless integer. A shift amount
bigger than the number of bits or elements of the hidden value is undefined.
The hidden value is uncovered by non-zero shift amounts. E.g. consider
the four bit values <code>base = 0xf</code>, <code>hidden = 0xc</code> shifted by an amount of
three result in <code>0xe</code>.</p><p>Syntax:</p><pre tabindex=0><code>shl-op ::= ssa-id `=`
  `llhd.shl` ssa-base `,` ssa-hidden `,` ssa-amount attr-dict `:`
  `(` base-type `,` hidden-type `,` amount-type `)` `-&gt;` result-type
</code></pre><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>shl <span class=nv>%base</span><span class=p>,</span> <span class=nv>%hidden</span><span class=p>,</span> <span class=nv>%amount</span> <span class=p>:</span> <span class=p>(</span><span class=k>i4</span><span class=p>,</span> <span class=k>i2</span><span class=p>,</span> <span class=k>i2</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i4</span>
</span></span></code></pre></div><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base</code></td><td>an integer bitvector of one or more bits or an ArrayType or LLHD sig type of an integer bitvector of one or more bits or an ArrayType values or LLHD pointer type of an integer bitvector of one or more bits or an ArrayType values</td></tr><tr><td style=text-align:center><code>hidden</code></td><td>an integer bitvector of one or more bits or an ArrayType or LLHD sig type of an integer bitvector of one or more bits or an ArrayType values or LLHD pointer type of an integer bitvector of one or more bits or an ArrayType values</td></tr><tr><td style=text-align:center><code>amount</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>an integer bitvector of one or more bits or an ArrayType or LLHD sig type of an integer bitvector of one or more bits or an ArrayType values or LLHD pointer type of an integer bitvector of one or more bits or an ArrayType values</td></tr></tbody></table><h3 id=llhdshr-circtllhdshrop><code>llhd.shr</code> (::circt::llhd::ShrOp)&nbsp;<a class=headline-hash href=#llhdshr-circtllhdshrop>¶</a></h3><p>Shifts a value to the right by a given amount.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.shr` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>The type of the base value and the hidden value must be the same, but
may differ in the number of bits or elements. The result always has the
same type (including width) of the base value.
The instruction is transparent to signals and pointers. For example,
passing a signal as argument will shift the underlying value and return
a signal to the shifted value.
Allowed (underlying) types are signless integers, nine-valued-logic values
and arrays. The shift amount has to be a signless integer. A shift amount
bigger than the number of bits or elements of the hidden value is undefined.
The hidden value is uncovered by non-zero shift amounts. E.g. consider
the four bit values <code>base = 0xf</code>, <code>hidden = 0xc</code> shifted by an amount of
three result in <code>0x9</code>.</p><p>Syntax:</p><pre tabindex=0><code>shr-op ::= ssa-id `=`
  `llhd.shr` ssa-base `,` ssa-hidden `,` ssa-amount attr-dict `:`
  `(` base-type `,` hidden-type `,` amount-type `)` `-&gt;` result-type
</code></pre><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>shr <span class=nv>%base</span><span class=p>,</span> <span class=nv>%hidden</span><span class=p>,</span> <span class=nv>%amount</span> <span class=p>:</span> <span class=p>(</span><span class=k>i4</span><span class=p>,</span> <span class=k>i2</span><span class=p>,</span> <span class=k>i2</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i4</span>
</span></span></code></pre></div><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base</code></td><td>an integer bitvector of one or more bits or an ArrayType or LLHD sig type of an integer bitvector of one or more bits or an ArrayType values or LLHD pointer type of an integer bitvector of one or more bits or an ArrayType values</td></tr><tr><td style=text-align:center><code>hidden</code></td><td>an integer bitvector of one or more bits or an ArrayType or LLHD sig type of an integer bitvector of one or more bits or an ArrayType values or LLHD pointer type of an integer bitvector of one or more bits or an ArrayType values</td></tr><tr><td style=text-align:center><code>amount</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>an integer bitvector of one or more bits or an ArrayType or LLHD sig type of an integer bitvector of one or more bits or an ArrayType values or LLHD pointer type of an integer bitvector of one or more bits or an ArrayType values</td></tr></tbody></table><h3 id=llhdsigarray_get-circtllhdsigarraygetop><code>llhd.sig.array_get</code> (::circt::llhd::SigArrayGetOp)&nbsp;<a class=headline-hash href=#llhdsigarray_get-circtllhdsigarraygetop>¶</a></h3><p>Extract an element from a signal of an array.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.sig.array_get` $input `[` $index `]` attr-dict `:` qualified(type($input))
</code></pre><p>The <code>llhd.sig.array_get</code> operation allows to access the element of the
<code>$input</code> operand at position <code>$index</code>. A new subsignal aliasing the element
will be returned.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Returns a !llhd.sig&lt;i8&gt;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>sig<span class=p>.</span>array_get <span class=nv>%arr</span><span class=p>[</span><span class=nv>%index</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;!</span>hw<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>i8</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>LLHD sig type of an ArrayType values</td></tr><tr><td style=text-align:center><code>index</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LLHD sig type of a type without inout values</td></tr></tbody></table><h3 id=llhdsigarray_slice-circtllhdsigarraysliceop><code>llhd.sig.array_slice</code> (::circt::llhd::SigArraySliceOp)&nbsp;<a class=headline-hash href=#llhdsigarray_slice-circtllhdsigarraysliceop>¶</a></h3><p>Get a range of consecutive values from a signal of an array</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.sig.array_slice` $input `at` $lowIndex attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>llhd.sig.array_slice</code> operation allows to access a sub-range of the
<code>$input</code> operand, starting at the index given by the <code>$lowIndex</code>
operand. The resulting slice length is defined by the result type.
Returns a signal aliasing the elements of the slice.</p><p>Width of &rsquo;lowIndex&rsquo; is defined to be the precise number of bits required to
index the &lsquo;input&rsquo; array. More precisely: for an input array of size M,
the width of &rsquo;lowIndex&rsquo; is ceil(log2(M)). Lower and upper bound indexes
which are larger than the size of the &lsquo;input&rsquo; array results in undefined
behavior.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> llhd<span class=p>.</span>sig<span class=p>.</span>array_slice <span class=nv>%input</span> at <span class=nv>%lowIndex</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>(!</span>llhd<span class=p>.</span>sig<span class=p>&lt;!</span>hw<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>i8</span><span class=p>&gt;&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;!</span>hw<span class=p>.</span>array<span class=p>&lt;</span><span class=m>2x</span><span class=k>i8</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>LLHD sig type of an ArrayType values</td></tr><tr><td style=text-align:center><code>lowIndex</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LLHD sig type of an ArrayType values</td></tr></tbody></table><h3 id=llhdsigextract-circtllhdsigextractop><code>llhd.sig.extract</code> (::circt::llhd::SigExtractOp)&nbsp;<a class=headline-hash href=#llhdsigextract-circtllhdsigextractop>¶</a></h3><p>Extract a range of bits from an integer signal</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.sig.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
</code></pre><p>The <code>llhd.sig.extract</code> operation allows to access a range of bits
of the <code>$input</code> operand, starting at the index given by the <code>$lowBit</code>
operand. The result length is defined by the result type.</p><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>LLHD sig type of an integer bitvector of one or more bits values</td></tr><tr><td style=text-align:center><code>lowBit</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LLHD sig type of an integer bitvector of one or more bits values</td></tr></tbody></table><h3 id=llhdsig-circtllhdsigop><code>llhd.sig</code> (::circt::llhd::SigOp)&nbsp;<a class=headline-hash href=#llhdsig-circtllhdsigop>¶</a></h3><p>Create a signal.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.sig` $name $init attr-dict `:` qualified(type($init))
</code></pre><p>The <code>llhd.sig</code> instruction introduces a new signal in the IR. The input
operand determines the initial value carried by the signal, while the
result type will always be a signal carrying the type of the init operand.
A signal defines a unique name within the entity it resides in.</p><p>Syntax:</p><pre tabindex=0><code>sig-op ::= ssa-id `=` `llhd.sig` sig-name ssa-init attr-dict `:` init-type
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%init_i64</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>123</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=nv>%sig_i64</span> <span class=p>=</span> llhd<span class=p>.</span>sig <span class=s>&#34;foo&#34;</span> <span class=nv>%init_64</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%init_i1</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%sig_i1</span> <span class=p>=</span> llhd<span class=p>.</span>sig <span class=s>&#34;bar&#34;</span> <span class=nv>%init_i1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span></code></pre></div><p>The first <code>llhd.sig</code> instruction creates a new signal named &ldquo;foo&rdquo;, carrying
an <code>i64</code> type with initial value of 123, while the second one creates a new
signal named &ldquo;bar&rdquo;, carrying an <code>i1</code> type with initial value of 1.</p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>init</code></td><td>an integer bitvector of one or more bits or an ArrayType or a StructType</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LLHD sig type of an integer bitvector of one or more bits or an ArrayType or a StructType values</td></tr></tbody></table><h3 id=llhdsigstruct_extract-circtllhdsigstructextractop><code>llhd.sig.struct_extract</code> (::circt::llhd::SigStructExtractOp)&nbsp;<a class=headline-hash href=#llhdsigstruct_extract-circtllhdsigstructextractop>¶</a></h3><p>Extract a field from a signal of a struct.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.sig.struct_extract` $input `[` $field `]` attr-dict `:` qualified(type($input))
</code></pre><p>The <code>llhd.sig.struct_extract</code> operation allows access to the field of the
<code>$input</code> operand given by its name via the <code>$field</code> attribute.
A new subsignal aliasing the field will be returned.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Returns a !llhd.sig&lt;i8&gt;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llhd<span class=p>.</span>sig<span class=p>.</span>struct_extract <span class=nv>%struct</span><span class=p>[</span><span class=s>&#34;foo&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;!</span>hw<span class=p>.</span>struct<span class=p>&lt;</span>foo<span class=p>:</span> <span class=k>i8</span><span class=p>,</span> bar<span class=p>:</span> <span class=k>i16</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>field</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>LLHD sig type of a StructType values</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LLHD sig type of a type without inout values</td></tr></tbody></table><h3 id=llhdstore-circtllhdstoreop><code>llhd.store</code> (::circt::llhd::StoreOp)&nbsp;<a class=headline-hash href=#llhdstore-circtllhdstoreop>¶</a></h3><p>Store a value.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.store` $pointer `,` $value attr-dict `:` qualified(type($pointer))
</code></pre><p>The <code>llhd.store</code> operation stores the value <code>value</code> to the memory region
given by <code>pointer</code>.</p><p><strong>Examples:</strong></p><pre tabindex=0><code>%int = llhd.const 0 : i32
%arr = llhd.array_uniform %int : !llhd.array&lt;3xi32&gt;
%iPtr = llhd.var %int : i32
%arrPtr = llhd.var %arr : !llhd.array&lt;3xi32&gt;

llhd.store %iPtr, %int : !llhd.ptr&lt;i32&gt;
llhd.store %arrPtr, %arr : !llhd.ptr&lt;!llhd.array&lt;3xi32&gt;&gt;
</code></pre><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>LLHD pointer type of an integer bitvector of one or more bits or an ArrayType or a StructType values</td></tr><tr><td style=text-align:center><code>value</code></td><td>an integer bitvector of one or more bits or an ArrayType or a StructType</td></tr></tbody></table><h3 id=llhdvar-circtllhdvarop><code>llhd.var</code> (::circt::llhd::VarOp)&nbsp;<a class=headline-hash href=#llhdvar-circtllhdvarop>¶</a></h3><p>Stack allocation.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.var` $init attr-dict `:` qualified(type($init))
</code></pre><p>The <code>llhd.var</code> operation allocates a memory region on the stack with the
initial value given by <code>init</code>, and returns a pointer to the allocated
region.</p><p><strong>Examples:</strong></p><pre tabindex=0><code>%int = llhd.const 0 : i32
%arr = llhd.array_uniform %int : !llhd.array&lt;3xi32&gt;

%iPtr = llhd.var %int : i32
%arrPtr = llhd.var %arr : !llhd.array&lt;3xi32&gt;
</code></pre><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>init</code></td><td>an integer bitvector of one or more bits or an ArrayType or a StructType</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LLHD pointer type of an integer bitvector of one or more bits or an ArrayType or a StructType values</td></tr></tbody></table><h3 id=llhdwait-circtllhdwaitop><code>llhd.wait</code> (::circt::llhd::WaitOp)&nbsp;<a class=headline-hash href=#llhdwait-circtllhdwaitop>¶</a></h3><p>Suspends execution of a process.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llhd.wait` (`for` $time^ `,`)? (`(`$obs^ `:` qualified(type($obs))`)` `,`)?
              $dest (`(` $destOps^ `:` qualified(type($destOps)) `)`)? attr-dict
</code></pre><p>The <code>wait</code> instruction suspends execution of a process until any of the
observed signals change or a fixed time interval has passed. Execution
resumes at the specified basic block with the passed arguments.</p><ul><li>This is a terminator instruction.</li><li>This instruction is only allowed in processes (<code>llhd.proc</code>).</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llhd<span class=p>.</span>wait <span class=nl>^bb1
</span></span></span><span class=line><span class=cl><span class=nl></span>llhd<span class=p>.</span>wait for <span class=nv>%time</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%time</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>time<span class=p>)</span>
</span></span><span class=line><span class=cl>llhd<span class=p>.</span>wait <span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;,</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;),</span> <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>llhd<span class=p>.</span>wait for <span class=nv>%time</span><span class=p>,</span> <span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;,</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;),</span>
</span></span><span class=line><span class=cl>  <span class=nl>^bb1</span><span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;,</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;)</span>
</span></span></code></pre></div><p>Traits: AttrSizedOperandSegments, HasParent<procop>, Terminator</p><p>Interfaces: BranchOpInterface</p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>obs</code></td><td>LLHD sig type of an integer bitvector of one or more bits or an ArrayType or a StructType values</td></tr><tr><td style=text-align:center><code>time</code></td><td>LLHD time type</td></tr><tr><td style=text-align:center><code>destOps</code></td><td>any type</td></tr></tbody></table><h4 id=successors>Successors:&nbsp;<a class=headline-hash href=#successors>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>any successor</td></tr></tbody></table><h2 id=attribute-definition>Attribute definition&nbsp;<a class=headline-hash href=#attribute-definition>¶</a></h2><h3 id=timeattr>TimeAttr&nbsp;<a class=headline-hash href=#timeattr>¶</a></h3><p>time attribute</p><p>Represents a value of the LLHD time type.</p><p>Example: <code>#llhd.time&lt;0ns, 1d, 0e></code></p><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>type</td><td style=text-align:center><code>llhd::TimeType</code></td><td></td></tr><tr><td style=text-align:center>time</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>timeUnit</td><td style=text-align:center><code>::llvm::StringRef</code></td><td>SI time unit</td></tr><tr><td style=text-align:center>delta</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>epsilon</td><td style=text-align:center><code>unsigned</code></td><td></td></tr></tbody></table><h2 id=type-constraint-definition>Type constraint definition&nbsp;<a class=headline-hash href=#type-constraint-definition>¶</a></h2><h3 id=llhd-time-type>LLHD time type&nbsp;<a class=headline-hash href=#llhd-time-type>¶</a></h3><h2 id=type-definition>Type definition&nbsp;<a class=headline-hash href=#type-definition>¶</a></h2><h3 id=ptrtype>PtrType&nbsp;<a class=headline-hash href=#ptrtype>¶</a></h3><p>pointer type</p><p>Syntax:</p><pre tabindex=0><code>!llhd.ptr&lt;
  ::mlir::Type   # underlyingType
&gt;
</code></pre><p>Represents a pointer to a memory location holding a value of its element
type. May be used to load and store data in distinct memory slots.</p><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlyingType</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=sigtype>SigType&nbsp;<a class=headline-hash href=#sigtype>¶</a></h3><p>signal type</p><p>Syntax:</p><pre tabindex=0><code>!llhd.sig&lt;
  ::mlir::Type   # underlyingType
&gt;
</code></pre><p>Signals correspond directly to wires in a physical design, and are used to
model propagation delays and timing. Signals are used to carry values across
time steps in the LLHD execution model.</p><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>underlyingType</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=timetype>TimeType&nbsp;<a class=headline-hash href=#timetype>¶</a></h3><p>time type</p><p>Syntax: <code>!llhd.time</code></p><p>Represents a simulation time value as a combination of a real time value in
seconds (or any smaller SI time unit), a delta value representing
infinitesimal time steps, and an epsilon value representing an absolute time
slot within a delta step (used to model SystemVerilog scheduling regions).</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/ title="HW Dialect Rationale"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - HW Dialect Rationale</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/Moore/ title="'moore' Dialect">Next - 'moore' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=active><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li></ul></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/>PyCDE</a></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>