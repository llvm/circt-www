<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'ltl' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/LTL/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'ltl' Dialect</h1><p>This dialect provides operations and types to model
<a href=https://en.wikipedia.org/wiki/Linear_temporal_logic>Linear Temporal Logic</a>, sequences, and properties, which are useful for hardware verification.</p><p><nav id=TableOfContents><ul><li><a href=#rationale>Rationale</a><ul><li><a href=#sequences-and-properties>Sequences and Properties</a></li></ul></li><li><a href=#representing-svas>Representing SVAs</a><ul><li><a href=#sequence-concatenation-and-cycle-delay>Sequence Concatenation and Cycle Delay</a></li><li><a href=#implication>Implication</a></li><li><a href=#clocking>Clocking</a></li><li><a href=#disable-iff>Disable Iff</a></li></ul></li><li><a href=#representing-the-ltl-formalism>Representing the LTL Formalism</a><ul><li><a href=#next--delay>Next / Delay</a></li><li><a href=#concatenation>Concatenation</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#overview>Overview</a></li><li><a href=#propertytype>PropertyType</a></li><li><a href=#sequencetype>SequenceType</a></li></ul></li><li><a href=#operations>Operations</a><ul><li><a href=#ltland-circtltlandop><code>ltl.and</code> (circt::ltl::AndOp)</a></li><li><a href=#ltlclock-circtltlclockop><code>ltl.clock</code> (circt::ltl::ClockOp)</a></li><li><a href=#ltlconcat-circtltlconcatop><code>ltl.concat</code> (circt::ltl::ConcatOp)</a></li><li><a href=#ltldelay-circtltldelayop><code>ltl.delay</code> (circt::ltl::DelayOp)</a></li><li><a href=#ltldisable-circtltldisableop><code>ltl.disable</code> (circt::ltl::DisableOp)</a></li><li><a href=#ltleventually-circtltleventuallyop><code>ltl.eventually</code> (circt::ltl::EventuallyOp)</a></li><li><a href=#ltlimplication-circtltlimplicationop><code>ltl.implication</code> (circt::ltl::ImplicationOp)</a></li><li><a href=#ltlnot-circtltlnotop><code>ltl.not</code> (circt::ltl::NotOp)</a></li><li><a href=#ltlor-circtltlorop><code>ltl.or</code> (circt::ltl::OrOp)</a></li></ul></li></ul></nav><h2 id=rationale>Rationale&nbsp;<a class=headline-hash href=#rationale>¶</a></h2><p>The main goal of the <code>ltl</code> dialect is to capture the core formalism underpinning SystemVerilog Assertions (SVAs), the de facto standard for describing temporal logic sequences and properties in hardware verification. (See IEEE 1800-2017 section 16 &ldquo;Assertions&rdquo;.) We expressly try <em>not</em> to model this dialect like an AST for SVAs, but instead try to strip away all the syntactic sugar and Verilog quirks, and distill out the core foundation as an IR. Within the CIRCT project, this dialect intends to enable emission of rich temporal assertions as part of the Verilog output, but also provide a foundation for formal tools built ontop of CIRCT.</p><p>As a primary reference, the <code>ltl</code> dialect attempts to model SVAs after the
<a href=https://en.wikipedia.org/wiki/Linear_temporal_logic>Linear Temporal Logic</a> formalism as a way to distill SystemVerilog&rsquo;s syntactic sugar and quirks down to a core representation. However, most definitions of LTL tend to be rather academic in nature and may be lacking certain building blocks to make them useful in practice. (See section on
<a href=#concatenation>concatenation</a> below.) To inform some practical design decisions, the <code>ltl</code> dialect tries to think of temporal sequences as &ldquo;regular expressions over time&rdquo;, borrowing from their wide applicability and usefulness.</p><h3 id=sequences-and-properties>Sequences and Properties&nbsp;<a class=headline-hash href=#sequences-and-properties>¶</a></h3><p>The core building blocks for modeling temporal logic in the <code>ltl</code> dialect are <em>sequences</em> and <em>properties</em>. In a nutshell, sequences behave like regular expressions over time, whereas properties provide the quantifiers to express that sequences must be true under certain conditions.</p><p><strong>Sequences</strong> describe boolean expressions at different points in time. They can be easily verified by a finite state automaton, similar to how regular expressions and languages have an equivalent automaton that recognizes the language. For example:</p><ul><li>The boolean <code>a</code> is a sequence. It holds if <code>a</code> is true in cycle 0 (the current cycle).</li><li>The boolean expression <code>a & b</code> is also a sequence. It holds if <code>a & b</code> is true in cycle 0.</li><li><code>##1 a</code> checks that <code>a</code> is true in cycle 1 (the next cycle).</li><li><code>##[1:4] a</code> checks that <code>a</code> is true anywhere in cycle 1, 2, 3, or 4.</li><li><code>a ##1 b</code> checks that <code>a</code> holds in cycle 0 and <code>b</code> holds in cycle 1.</li><li><code>##1 (a ##1 b)</code> checks that <code>a</code> holds in cycle 1 and <code>b</code> holds in cycle 2.</li><li><code>(a ##1 b) ##5 (c ##1 d)</code> checks that the sequence <code>(a ##1 b)</code> holds and is followed by the sequence <code>(c ##1 d)</code> 5 or 6 cycles later. Concretely, this checks that <code>a</code> holds in cycle 0, <code>b</code> holds in cycle 1, <code>c</code> holds in cycle 6 (5 cycles after the first sequence ended in cycle 1), and <code>d</code> holds in cycle 7.</li></ul><p><strong>Properties</strong> describe concrete, testable propositions or claims built from sequences. While sequences can observe and match a certain behavior in a circuit at a specific point in time, properties allow you to express that these sequences hold in every cycle, or hold at some future point in time, or that one sequence is always followed by another. For example:</p><ul><li><code>always s</code> checks that the sequence <code>s</code> holds in every cycle. This is often referred to as the <strong>G</strong> (or &ldquo;globally&rdquo;) operator in LTL.</li><li><code>eventually s</code> checks that the sequence <code>s</code> will hold at some cycle now or in the future. This is often referred to as the <strong>F</strong> (or &ldquo;finally&rdquo;) operator in LTL.</li><li><code>s implies t</code> checks that whenever the sequence <code>s</code> is observed, it is immediately followed by sequence <code>t</code>.</li></ul><p>Traditional definitions of the LTL formalism do not make a distinction between sequences and properties. Most of their operators fall into the property category, for example, quantifiers like <em>globally</em>, <em>finally</em>, <em>release</em>, and <em>until</em>. The set of sequence operators is usually very small, since it is not necessary for academic treatment, consisting only of the <em>next</em> operator. The <code>ltl</code> dialect provides a richer set of operations to model sequences.</p><h2 id=representing-svas>Representing SVAs&nbsp;<a class=headline-hash href=#representing-svas>¶</a></h2><h3 id=sequence-concatenation-and-cycle-delay>Sequence Concatenation and Cycle Delay&nbsp;<a class=headline-hash href=#sequence-concatenation-and-cycle-delay>¶</a></h3><p>The primary building block for sequences in SVAs is the <em>concatenation</em> expression. Concatenation is always associated with a cycle delay, which indicates how many cycles pass between the end of the LHS sequence and the start of the RHS sequence. One, two, or more sequences can be concatenated at once, and the overall concatenation can have an initial cycle delay. For example:</p><pre tabindex=0><code>a ##1 b ##1 c      // 1 cycle delay between a, b, and c
##2 a ##1 b ##1 c  // same, plus 2 cycles of initial delay before a
</code></pre><p>In the simplest form, a cycle delay can appear as a prefix of another sequence, e.g., <code>##1 a</code>. This is essentially a concatenation with only one sequence, <code>a</code>, and an initial cycle delay of the concatenation of <code>1</code>. The prefix delays map to the LTL dialect as follows:</p><ul><li><code>##N seq</code>. <strong>Fixed delay.</strong> Sequence <code>seq</code> has to match exactly <code>N</code> cycles in the future. Equivalent to <code>ltl.delay %seq, N, 0</code>.</li><li><code>##[N:M] seq</code>. <strong>Bounded range delay.</strong> Sequence <code>seq</code> has to match anywhere between <code>N</code> and <code>M</code> cycles in the future, inclusive. Equivalent to <code>ltl.delay %seq, N, (M-N)</code></li><li><code>##[N:$] seq</code>. <strong>Unbounded range delay.</strong> Sequence <code>seq</code> has to match anywhere at or beyond <code>N</code> cycles in the future, after a finite amount of cycles. Equivalent to <code>ltl.delay %seq, N</code>.</li><li><code>##[*] seq</code>. Shorthand for <code>##[0:$]</code>. Equivalent to <code>ltl.delay %seq, 0</code>.</li><li><code>##[+] seq</code>. Shorthand for <code>##[1:$]</code>. Equivalent to <code>ltl.delay %seq, 1</code>.</li></ul><p>Concatenation of two sequences always involves a cycle delay specification in between them, e.g., <code>a ##1 b</code> where sequence <code>b</code> starts in the cycle after <code>a</code> ends. Zero-cycle delays can be specified, e.g., <code>a ##0 b</code> where <code>b</code> starts in the same cycle as <code>a</code> ends. If <code>a</code> and <code>b</code> are booleans, <code>a ##0 b</code> is equivalent to <code>a && b</code>.</p><p>The dialect separates concatenation and cycle delay into two orthogonal operations, <code>ltl.concat</code> and <code>ltl.delay</code>, respectively. The former models concatenation as <code>a ##0 b</code>, and the latter models delay as a prefix <code>##1 c</code>. The SVA concatenations with their infix delays map to the LTL dialect as follows:</p><ul><li><p><code>seqA ##N seqB</code>. <strong>Binary concatenation.</strong> Sequence <code>seqB</code> follows <code>N</code> cycles after <code>seqA</code>. This can be represented as <code>seqA ##0 (##N seqB)</code>, which is equivalent to</p><pre tabindex=0><code>%0 = ltl.delay %seqB, N, 0
ltl.concat %seqA, %0
</code></pre></li><li><p><code>seqA ##N seqB ##M seqC</code>. <strong>Variadic concatenation.</strong> Sequence <code>seqC</code> follows <code>M</code> cycles after <code>seqB</code>, which itself follows <code>N</code> cycles after <code>seqA</code>. This can be represented as <code>seqA ##0 (##N seqB) ##0 (##M seqC)</code>, which is equivalent to</p><pre tabindex=0><code>%0 = ltl.delay %seqB, N, 0
%1 = ltl.delay %seqC, M, 0
ltl.concat %seqA, %0, %1
</code></pre><p>Since concatenation is associative, this is also equivalent to <code>seqA ##N (seqB ##M seqC)</code>:</p><pre tabindex=0><code>%0 = ltl.delay %seqC, M, 0
%1 = ltl.concat %seqB, %0
%2 = ltl.delay %1, N, 0
ltl.concat %seqA, %2
</code></pre><p>And also <code>(seqA ##N seqB) ##M seqC</code>:</p><pre tabindex=0><code>%0 = ltl.delay %seqB, N, 0
%1 = ltl.concat %seqA, %0
%2 = ltl.delay %seqC, M, 0
ltl.concat %1, %2
</code></pre></li><li><p><code>##N seqA ##M seqB</code>. <strong>Initial delay.</strong> Sequence <code>seqB</code> follows <code>M</code> cycles afer <code>seqA</code>, which itself starts <code>N</code> cycles in the future. This is equivalent to a delay on <code>seqA</code> within the concatenation:</p><pre tabindex=0><code>%0 = ltl.delay %seqA, N, 0
%1 = ltl.delay %seqB, M, 0
ltl.concat %0, %1
</code></pre><p>Alternatively, the delay can also be placed on the entire concatenation:</p><pre tabindex=0><code>%0 = ltl.delay %seqB, M, 0
%1 = ltl.concat %seqA, %0
ltl.delay %1, N, 0
</code></pre></li><li><p>Only the fixed delay <code>##N</code> is shown here for simplicity, but the examples extend to the other delay flavors <code>##[N:M]</code>, <code>##[N:$]</code>, <code>##[*]</code>, and <code>##[+]</code>.</p></li></ul><h3 id=implication>Implication&nbsp;<a class=headline-hash href=#implication>¶</a></h3><pre tabindex=0><code>seq |-&gt; prop
seq |=&gt; prop
</code></pre><p>The overlapping <code>|-></code> and non-overlapping <code>|=></code> implication operators of SVA, which only check a property after a precondition sequence matches, map to the <code>ltl.implication</code> operation. When the sequence matches in the overlapping case <code>|-></code>, the property check starts at the same time the matched sequence ended. In the non-overlapping case <code>|=></code>, the property check starts <em>at the clock tick after the</em> end of the matched sequence, unless the matched sequence was empty, in which special rules apply. (See IEEE 1800-2017 section 16.12.7 &ldquo;Implication&rdquo;.) The non-overlapping operator can be expressed in terms of the overlapping operator:</p><pre tabindex=0><code>seq |=&gt; prop
</code></pre><p>is equivalent to</p><pre tabindex=0><code>(seq ##1 true) |-&gt; prop
</code></pre><p>The <code>ltl.implication</code> op implements the overlapping case <code>|-></code>, such that the two SVA operator flavors map to the <code>ltl</code> dialect as follows:</p><ul><li><code>seq |-> prop</code>. <strong>Overlapping implication.</strong> Equivalent to <code>ltl.implication %seq, %prop</code>.</li><li><code>seq |=> prop</code>. <strong>Non-overlapping implication.</strong> Equivalent to<pre tabindex=0><code>%true = hw.constant true
%0 = ltl.delay %true, 1, 0
%1 = ltl.concat %seq, %0
ltl.implication %1, %prop
</code></pre></li></ul><p>An important benefit of only modeling the overlapping <code>|-></code> implication operator is that it does not interact with a clock. The end point of the left-hand sequence is the starting point of the right-hand sequence. There is no notion of delay between the end of the left and the start of the right sequence. Compare this to the <code>|=></code> operator in SVA, which implies that the right-hand sequence happens at &ldquo;strictly the next clock tick&rdquo;, which requires the operator to have a notion of time and clocking. As described above, it is still possible to model this using an explicit <code>ltl.delay</code> op, which already has an established interaction with a clock.</p><h3 id=clocking>Clocking&nbsp;<a class=headline-hash href=#clocking>¶</a></h3><p>Sequence and property expressions in SVAs can specify a clock with respect to which all cycle delays are expressed. (See IEEE 1800-2017 section 16.16 &ldquo;Clock resolution&rdquo;.) These map to the <code>ltl.clock</code> operation.</p><ul><li><code>@(posedge clk) seqOrProp</code>. <strong>Trigger on low-to-high clock edge.</strong> Equivalent to <code>ltl.clock %seqOrProp, posedge %clk</code>.</li><li><code>@(negedge clk) seqOrProp</code>. <strong>Trigger on high-to-low clock edge.</strong> Equivalent to <code>ltl.clock %seqOrProp, negedge %clk</code>.</li><li><code>@(edge clk) seqOrProp</code>. <strong>Trigger on any clock edge.</strong> Equivalent to <code>ltl.clock %seqOrProp, edge %clk</code>.</li></ul><h3 id=disable-iff>Disable Iff&nbsp;<a class=headline-hash href=#disable-iff>¶</a></h3><p>Properties in SVA can have a disable condition attached, which allows for preemptive resets to be expressed. If the disable condition is true at any time during the evaluation of a property, the property is considered disabled. (See IEEE 1800-2017 end of section 16.12 &ldquo;Declaring properties&rdquo;.) This maps to the <code>ltl.disable</code> operation.</p><ul><li><code>disable iff (expr) prop</code>. <strong>Disable condition.</strong> Equivalent to <code>ltl.disable %prop if %expr</code>.</li></ul><p>Note that SVAs only allow for entire properties to be disabled, at the point at which they are passed to an assert, assume, or cover statement. It is explicitly forbidden to define a property with a <code>disable iff</code> clause and then using it within another property. For example, the following is forbidden:</p><pre tabindex=0><code>property p0; disable iff (cond) a |-&gt; b; endproperty
property p1; eventually p0; endproperty
</code></pre><p>In this example, <code>p1</code> refers to property <code>p0</code>, which is illegal in SVA since <code>p0</code> itself defines a disable condition.</p><p>In contrast, the LTL dialect explicitly allows for properties to be disabled at arbitrary points, and disabled properties to be used in other properties. Since a disabled nested property also disables the parent property, the IR can always be rewritten into a form where there is only one <code>disable iff</code> condition at the root of a property expression.</p><h2 id=representing-the-ltl-formalism>Representing the LTL Formalism&nbsp;<a class=headline-hash href=#representing-the-ltl-formalism>¶</a></h2><h3 id=next--delay>Next / Delay&nbsp;<a class=headline-hash href=#next--delay>¶</a></h3><p>The <code>ltl.delay</code> sequence operation represents various shorthands for the <em>next</em>/<strong>X</strong> operator in LTL:</p><table><thead><tr><th>Operation</th><th>LTL Formula</th></tr></thead><tbody><tr><td><code>ltl.delay %a, 0, 0</code></td><td>a</td></tr><tr><td><code>ltl.delay %a, 1, 0</code></td><td><strong>X</strong>a</td></tr><tr><td><code>ltl.delay %a, 3, 0</code></td><td><strong>XXX</strong>a</td></tr><tr><td><code>ltl.delay %a, 0, 2</code></td><td>a ∨ <strong>X</strong>a ∨ <strong>XX</strong>a</td></tr><tr><td><code>ltl.delay %a, 1, 2</code></td><td><strong>X</strong>(a ∨ <strong>X</strong>a ∨ <strong>XX</strong>a)</td></tr><tr><td><code>ltl.delay %a, 0</code></td><td><strong>F</strong>a</td></tr><tr><td><code>ltl.delay %a, 2</code></td><td><strong>XXF</strong>a</td></tr></tbody></table><h3 id=concatenation>Concatenation&nbsp;<a class=headline-hash href=#concatenation>¶</a></h3><p>The <code>ltl.concat</code> sequence operation does not have a direct equivalent in LTL. It builds a longer sequence by composing multiple shorter sequences one after another. LTL has no concept of concatenation, or a <em>&ldquo;v happens after u&rdquo;</em>, where the point in time at which v starts is dependent on how long the sequence u was.</p><p>For a sequence u with a fixed length of 2, concatenation can be represented as <em>"(u happens) and (v happens 2 cycles in the future)"</em>, u ∧ <strong>XX</strong>v. If u has a dynamic length though, for example a delay between 1 and 2, <code>ltl.delay %u, 1, 1</code> or <strong>X</strong>u ∨ <strong>XX</strong>u in LTL, there is no fixed number of cycles by which the sequence v can be delayed to make it start after u. Instead, all different-length variants of sequence u have to be enumerated and combined with a copy of sequence v delayed by the appropriate amount: (<strong>X</strong>u ∧ <strong>XX</strong>v) ∨ (<strong>XX</strong>u ∧ <strong>XXX</strong>v). This is basically saying &ldquo;u delayed by 1 to 2 cycles followed by v&rdquo; is the same as either <em>&ldquo;u delayed by 1 cycle and v delayed by 2 cycles&rdquo;</em>, or <em>&ldquo;u delayed by 2 cycles and v delayed by 3 cycles&rdquo;</em>.</p><p>The <em>&ldquo;v happens after u&rdquo;</em> relationship is crucial to express sequences efficiently, which is why the LTL dialect has the <code>ltl.concat</code> op. If sequences are thought of as regular expressions over time, for example, <code>a(b|cd)</code> or <em>&ldquo;a followed by either (b) or (c followed by d)&rdquo;</em>, the importance of having a concatenation operation as temporal connective becomes apparent. Why LTL formalisms tend to not include such an operator is unclear.</p><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><h3 id=overview>Overview&nbsp;<a class=headline-hash href=#overview>¶</a></h3><p>The <code>ltl</code> dialect operations defines two main types returned by its operations: sequences and properties. These types form a hierarchy together with the boolean type <code>i1</code>:</p><ul><li>a boolean <code>i1</code> is also a valid sequence</li><li>a sequence <code>!ltl.sequence</code> is also a valid property</li></ul><pre tabindex=0><code>i1 &lt;: ltl.sequence &lt;: ltl.property
</code></pre><p>The two type constraints <code>AnySequenceType</code> and <code>AnyPropertyType</code> are provided to implement this hierarchy. Operations use these constraints for their operands, such that they can properly accept <code>i1</code> as a sequence, <code>i1</code> or a sequence as a property. The return type is an explicit <code>!ltl.sequence</code> or <code>!ltl.property</code>.</p><h3 id=propertytype>PropertyType&nbsp;<a class=headline-hash href=#propertytype>¶</a></h3><p>LTL property type</p><p>Syntax: <code>!ltl.property</code></p><p>The <code>ltl.property</code> type represents a verifiable property built from linear
temporal logic sequences and quantifiers, for example, <em>&ldquo;if you see sequence
A, eventually you will see sequence B&rdquo;</em>.</p><p>Note that this type explicitly identifies a <em>property</em>. However, a boolean
value (<code>i1</code>) or a sequence (<code>ltl.sequence</code>) is also a valid property.
Operations that accept a property as an operand will use the <code>AnyProperty</code>
constraint, which also accepts <code>ltl.sequence</code> and <code>i1</code>.</p><h3 id=sequencetype>SequenceType&nbsp;<a class=headline-hash href=#sequencetype>¶</a></h3><p>LTL sequence type</p><p>Syntax: <code>!ltl.sequence</code></p><p>The <code>ltl.sequence</code> type represents a sequence of linear temporal logic, for
example, <em>&ldquo;A is true two cycles after B is true&rdquo;</em>.</p><p>Note that this type explicitly identifies a <em>sequence</em>. However, a boolean
value (<code>i1</code>) is also a valid sequence. Operations that accept a sequence as
an operand will use the <code>AnySequence</code> constraint, which also accepts <code>i1</code>.</p><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><h3 id=ltland-circtltlandop><code>ltl.and</code> (circt::ltl::AndOp)&nbsp;<a class=headline-hash href=#ltland-circtltlandop>¶</a></h3><p><em>A conjunction of booleans, sequences, or properties.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ltl.and` $inputs attr-dict `:` type($inputs)
</code></pre><p>If any of the <code>$inputs</code> is of type <code>!ltl.property</code>, the result of the op is
an <code>!ltl.property</code>. Otherwise it is an <code>!ltl.sequence</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 1-bit signless integer or LTL sequence type or LTL property type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer or LTL sequence type or LTL property type</td></tr></tbody></table><h3 id=ltlclock-circtltlclockop><code>ltl.clock</code> (circt::ltl::ClockOp)&nbsp;<a class=headline-hash href=#ltlclock-circtltlclockop>¶</a></h3><p><em>Specify the clock for a property or sequence.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ltl.clock` $input `,` $edge $clock attr-dict `:` type($input)
</code></pre><p>Specifies the <code>$edge</code> on a given <code>$clock</code> to be the clock for an <code>$input</code>
property or sequence. All cycle delays in the <code>$input</code> implicitly refer to a
clock that advances the state to the next cycle. The <code>ltl.clock</code> operation
provides that clock. The clock applies to the entire property or sequence
expression tree below <code>$input</code>, up to any other nested <code>ltl.clock</code>
operations.</p><p>The operation returns a property if the <code>$input</code> is a property, and a
sequence otherwise.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>edge</code></td><td>circt::ltl::ClockEdgeAttr</td><td>clock edge</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit signless integer or LTL sequence type or LTL property type</td></tr><tr><td style=text-align:center><code>clock</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LTL sequence type or LTL property type</td></tr></tbody></table><h3 id=ltlconcat-circtltlconcatop><code>ltl.concat</code> (circt::ltl::ConcatOp)&nbsp;<a class=headline-hash href=#ltlconcat-circtltlconcatop>¶</a></h3><p><em>Concatenate sequences into a longer sequence.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ltl.concat` $inputs attr-dict `:` type($inputs)
</code></pre><p>Concatenates all of the <code>$inputs</code> sequences one after another into one
longer sequence. The sequences are arranged such that the end time of the
previous sequences coincides with the start time of the next sequence. This
means there is no implicit cycle of delay between the concatenated
sequences, which may be counterintuitive.</p><p>If a sequence should follow in the cycle after another sequence finishes,
that cycle of delay needs to be explicit. For example, <em>&ldquo;u followed by v in
next cycle&rdquo;</em> (<code>u ##1 v</code> in SVA) is represented as
<code>concat(u, delay(v, 1, 0))</code>:</p><pre tabindex=0><code>%0 = ltl.delay %v, 1, 0 : i1
ltl.concat %u, %v : !ltl.sequence, !ltl.sequence
</code></pre><p>The resulting sequence checks for <code>u</code> in the first cycle and <code>v</code> in the
second, <code>[u, v]</code> in short.</p><p>Without this explicit delay, the previous sequence&rsquo;s end overlaps with the
next sequence&rsquo;s start. For example, consider the two sequences <code>u = a ##1 b</code>
and <code>v = c ##1 d</code>, which check for <code>a</code> and <code>c</code> in the first, and <code>b</code> and <code>d</code>
in the second cycle. When these two sequences are concatenated,
<code>concat(u, v)</code>, the end time of the first sequence coincides with the start
time of the second. As a result, the check for <code>b</code> at the end of the first
sequence will coincide with the check for <code>c</code> at the start of the second
sequence: <code>concat(u, v) = a ##1 (b && c) ##1 d</code>. The resulting sequence
checks for <code>a</code> in the first cycle, <code>b</code> and <code>c</code> in the second, and <code>d</code> in the
third, <code>[a, (b && c), d]</code> in short.</p><p>By making the delay between concatenated sequences explicit, the <code>concat</code>
operation behaves nicely in the presence of zero-length sequences. An empty,
zero-length sequence in a concatenation behaves as if the sequence wasn&rsquo;t
present at all. Compare this to SVAs which struggle with empty sequences.
For example, <code>x ##1 y ##1 z</code> would become <code>x ##2 z</code> if <code>y</code> was empty.
Similarly, expressing zero or more repetitions of a sequence, <code>w ##[*]</code>, is
challenging in SVA since concatenation always implies a cycle of delay, but
trivial if the delay is made explicit. This is related to the handling of
empty rules in a parser&rsquo;s grammar.</p><p>Note that concatenating two boolean values <em>a</em> and <em>b</em> is equivalent to
computing the logical AND of them. Booleans are sequences that check if the
boolean is true in the current cycle, which means that the sequence starts
and ends in the same cycle. Since concatenation aligns the sequences such
that end time of <em>a</em> and start time of <em>b</em> coincide, the resulting sequence
checks if <em>a</em> and <em>b</em> both are true in the current cycle, which is an AND
operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 1-bit signless integer or LTL sequence type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LTL sequence type</td></tr></tbody></table><h3 id=ltldelay-circtltldelayop><code>ltl.delay</code> (circt::ltl::DelayOp)&nbsp;<a class=headline-hash href=#ltldelay-circtltldelayop>¶</a></h3><p><em>Delay a sequence by a number of cycles.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ltl.delay` $input `,` $delay (`,` $length^)? attr-dict `:` type($input)
</code></pre><p>Delays the <code>$input</code> sequence by the number of cycles specified by <code>$delay</code>.
The delay must be greater than or equal to zero. The optional <code>$length</code>
specifies during how many cycles after the initial delay the sequence can
match. Omitting <code>$length</code> indicates an unbounded but finite delay. For
example:</p><ul><li><code>ltl.delay %seq, 2, 0</code> delays <code>%seq</code> by exactly 2 cycles. The resulting
sequence matches if <code>%seq</code> matches exactly 2 cycles in the future.</li><li><code>ltl.delay %seq, 2, 2</code> delays <code>%seq</code> by 2, 3, or 4 cycles. The resulting
sequence matches if <code>%seq</code> matches 2, 3, or 4 cycles in the future.</li><li><code>ltl.delay %seq, 2</code> delays <code>%seq</code> by 2 or more cycles. The number of
cycles is unbounded but finite, which means that <code>%seq</code> <em>has</em> to match at
some point, instead of effectively never occuring by being delayed an
infinite number of cycles.</li><li><code>ltl.delay %seq, 0, 0</code> is equivalent to just <code>%seq</code>.</li></ul><h4 id=clocking-1>Clocking&nbsp;<a class=headline-hash href=#clocking-1>¶</a></h4><p>The cycle delay specified on the operation refers to a clocking event. This
event is not directly specified by the delay operation itself. Instead, the
<a href=#ltlclock-circtltlclockop><code>ltl.clock</code></a> operation can be used to associate
all delays within a sequence with a clock.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>delay</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>length</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit signless integer or LTL sequence type</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LTL sequence type</td></tr></tbody></table><h3 id=ltldisable-circtltldisableop><code>ltl.disable</code> (circt::ltl::DisableOp)&nbsp;<a class=headline-hash href=#ltldisable-circtltldisableop>¶</a></h3><p><em>Disable the evaluation of a property based on a condition.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ltl.disable` $input `if` $condition attr-dict `:` type($input)
</code></pre><p>Creates a new property which evaluates the given <code>$input</code> property only if
the given disable <code>$condition</code> is false throughout the entire evaluation. If
the <code>$condition</code> is true at any point in time during the evaluation of
<code>$input</code>, the resulting property is disabled.</p><p>The disabling is &ldquo;infectious&rdquo;. If a property is disabled, it also implicitly
disables all properties that use it. Consider the following example:</p><pre tabindex=0><code>%0 = ltl.disable %prop if %cond
%1 = ltl.or %0, %otherProp
</code></pre><p>If the property <code>%0</code> is disabled, the derived property <code>%1</code> is also
disabled.</p><p>As a result, it is always legal to canonicalize the IR into a form where
there is only one <code>ltl.disable</code> operation at the root of a property
expression.</p><p>Note that a property being disabled based on a condition is different from a
property that trivially evaluates to true if the condition does not hold.
The former ensures that a property is only checked when a certain condition
is true, but the number of cases in which the property holds or doesn&rsquo;t hold
remains unchanged. The latter adds additional cases where the property
holds, which can offer a solver unintended ways to make assertions or
coverage proofs derived from the property pass. For example:</p><pre tabindex=0><code>%p0 = ltl.or %prop, %cond
%p1 = ltl.disable %prop if %cond
</code></pre><p><code>$cond</code> being true would disable the evaluation of <code>%p0</code> and would make
<code>%p1</code> evaluate to true. These are subtly different. If used in an assertion
during simulation, <code>$cond</code> would adequately disable triggering of the
assertion in both cases. However, if used in a formal verification setting
where proofs for <code>%p0</code> and <code>%p1</code> always holding or never holding are sought,
a solver might use <code>%cond = true</code> to trivially make <code>%p0</code> hold, which is not
possible for <code>%p1</code>. Consider the following more concrete example:</p><pre tabindex=0><code>%p2 = ltl.or %protocolCorrectProperty, %reset
%p3 = ltl.disable %protocolCorrectProperty if %reset
verif.cover %p2
verif.cover %p3
</code></pre><p>The intent is to formally prove coverage for <code>%protocolCorrectProperty</code>
while the circuit is in regular operation (i.e., out of reset). A formal
solver would trivially prove coverage for <code>%p2</code> by assigning
<code>%reset = true</code>, but would have to actually prove coverage for the
underlying <code>%protocolCorrectProperty</code> for <code>%p3</code>. The latter is almost always
the intended behavior.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit signless integer or LTL sequence type or LTL property type</td></tr><tr><td style=text-align:center><code>condition</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LTL property type</td></tr></tbody></table><h3 id=ltleventually-circtltleventuallyop><code>ltl.eventually</code> (circt::ltl::EventuallyOp)&nbsp;<a class=headline-hash href=#ltleventually-circtltleventuallyop>¶</a></h3><p><em>Ensure that a property will hold at some time in the future.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ltl.eventually` $input attr-dict `:` type($input)
</code></pre><p>Checks that the <code>$input</code> property will hold at a future time. This operator
is strong: it requires that the <code>$input</code> holds after a <em>finite</em> number of
cycles. The operator does <em>not</em> hold if the <code>$input</code> can&rsquo;t hold in the
future.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit signless integer or LTL sequence type or LTL property type</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LTL property type</td></tr></tbody></table><h3 id=ltlimplication-circtltlimplicationop><code>ltl.implication</code> (circt::ltl::ImplicationOp)&nbsp;<a class=headline-hash href=#ltlimplication-circtltlimplicationop>¶</a></h3><p><em>Only check a property after a sequence matched.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ltl.implication` operands attr-dict `:` type(operands)
</code></pre><p>Preconditions the checking of the <code>$consequent</code> property on the
<code>$antecedent</code> sequence. In a nutshell, if the <code>$antecedent</code> sequence matches
at a given point in time, the <code>$consequent</code> property is checked starting at
the point in time at which the matched sequence ends. The result property of
the <code>ltl.implication</code> holds if the <code>$consequent</code> holds. Conversely, if the
<code>$antecedent</code> does <em>not</em> match at a given point in time, the result property
trivially holds. This is conceptually identical to the implication operator
→, but with additional temporal semantics.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>antecedent</code></td><td>1-bit signless integer or LTL sequence type</td></tr><tr><td style=text-align:center><code>consequent</code></td><td>1-bit signless integer or LTL sequence type or LTL property type</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LTL property type</td></tr></tbody></table><h3 id=ltlnot-circtltlnotop><code>ltl.not</code> (circt::ltl::NotOp)&nbsp;<a class=headline-hash href=#ltlnot-circtltlnotop>¶</a></h3><p><em>A negation of a property.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ltl.not` $input attr-dict `:` type($input)
</code></pre><p>Negates the <code>$input</code> property. The resulting property evaluates to true if
<code>$input</code> evaluates to false, and it evaluates to false if <code>$input</code> evaluates
to true.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit signless integer or LTL sequence type or LTL property type</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LTL property type</td></tr></tbody></table><h3 id=ltlor-circtltlorop><code>ltl.or</code> (circt::ltl::OrOp)&nbsp;<a class=headline-hash href=#ltlor-circtltlorop>¶</a></h3><p><em>A disjunction of booleans, sequences, or properties.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `ltl.or` $inputs attr-dict `:` type($inputs)
</code></pre><p>If any of the <code>$inputs</code> is of type <code>!ltl.property</code>, the result of the op is
an <code>!ltl.property</code>. Otherwise it is an <code>!ltl.sequence</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 1-bit signless integer or LTL sequence type or LTL property type</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer or LTL sequence type or LTL property type</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/ title="LoopSchedule Dialect Rationale"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - LoopSchedule Dialect Rationale</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/Moore/ title="'moore' Dialect">Next - 'moore' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li class=active><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>