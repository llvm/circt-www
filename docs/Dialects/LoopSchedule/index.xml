<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>'loopschedule' Dialect on CIRCT</title><link>https://circt.llvm.org/docs/Dialects/LoopSchedule/</link><description>Recent content in 'loopschedule' Dialect on CIRCT</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Jan 1970 00:00:00 +0000</lastBuildDate><atom:link href="https://circt.llvm.org/docs/Dialects/LoopSchedule/index.xml" rel="self" type="application/rss+xml"/><item><title>LoopSchedule Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/</guid><description>This document describes various design points of the loopschedule dialect, why it is the way it is, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction The loopschedule dialect provides a collection of ops to represent software-like loops after scheduling. There are currently two main kinds of loops that can be represented: pipelined and sequential. Pipelined loops allow multiple iterations of the loop to be in-flight at a time and have an associated initiation interval (II) to specify the number of cycles between the start of successive loop iterations.</description></item></channel></rss>