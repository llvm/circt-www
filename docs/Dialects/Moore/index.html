<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'moore' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/Moore/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'moore' Dialect</h1><p>This dialect provides operations and types to capture a SystemVerilog design after parsing, type checking, and elaboration.</p><p><nav id=TableOfContents><ul><li><a href=#rationale>Rationale</a></li><li><a href=#types>Types</a></li><li><a href=#operations>Operations</a><ul><li><a href=#mooreashr-circtmooreashrop><code>moore.ashr</code> (::circt::moore::AShrOp)</a></li><li><a href=#mooreadd-circtmooreaddop><code>moore.add</code> (::circt::moore::AddOp)</a></li><li><a href=#mooreand-circtmooreandop><code>moore.and</code> (::circt::moore::AndOp)</a></li><li><a href=#mooreblocking_assign-circtmooreblockingassignop><code>moore.blocking_assign</code> (::circt::moore::BlockingAssignOp)</a></li><li><a href=#moorebool_cast-circtmooreboolcastop><code>moore.bool_cast</code> (::circt::moore::BoolCastOp)</a></li><li><a href=#moorecase_eq-circtmoorecaseeqop><code>moore.case_eq</code> (::circt::moore::CaseEqOp)</a></li><li><a href=#moorecase_ne-circtmoorecaseneop><code>moore.case_ne</code> (::circt::moore::CaseNeOp)</a></li><li><a href=#mooreconcat-circtmooreconcatop><code>moore.concat</code> (::circt::moore::ConcatOp)</a></li><li><a href=#mooreconstant-circtmooreconstantop><code>moore.constant</code> (::circt::moore::ConstantOp)</a></li><li><a href=#mooreassign-circtmoorecontinuousassignop><code>moore.assign</code> (::circt::moore::ContinuousAssignOp)</a></li><li><a href=#mooreconversion-circtmooreconversionop><code>moore.conversion</code> (::circt::moore::ConversionOp)</a></li><li><a href=#moorediv-circtmooredivop><code>moore.div</code> (::circt::moore::DivOp)</a></li><li><a href=#mooreeq-circtmooreeqop><code>moore.eq</code> (::circt::moore::EqOp)</a></li><li><a href=#moorege-circtmooregeop><code>moore.ge</code> (::circt::moore::GeOp)</a></li><li><a href=#mooregt-circtmooregtop><code>moore.gt</code> (::circt::moore::GtOp)</a></li><li><a href=#mooreinstance-circtmooreinstanceop><code>moore.instance</code> (::circt::moore::InstanceOp)</a></li><li><a href=#moorele-circtmooreleop><code>moore.le</code> (::circt::moore::LeOp)</a></li><li><a href=#moorelt-circtmooreltop><code>moore.lt</code> (::circt::moore::LtOp)</a></li><li><a href=#mooremod-circtmooremodop><code>moore.mod</code> (::circt::moore::ModOp)</a></li><li><a href=#mooremul-circtmooremulop><code>moore.mul</code> (::circt::moore::MulOp)</a></li><li><a href=#moorene-circtmooreneop><code>moore.ne</code> (::circt::moore::NeOp)</a></li><li><a href=#mooreneg-circtmoorenegop><code>moore.neg</code> (::circt::moore::NegOp)</a></li><li><a href=#moorenonblocking_assign-circtmoorenonblockingassignop><code>moore.nonblocking_assign</code> (::circt::moore::NonBlockingAssignOp)</a></li><li><a href=#moorenot-circtmoorenotop><code>moore.not</code> (::circt::moore::NotOp)</a></li><li><a href=#mooreor-circtmooreorop><code>moore.or</code> (::circt::moore::OrOp)</a></li><li><a href=#mooreprocedure-circtmooreprocedureop><code>moore.procedure</code> (::circt::moore::ProcedureOp)</a></li><li><a href=#mooreread_lvalue-circtmoorereadlvalueop><code>moore.read_lvalue</code> (::circt::moore::ReadLValueOp)</a></li><li><a href=#moorereduce_and-circtmoorereduceandop><code>moore.reduce_and</code> (::circt::moore::ReduceAndOp)</a></li><li><a href=#moorereduce_or-circtmoorereduceorop><code>moore.reduce_or</code> (::circt::moore::ReduceOrOp)</a></li><li><a href=#moorereduce_xor-circtmoorereducexorop><code>moore.reduce_xor</code> (::circt::moore::ReduceXorOp)</a></li><li><a href=#mooremodule-circtmooresvmoduleop><code>moore.module</code> (::circt::moore::SVModuleOp)</a></li><li><a href=#mooreshl-circtmooreshlop><code>moore.shl</code> (::circt::moore::ShlOp)</a></li><li><a href=#mooreshr-circtmooreshrop><code>moore.shr</code> (::circt::moore::ShrOp)</a></li><li><a href=#mooresub-circtmooresubop><code>moore.sub</code> (::circt::moore::SubOp)</a></li><li><a href=#moorevariable-circtmoorevariableop><code>moore.variable</code> (::circt::moore::VariableOp)</a></li><li><a href=#moorewildcard_eq-circtmoorewildcardeqop><code>moore.wildcard_eq</code> (::circt::moore::WildcardEqOp)</a></li><li><a href=#moorewildcard_ne-circtmoorewildcardneop><code>moore.wildcard_ne</code> (::circt::moore::WildcardNeOp)</a></li><li><a href=#moorexor-circtmoorexorop><code>moore.xor</code> (::circt::moore::XorOp)</a></li></ul></li></ul></nav><h2 id=rationale>Rationale&nbsp;<a class=headline-hash href=#rationale>¶</a></h2><p>The main goal of the <code>moore</code> dialect is to provide a set of operations and types for the <code>ImportVerilog</code> conversion to translate a fully parsed, type-checked, and elaborated Slang AST into MLIR operations. See IEEE 1800-2017 for more details about SystemVerilog. The dialect aims to faithfully capture the full SystemVerilog types and semantics, and provide a platform for transformation passes to resolve language quirks, analyze the design at a high level, and lower it to the core dialects.</p><p>In contrast, the <code>sv</code> dialect is geared towards emission of SystemVerilog text, and is focused on providing a good lowering target to allow for emission. The <code>moore</code> and <code>sv</code> dialect may eventually converge into a single dialect. As we are building out the Verilog frontend capabilities of CIRCT it is valuable to have a separate ingestion dialect, such that we do not have to make disruptive changes to the load-bearing <code>sv</code> dialect used in production.</p><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><h3 id=mooreashr-circtmooreashrop><code>moore.ashr</code> (::circt::moore::AShrOp)&nbsp;<a class=headline-hash href=#mooreashr-circtmooreashrop>¶</a></h3><p><em>Arithmetic right shift</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.ashr` $value `,` $amount attr-dict `:` type($value) `,` type($amount)
</code></pre><p>Shifts the <code>value</code> to the left or right by <code>amount</code> number of bits. The
result has the same type as the input value. The amount is always treated as
an unsigned number and has no effect on the signedness of the result. X or
Z bits in the input value are simply shifted left or right the same way 0 or
1 bits are. If the amount contains X or Z bits, all result bits are X.</p><p><code>shl</code> shifts bits to the left, filling in 0 for the vacated least
significant bits. <code>shr</code> and <code>ashr</code> shift bits to the right; <code>shr</code> fills in
0 for the vacated most significant bits, and <code>ashr</code> copies the input&rsquo;s sign
bit into the vacated most significant bits. Note that in contrast to the SV
spec, the <code>ashr</code> <em>always</em> fills in the sign bit regardless of the signedness
of the input.</p><p><code>shl</code> corresponds to the <code>&lt;&lt;</code> and <code>&lt;&lt;&lt;</code> operators. <code>shr</code> corresponds to the
<code>>></code> operator, and the <code>>>></code> operator applied to an unsigned value. <code>ashr</code>
corresponds to the <code>>>></code> operator applied to a signed value.</p><p>See IEEE 1800-2017 § 11.4.10 &ldquo;Shift operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>amount</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>simple bit vector type</td></tr></tbody></table><h3 id=mooreadd-circtmooreaddop><code>moore.add</code> (::circt::moore::AddOp)&nbsp;<a class=headline-hash href=#mooreadd-circtmooreaddop>¶</a></h3><p><em>Addition</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.add` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Add the operands. If any bit in the two operands is Z or X, all bits in the
result are X.</p><p>See IEEE 1800-2017 § 11.4.3 &ldquo;Arithmetic operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>simple bit vector type</td></tr></tbody></table><h3 id=mooreand-circtmooreandop><code>moore.and</code> (::circt::moore::AndOp)&nbsp;<a class=headline-hash href=#mooreand-circtmooreandop>¶</a></h3><p><em>Bitwise AND operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.and` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Applies the boolean AND operation to each pair of corresponding bits in the
left- and right-hand side operand. Corresponds to the <code>&</code> operator.</p><p>See IEEE 1800-2017 § 11.4.8 &ldquo;Bitwise operators&rdquo;.</p><table><thead><tr><th></th><th>0</th><th>1</th><th>X</th><th>Z</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>X</td><td>X</td></tr><tr><td>X</td><td>0</td><td>X</td><td>X</td><td>X</td></tr><tr><td>Z</td><td>0</td><td>X</td><td>X</td><td>X</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>simple bit vector type</td></tr></tbody></table><h3 id=mooreblocking_assign-circtmooreblockingassignop><code>moore.blocking_assign</code> (::circt::moore::BlockingAssignOp)&nbsp;<a class=headline-hash href=#mooreblocking_assign-circtmooreblockingassignop>¶</a></h3><p><em>Blocking procedural assignment</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.blocking_assign` $dst `,` $src attr-dict `:` type($src)
</code></pre><p>A blocking procedural assignment in a sequential block, such as <code>x = y</code>. The
effects of the assignment are visible to any subsequent operations in the
block.</p><p>See IEEE 1800-2017 § 10.4.1 &ldquo;Blocking procedural assignments&rdquo;.</p><p>Traits: <code>SameTypeOperands</code></p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>any type</td></tr><tr><td style=text-align:center><code>src</code></td><td>any type</td></tr></tbody></table><h3 id=moorebool_cast-circtmooreboolcastop><code>moore.bool_cast</code> (::circt::moore::BoolCastOp)&nbsp;<a class=headline-hash href=#moorebool_cast-circtmooreboolcastop>¶</a></h3><p><em>Cast a value to a single bit boolean</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.bool_cast` $input attr-dict `:` type($input) `-&gt;` type($result)
</code></pre><p>Convert a nonzero or true value into 1, a zero or false value into 0, and
any value containing Z or X bits into a X. This conversion is useful in
combination with the logical and, or, implication, equivalence, and negation
operators.</p><p>See IEEE 1800-2017 § 11.4.7 &ldquo;Logical operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unpacked type</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>single bit type</td></tr></tbody></table><h3 id=moorecase_eq-circtmoorecaseeqop><code>moore.case_eq</code> (::circt::moore::CaseEqOp)&nbsp;<a class=headline-hash href=#moorecase_eq-circtmoorecaseeqop>¶</a></h3><p><em>Case equality</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.case_eq` $lhs `,` $rhs attr-dict `:` type($lhs)
</code></pre><p>Compares the bits in the left- and right-hand side operand and returns a
single bit 0 or 1 result. If all corresponding bits in the left- and
right-hand side are equal (both 0, 1, X, or Z), the two operands are
considered equal (<code>case_eq</code> returns 1, <code>case_ne</code> returns 0). If any bits are
not equal, the two operands are considered not equal (<code>case_eq</code> returns 0,
<code>case_ne</code> returns 1). <code>case_eq</code> corresponds to the <code>===</code> operator and
<code>case_ne</code> to the <code>!==</code> operator.</p><p>See IEEE 1800-2017 § 11.4.5 &ldquo;Equality operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td><code>bit</code> type</td></tr></tbody></table><h3 id=moorecase_ne-circtmoorecaseneop><code>moore.case_ne</code> (::circt::moore::CaseNeOp)&nbsp;<a class=headline-hash href=#moorecase_ne-circtmoorecaseneop>¶</a></h3><p><em>Case inequality</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.case_ne` $lhs `,` $rhs attr-dict `:` type($lhs)
</code></pre><p>Compares the bits in the left- and right-hand side operand and returns a
single bit 0 or 1 result. If all corresponding bits in the left- and
right-hand side are equal (both 0, 1, X, or Z), the two operands are
considered equal (<code>case_eq</code> returns 1, <code>case_ne</code> returns 0). If any bits are
not equal, the two operands are considered not equal (<code>case_eq</code> returns 0,
<code>case_ne</code> returns 1). <code>case_eq</code> corresponds to the <code>===</code> operator and
<code>case_ne</code> to the <code>!==</code> operator.</p><p>See IEEE 1800-2017 § 11.4.5 &ldquo;Equality operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td><code>bit</code> type</td></tr></tbody></table><h3 id=mooreconcat-circtmooreconcatop><code>moore.concat</code> (::circt::moore::ConcatOp)&nbsp;<a class=headline-hash href=#mooreconcat-circtmooreconcatop>¶</a></h3><p><em>A concatenation of expressions</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.concat` $values attr-dict `:` functional-type($values, $result)
</code></pre><p>This operation represents the SystemVerilog concatenation expression
<code>{x, y, z}</code>. See IEEE 1800-2017 §11.4.12 &ldquo;Concatenation operators&rdquo;.</p><p>All operands must be simple bit vector types.</p><p>The concatenation result is a simple bit vector type. The result is unsigned
regardless of the sign of the operands (see concatenation-specific rules in
IEEE 1800-2017 §11.8.1 &ldquo;Rules for expression types&rdquo;). The size of the result
is the sum of the sizes of all operands. If any of the operands is
four-valued, the result is four-valued; otherwise it is two-valued.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values</code></td><td>variadic of simple bit vector type</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>simple bit vector type</td></tr></tbody></table><h3 id=mooreconstant-circtmooreconstantop><code>moore.constant</code> (::circt::moore::ConstantOp)&nbsp;<a class=headline-hash href=#mooreconstant-circtmooreconstantop>¶</a></h3><p><em>A constant integer value</em></p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>simple bit vector type</td></tr></tbody></table><h3 id=mooreassign-circtmoorecontinuousassignop><code>moore.assign</code> (::circt::moore::ContinuousAssignOp)&nbsp;<a class=headline-hash href=#mooreassign-circtmoorecontinuousassignop>¶</a></h3><p><em>Continuous assignment within a module</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.assign` $dst `,` $src attr-dict `:` type($src)
</code></pre><p>A continuous assignment in module scope, such as <code>assign x = y;</code>, which
continuously drives the value on the right-hand side onto the left-hand
side.</p><p>See IEEE 1800-2017 § 10.3 &ldquo;Continuous assignments&rdquo;.</p><p>Traits: <code>HasParent&lt;SVModuleOp></code>, <code>SameTypeOperands</code></p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>any type</td></tr><tr><td style=text-align:center><code>src</code></td><td>any type</td></tr></tbody></table><h3 id=mooreconversion-circtmooreconversionop><code>moore.conversion</code> (::circt::moore::ConversionOp)&nbsp;<a class=headline-hash href=#mooreconversion-circtmooreconversionop>¶</a></h3><p><em>A type conversion</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.conversion` $input attr-dict `:` type($input) `-&gt;` type($result)
</code></pre><p>An explicit or implicit type conversion. These are either generated
automatically in order to make assignments compatible:</p><pre tabindex=0><code>int a;
shortint b;
a = b;  // generates an implicit cast from shortint to int
</code></pre><p>Or explicitly by the user through a type, sign, or const cast expression:</p><pre tabindex=0><code>byte&#39;(a)
unsigned&#39;(a)
signed&#39;(a)
42&#39;(a)
</code></pre><p>See IEEE 1800-2017 § 6.24 &ldquo;Casting&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=moorediv-circtmooredivop><code>moore.div</code> (::circt::moore::DivOp)&nbsp;<a class=headline-hash href=#moorediv-circtmooredivop>¶</a></h3><p><em>Division</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.div` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Divide the left-hand side by the right-hand side operand. Any fractional
part is truncated toward zero. If the right-hand side is zero, all bits of
the result are X. If any bit in the two operands is Z or X, all bits in the
result are X.</p><p>See IEEE 1800-2017 § 11.4.3 &ldquo;Arithmetic operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>simple bit vector type</td></tr></tbody></table><h3 id=mooreeq-circtmooreeqop><code>moore.eq</code> (::circt::moore::EqOp)&nbsp;<a class=headline-hash href=#mooreeq-circtmooreeqop>¶</a></h3><p><em>Logical equality</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.eq` $lhs `,` $rhs attr-dict `:` type($lhs) `-&gt;` type($result)
</code></pre><p>Compares the bits in the left- and right-hand side operand and returns a
single bit 0, 1, or X result. If all corresponding bits in the left- and
right-hand side are equal, and all are 0 or 1 (not X or Z), the two operands
are considered equal (<code>eq</code> returns 1, <code>ne</code> returns 0). If any bits are not
equal, but all are 0 or 1, the two operands are considered not equal (<code>eq</code>
returns 0, <code>ne</code> returns 1). If any bit in the two operands is Z or X,
returns X. <code>eq</code> corresponds to the <code>==</code> operator and <code>ne</code> to the <code>!=</code>
operator.</p><p>See IEEE 1800-2017 § 11.4.5 &ldquo;Equality operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>single bit type</td></tr></tbody></table><h3 id=moorege-circtmooregeop><code>moore.ge</code> (::circt::moore::GeOp)&nbsp;<a class=headline-hash href=#moorege-circtmooregeop>¶</a></h3><p><em>Greater than or equal</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.ge` $lhs `,` $rhs attr-dict `:` type($lhs) `-&gt;` type($result)
</code></pre><p>Compares the left- and right-hand side operand and returns a single bit 0,
1, or X result. If any bit in the two operands is Z or X, returns X.
Otherwise, if all bits are 0 or 1, <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code> return whether
the left-hand side is less than, less than or equal to, greater than, or
greater than or equal to the right-hand side, respectively. <code>lt</code> corresponds
to the <code>&lt;</code> operator, <code>le</code> to <code>&lt;=</code>, <code>gt</code> to <code>></code>, and <code>ge</code> to <code>>=</code>.</p><p>See IEEE 1800-2017 § 11.4.4 &ldquo;Relational operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>single bit type</td></tr></tbody></table><h3 id=mooregt-circtmooregtop><code>moore.gt</code> (::circt::moore::GtOp)&nbsp;<a class=headline-hash href=#mooregt-circtmooregtop>¶</a></h3><p><em>Greater than</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.gt` $lhs `,` $rhs attr-dict `:` type($lhs) `-&gt;` type($result)
</code></pre><p>Compares the left- and right-hand side operand and returns a single bit 0,
1, or X result. If any bit in the two operands is Z or X, returns X.
Otherwise, if all bits are 0 or 1, <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code> return whether
the left-hand side is less than, less than or equal to, greater than, or
greater than or equal to the right-hand side, respectively. <code>lt</code> corresponds
to the <code>&lt;</code> operator, <code>le</code> to <code>&lt;=</code>, <code>gt</code> to <code>></code>, and <code>ge</code> to <code>>=</code>.</p><p>See IEEE 1800-2017 § 11.4.4 &ldquo;Relational operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>single bit type</td></tr></tbody></table><h3 id=mooreinstance-circtmooreinstanceop><code>moore.instance</code> (::circt::moore::InstanceOp)&nbsp;<a class=headline-hash href=#mooreinstance-circtmooreinstanceop>¶</a></h3><p><em>Create an instance of a module</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.instance` $instanceName $moduleName attr-dict
</code></pre><p>The <code>moore.instance</code> operation instantiates a <code>moore.module</code> operation.</p><p>See IEEE 1800-2017 § 23.3 &ldquo;Module instances&rdquo;.</p><p>Interfaces: <code>SymbolUserOpInterface</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>instanceName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>moduleName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h3 id=moorele-circtmooreleop><code>moore.le</code> (::circt::moore::LeOp)&nbsp;<a class=headline-hash href=#moorele-circtmooreleop>¶</a></h3><p><em>Less than or equal</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.le` $lhs `,` $rhs attr-dict `:` type($lhs) `-&gt;` type($result)
</code></pre><p>Compares the left- and right-hand side operand and returns a single bit 0,
1, or X result. If any bit in the two operands is Z or X, returns X.
Otherwise, if all bits are 0 or 1, <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code> return whether
the left-hand side is less than, less than or equal to, greater than, or
greater than or equal to the right-hand side, respectively. <code>lt</code> corresponds
to the <code>&lt;</code> operator, <code>le</code> to <code>&lt;=</code>, <code>gt</code> to <code>></code>, and <code>ge</code> to <code>>=</code>.</p><p>See IEEE 1800-2017 § 11.4.4 &ldquo;Relational operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>single bit type</td></tr></tbody></table><h3 id=moorelt-circtmooreltop><code>moore.lt</code> (::circt::moore::LtOp)&nbsp;<a class=headline-hash href=#moorelt-circtmooreltop>¶</a></h3><p><em>Less than</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.lt` $lhs `,` $rhs attr-dict `:` type($lhs) `-&gt;` type($result)
</code></pre><p>Compares the left- and right-hand side operand and returns a single bit 0,
1, or X result. If any bit in the two operands is Z or X, returns X.
Otherwise, if all bits are 0 or 1, <code>lt</code>, <code>le</code>, <code>gt</code>, and <code>ge</code> return whether
the left-hand side is less than, less than or equal to, greater than, or
greater than or equal to the right-hand side, respectively. <code>lt</code> corresponds
to the <code>&lt;</code> operator, <code>le</code> to <code>&lt;=</code>, <code>gt</code> to <code>></code>, and <code>ge</code> to <code>>=</code>.</p><p>See IEEE 1800-2017 § 11.4.4 &ldquo;Relational operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>single bit type</td></tr></tbody></table><h3 id=mooremod-circtmooremodop><code>moore.mod</code> (::circt::moore::ModOp)&nbsp;<a class=headline-hash href=#mooremod-circtmooremodop>¶</a></h3><p><em>Remainder</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.mod` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Compute the remainder of the left-hand side divided by the right-hand side
operand. If the right-hand side is zero, all bits of the result are X. The
sign of the result is the sign of the left-hand side. If any bit in the two
operands is Z or X, all bits in the result are X.</p><p>See IEEE 1800-2017 § 11.4.3 &ldquo;Arithmetic operators&rdquo;.</p><p>Consider the following examples:</p><table><thead><tr><th>LHS</th><th>RHS</th><th>Result</th></tr></thead><tbody><tr><td>11</td><td>3</td><td>2</td></tr><tr><td>-11</td><td>3</td><td>-2</td></tr><tr><td>11</td><td>-3</td><td>2</td></tr><tr><td>-11</td><td>-3</td><td>-2</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>simple bit vector type</td></tr></tbody></table><h3 id=mooremul-circtmooremulop><code>moore.mul</code> (::circt::moore::MulOp)&nbsp;<a class=headline-hash href=#mooremul-circtmooremulop>¶</a></h3><p><em>Multiplication</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.mul` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Multiply the operands. If any bit in the two operands is Z or X, all bits in
the result are X.</p><p>See IEEE 1800-2017 § 11.4.3 &ldquo;Arithmetic operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>simple bit vector type</td></tr></tbody></table><h3 id=moorene-circtmooreneop><code>moore.ne</code> (::circt::moore::NeOp)&nbsp;<a class=headline-hash href=#moorene-circtmooreneop>¶</a></h3><p><em>Logical inequality</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.ne` $lhs `,` $rhs attr-dict `:` type($lhs) `-&gt;` type($result)
</code></pre><p>Compares the bits in the left- and right-hand side operand and returns a
single bit 0, 1, or X result. If all corresponding bits in the left- and
right-hand side are equal, and all are 0 or 1 (not X or Z), the two operands
are considered equal (<code>eq</code> returns 1, <code>ne</code> returns 0). If any bits are not
equal, but all are 0 or 1, the two operands are considered not equal (<code>eq</code>
returns 0, <code>ne</code> returns 1). If any bit in the two operands is Z or X,
returns X. <code>eq</code> corresponds to the <code>==</code> operator and <code>ne</code> to the <code>!=</code>
operator.</p><p>See IEEE 1800-2017 § 11.4.5 &ldquo;Equality operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>single bit type</td></tr></tbody></table><h3 id=mooreneg-circtmoorenegop><code>moore.neg</code> (::circt::moore::NegOp)&nbsp;<a class=headline-hash href=#mooreneg-circtmoorenegop>¶</a></h3><p><em>Arithmetic negation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.neg` $input attr-dict `:` type($input)
</code></pre><p>Negate a value to its two&rsquo;s complement form. If any bit in the input is Z or
X, all bits in the result are X.</p><p>See IEEE 1800-2017 § 11.4.3 &ldquo;Arithmetic operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>simple bit vector type</td></tr></tbody></table><h3 id=moorenonblocking_assign-circtmoorenonblockingassignop><code>moore.nonblocking_assign</code> (::circt::moore::NonBlockingAssignOp)&nbsp;<a class=headline-hash href=#moorenonblocking_assign-circtmoorenonblockingassignop>¶</a></h3><p><em>Nonblocking procedural assignment</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.nonblocking_assign` $dst `,` $src attr-dict `:` type($src)
</code></pre><p>A nonblocking procedural assignment in a sequential block, such as <code>x &lt;= y;</code>
or <code>x &lt;= @(posedge y) z</code> or <code>x &lt;= #1ns y</code>. The assignment does not take
effect immediately. Subsequent operations in the block do not see the
effects of this assignment. Instead, the assignment is scheduled to happen
in a subsequent time step as dictated by the delay or event control.</p><p>See IEEE 1800-2017 § 10.4.2 &ldquo;Nonblocking procedural assignments&rdquo;.</p><p>Traits: <code>SameTypeOperands</code></p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>any type</td></tr><tr><td style=text-align:center><code>src</code></td><td>any type</td></tr></tbody></table><h3 id=moorenot-circtmoorenotop><code>moore.not</code> (::circt::moore::NotOp)&nbsp;<a class=headline-hash href=#moorenot-circtmoorenotop>¶</a></h3><p><em>Bitwise unary negation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.not` $input attr-dict `:` type($input)
</code></pre><p>Applies the boolean NOT operation to each bit in the input. Corresponds to
the <code>~</code> operator, as well as the negation in the <code>~&</code>, <code>~|</code>, <code>^~</code>, and <code>~^</code>
reduction operators.</p><p>See IEEE 1800-2017 § 11.4.8 &ldquo;Bitwise operators&rdquo;.</p><table><thead><tr><th>Input</th><th>Result</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td></tr><tr><td>X</td><td>X</td></tr><tr><td>Z</td><td>X</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>simple bit vector type</td></tr></tbody></table><h3 id=mooreor-circtmooreorop><code>moore.or</code> (::circt::moore::OrOp)&nbsp;<a class=headline-hash href=#mooreor-circtmooreorop>¶</a></h3><p><em>Bitwise OR operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.or` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Applies the boolean OR operation to each pair of corresponding bits in the
left- and right-hand side operand. Corresponds to the <code>|</code> operator.</p><p>See IEEE 1800-2017 § 11.4.8 &ldquo;Bitwise operators&rdquo;.</p><table><thead><tr><th></th><th>0</th><th>1</th><th>X</th><th>Z</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>X</td><td>X</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>X</td><td>X</td><td>1</td><td>X</td><td>X</td></tr><tr><td>Z</td><td>X</td><td>1</td><td>X</td><td>X</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>simple bit vector type</td></tr></tbody></table><h3 id=mooreprocedure-circtmooreprocedureop><code>moore.procedure</code> (::circt::moore::ProcedureOp)&nbsp;<a class=headline-hash href=#mooreprocedure-circtmooreprocedureop>¶</a></h3><p><em>A procedure executed at different points in time</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.procedure` $kind attr-dict-with-keyword $bodyRegion
</code></pre><p>The <code>moore.procedure</code> operation represents the SystemVerilog <code>initial</code>,
<code>final</code>, <code>always</code>, <code>always_comb</code>, <code>always_latch</code>, and <code>always_ff</code>
procedures.</p><p>Execution times of the various procedures:</p><ul><li><p>An <code>initial</code> procedure is executed once at the start of a design&rsquo;s
lifetime, before any other procedures are executed.</p></li><li><p>A <code>final</code> procedure is executed once at the end of a design&rsquo;s lifetime,
after all other procedures have stopped execution.</p></li><li><p>An <code>always</code> or <code>always_ff</code> procedure is repeatedly executed during a
design&rsquo;s lifetime. Timing and event control inside the procedure can
suspend its execution, for example to wait for a signal to change. If no
such timing or event control is present, the procedure repeats infinitely
at the current timestep, effectively deadlocking the design.</p></li><li><p>An <code>always_comb</code> or <code>always_latch</code> procedure is executed once at the start
of a design&rsquo;s lifetime, after any <code>initial</code> procedures, and throughout the
lifetime of the design whenever any of the variables read by the body of
the procedure changes. Since the procedure is only executed when its
change, and not repeatedly, the body generally does not contain any timing
or event control. This behavior mitigates a shortcoming of <code>always</code>
procedures, which commonly have an event control like <code>@*</code> that blocks
and waits for a change of any input signals. This prevents the body from
executing when the design is initialized and properly reacting to the
initial values of signals. In contrast, <code>always_comb</code> and <code>always_latch</code>
procedures have an implicit unconditional execution at design start-up.</p></li></ul><p>See IEEE 1800-2017 § 9.2 &ldquo;Structured procedures&rdquo;.</p><p>Traits: <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>RecursiveMemoryEffects</code>, <code>RecursivelySpeculatableImplTrait</code>, <code>SingleBlock</code></p><p>Interfaces: <code>ConditionallySpeculatable</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>kind</code></td><td>circt::moore::ProcedureKindAttr</td><td>Procedure kind</td></tr></table><h3 id=mooreread_lvalue-circtmoorereadlvalueop><code>moore.read_lvalue</code> (::circt::moore::ReadLValueOp)&nbsp;<a class=headline-hash href=#mooreread_lvalue-circtmoorereadlvalueop>¶</a></h3><p><em>Read the current value of a declaration</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.read_lvalue` $input attr-dict `:` type($result)
</code></pre><p>Samples the current value of a declaration. This is a helper to capture the
exact point at which declarations that can be targeted by assignments are
read.</p><p>Traits: <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>unpacked type</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>unpacked type</td></tr></tbody></table><h3 id=moorereduce_and-circtmoorereduceandop><code>moore.reduce_and</code> (::circt::moore::ReduceAndOp)&nbsp;<a class=headline-hash href=#moorereduce_and-circtmoorereduceandop>¶</a></h3><p><em>Reduction AND operator</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.reduce_and` $input attr-dict `:` type($input) `-&gt;` type($result)
</code></pre><p>Reduces all bits in the input to a single result bit by iteratively applying
the boolean AND operator. If the input has only a single bit, that bit is
returned.</p><p>See IEEE 1800-2017 § 11.4.9 &ldquo;Reduction operators&rdquo;. See the corresponding
<code>and</code>, <code>or</code>, and <code>xor</code> operations for the truth table.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>single bit type</td></tr></tbody></table><h3 id=moorereduce_or-circtmoorereduceorop><code>moore.reduce_or</code> (::circt::moore::ReduceOrOp)&nbsp;<a class=headline-hash href=#moorereduce_or-circtmoorereduceorop>¶</a></h3><p><em>Reduction OR operator</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.reduce_or` $input attr-dict `:` type($input) `-&gt;` type($result)
</code></pre><p>Reduces all bits in the input to a single result bit by iteratively applying
the boolean OR operator. If the input has only a single bit, that bit is
returned.</p><p>See IEEE 1800-2017 § 11.4.9 &ldquo;Reduction operators&rdquo;. See the corresponding
<code>and</code>, <code>or</code>, and <code>xor</code> operations for the truth table.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>single bit type</td></tr></tbody></table><h3 id=moorereduce_xor-circtmoorereducexorop><code>moore.reduce_xor</code> (::circt::moore::ReduceXorOp)&nbsp;<a class=headline-hash href=#moorereduce_xor-circtmoorereducexorop>¶</a></h3><p><em>Reduction XOR operator</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.reduce_xor` $input attr-dict `:` type($input) `-&gt;` type($result)
</code></pre><p>Reduces all bits in the input to a single result bit by iteratively applying
the boolean XOR operator. If the input has only a single bit, that bit is
returned.</p><p>See IEEE 1800-2017 § 11.4.9 &ldquo;Reduction operators&rdquo;. See the corresponding
<code>and</code>, <code>or</code>, and <code>xor</code> operations for the truth table.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>single bit type</td></tr></tbody></table><h3 id=mooremodule-circtmooresvmoduleop><code>moore.module</code> (::circt::moore::SVModuleOp)&nbsp;<a class=headline-hash href=#mooremodule-circtmooresvmoduleop>¶</a></h3><p><em>A module definition</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.module` $sym_name attr-dict-with-keyword $bodyRegion
</code></pre><p>The <code>moore.module</code> operation represents a SystemVerilog module, including
its name, port list, and the constituent parts that make up its body. The
module&rsquo;s body is an SSACFG region, since declarations within SystemVerilog
modules generally have to appear before their uses, and dedicated assignment
operators are used to make connections after declarations.</p><p>See IEEE 1800-2017 § 3.3 &ldquo;Modules&rdquo; and § 23.2 &ldquo;Module definitions&rdquo;.</p><p>Traits: <code>IsolatedFromAbove</code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=mooreshl-circtmooreshlop><code>moore.shl</code> (::circt::moore::ShlOp)&nbsp;<a class=headline-hash href=#mooreshl-circtmooreshlop>¶</a></h3><p><em>Logical left shift</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.shl` $value `,` $amount attr-dict `:` type($value) `,` type($amount)
</code></pre><p>Shifts the <code>value</code> to the left or right by <code>amount</code> number of bits. The
result has the same type as the input value. The amount is always treated as
an unsigned number and has no effect on the signedness of the result. X or
Z bits in the input value are simply shifted left or right the same way 0 or
1 bits are. If the amount contains X or Z bits, all result bits are X.</p><p><code>shl</code> shifts bits to the left, filling in 0 for the vacated least
significant bits. <code>shr</code> and <code>ashr</code> shift bits to the right; <code>shr</code> fills in
0 for the vacated most significant bits, and <code>ashr</code> copies the input&rsquo;s sign
bit into the vacated most significant bits. Note that in contrast to the SV
spec, the <code>ashr</code> <em>always</em> fills in the sign bit regardless of the signedness
of the input.</p><p><code>shl</code> corresponds to the <code>&lt;&lt;</code> and <code>&lt;&lt;&lt;</code> operators. <code>shr</code> corresponds to the
<code>>></code> operator, and the <code>>>></code> operator applied to an unsigned value. <code>ashr</code>
corresponds to the <code>>>></code> operator applied to a signed value.</p><p>See IEEE 1800-2017 § 11.4.10 &ldquo;Shift operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>amount</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>simple bit vector type</td></tr></tbody></table><h3 id=mooreshr-circtmooreshrop><code>moore.shr</code> (::circt::moore::ShrOp)&nbsp;<a class=headline-hash href=#mooreshr-circtmooreshrop>¶</a></h3><p><em>Logical right shift</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.shr` $value `,` $amount attr-dict `:` type($value) `,` type($amount)
</code></pre><p>Shifts the <code>value</code> to the left or right by <code>amount</code> number of bits. The
result has the same type as the input value. The amount is always treated as
an unsigned number and has no effect on the signedness of the result. X or
Z bits in the input value are simply shifted left or right the same way 0 or
1 bits are. If the amount contains X or Z bits, all result bits are X.</p><p><code>shl</code> shifts bits to the left, filling in 0 for the vacated least
significant bits. <code>shr</code> and <code>ashr</code> shift bits to the right; <code>shr</code> fills in
0 for the vacated most significant bits, and <code>ashr</code> copies the input&rsquo;s sign
bit into the vacated most significant bits. Note that in contrast to the SV
spec, the <code>ashr</code> <em>always</em> fills in the sign bit regardless of the signedness
of the input.</p><p><code>shl</code> corresponds to the <code>&lt;&lt;</code> and <code>&lt;&lt;&lt;</code> operators. <code>shr</code> corresponds to the
<code>>></code> operator, and the <code>>>></code> operator applied to an unsigned value. <code>ashr</code>
corresponds to the <code>>>></code> operator applied to a signed value.</p><p>See IEEE 1800-2017 § 11.4.10 &ldquo;Shift operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>amount</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>simple bit vector type</td></tr></tbody></table><h3 id=mooresub-circtmooresubop><code>moore.sub</code> (::circt::moore::SubOp)&nbsp;<a class=headline-hash href=#mooresub-circtmooresubop>¶</a></h3><p><em>Subtraction</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.sub` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Subtract the right-hand side from the left-hand side operand. If any bit in
the two operands is Z or X, all bits in the result are X.</p><p>See IEEE 1800-2017 § 11.4.3 &ldquo;Arithmetic operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>simple bit vector type</td></tr></tbody></table><h3 id=moorevariable-circtmoorevariableop><code>moore.variable</code> (::circt::moore::VariableOp)&nbsp;<a class=headline-hash href=#moorevariable-circtmoorevariableop>¶</a></h3><p><em>A variable declaration</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.variable` `` custom&lt;ImplicitSSAName&gt;($name) ($initial^)? attr-dict
              `:` type($result)
</code></pre><p>See IEEE 1800-2017 § 6.8 &ldquo;Variable declarations&rdquo;.</p><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>initial</code></td><td>unpacked type</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>unpacked type</td></tr></tbody></table><h3 id=moorewildcard_eq-circtmoorewildcardeqop><code>moore.wildcard_eq</code> (::circt::moore::WildcardEqOp)&nbsp;<a class=headline-hash href=#moorewildcard_eq-circtmoorewildcardeqop>¶</a></h3><p><em>Wildcard equality</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.wildcard_eq` $lhs `,` $rhs attr-dict `:` type($lhs) `-&gt;` type($result)
</code></pre><p>Compares the bits in the left- and right-hand side operand and returns a
single bit 0, 1, or X result. If any bit in the left-hand side is Z or X,
returns X. Performs the same comparison as the <code>eq</code> and <code>ne</code> operations, but
all right-hand side bits that are X or Z are skipped. Therefore, X and Z in
the right-hand side act as wildcards or &ldquo;don&rsquo;t care&rdquo; values. <code>wildcard_eq</code>
corresponds to the <code>==?</code> operator and <code>wildcard_ne</code> to the <code>!=?</code> operator.</p><p>See IEEE 1800-2017 § 11.4.6 &ldquo;Wildcard equality operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>single bit type</td></tr></tbody></table><h3 id=moorewildcard_ne-circtmoorewildcardneop><code>moore.wildcard_ne</code> (::circt::moore::WildcardNeOp)&nbsp;<a class=headline-hash href=#moorewildcard_ne-circtmoorewildcardneop>¶</a></h3><p><em>Wildcard inequality</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.wildcard_ne` $lhs `,` $rhs attr-dict `:` type($lhs) `-&gt;` type($result)
</code></pre><p>Compares the bits in the left- and right-hand side operand and returns a
single bit 0, 1, or X result. If any bit in the left-hand side is Z or X,
returns X. Performs the same comparison as the <code>eq</code> and <code>ne</code> operations, but
all right-hand side bits that are X or Z are skipped. Therefore, X and Z in
the right-hand side act as wildcards or &ldquo;don&rsquo;t care&rdquo; values. <code>wildcard_eq</code>
corresponds to the <code>==?</code> operator and <code>wildcard_ne</code> to the <code>!=?</code> operator.</p><p>See IEEE 1800-2017 § 11.4.6 &ldquo;Wildcard equality operators&rdquo;.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>single bit type</td></tr></tbody></table><h3 id=moorexor-circtmoorexorop><code>moore.xor</code> (::circt::moore::XorOp)&nbsp;<a class=headline-hash href=#moorexor-circtmoorexorop>¶</a></h3><p><em>Bitwise XOR operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `moore.xor` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Applies the boolean XOR operation to each pair of corresponding bits in the
left- and right-hand side operand. Corresponds to the <code>^</code> operator.</p><p>See IEEE 1800-2017 § 11.4.8 &ldquo;Bitwise operators&rdquo;.</p><table><thead><tr><th></th><th>0</th><th>1</th><th>X</th><th>Z</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>X</td><td>X</td></tr><tr><td>1</td><td>1</td><td>0</td><td>X</td><td>X</td></tr><tr><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td></tr><tr><td>Z</td><td>X</td><td>X</td><td>X</td><td>X</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>simple bit vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>simple bit vector type</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>simple bit vector type</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/LTL/ title="'ltl' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'ltl' Dialect</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/MSFT/ title="'msft' Dialect">Next - 'msft' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li class=active><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>