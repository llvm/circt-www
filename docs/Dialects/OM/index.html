<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'om' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/OM/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'om' Dialect</h1><p>The Object Model dialect captures design intent from various domains in an
object model.</p><p>For more information about the Object Model dialect, see the
<a href=/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a>.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#omany_cast-circtomanycastop><code>om.any_cast</code> (::circt::om::AnyCastOp)</a></li><li><a href=#ombasepath_create-circtombasepathcreateop><code>om.basepath_create</code> (::circt::om::BasePathCreateOp)</a></li><li><a href=#omclass-circtomclassop><code>om.class</code> (::circt::om::ClassOp)</a></li><li><a href=#omclassextern-circtomclassexternop><code>om.class.extern</code> (::circt::om::ClassExternOp)</a></li><li><a href=#omclassexternfield-circtomclassexternfieldop><code>om.class.extern.field</code> (::circt::om::ClassExternFieldOp)</a></li><li><a href=#omclassfield-circtomclassfieldop><code>om.class.field</code> (::circt::om::ClassFieldOp)</a></li><li><a href=#omconstant-circtomconstantop><code>om.constant</code> (::circt::om::ConstantOp)</a></li><li><a href=#omfrozenbasepath_create-circtomfrozenbasepathcreateop><code>om.frozenbasepath_create</code> (::circt::om::FrozenBasePathCreateOp)</a></li><li><a href=#omfrozenpath_create-circtomfrozenpathcreateop><code>om.frozenpath_create</code> (::circt::om::FrozenPathCreateOp)</a></li><li><a href=#omfrozenpath_empty-circtomfrozenemptypathop><code>om.frozenpath_empty</code> (::circt::om::FrozenEmptyPathOp)</a></li><li><a href=#omintegeradd-circtomintegeraddop><code>om.integer.add</code> (::circt::om::IntegerAddOp)</a></li><li><a href=#omintegermul-circtomintegermulop><code>om.integer.mul</code> (::circt::om::IntegerMulOp)</a></li><li><a href=#omintegershr-circtomintegershrop><code>om.integer.shr</code> (::circt::om::IntegerShrOp)</a></li><li><a href=#omlist_create-circtomlistcreateop><code>om.list_create</code> (::circt::om::ListCreateOp)</a></li><li><a href=#ommap_create-circtommapcreateop><code>om.map_create</code> (::circt::om::MapCreateOp)</a></li><li><a href=#omobject-circtomobjectop><code>om.object</code> (::circt::om::ObjectOp)</a></li><li><a href=#omobjectfield-circtomobjectfieldop><code>om.object.field</code> (::circt::om::ObjectFieldOp)</a></li><li><a href=#ompath_create-circtompathcreateop><code>om.path_create</code> (::circt::om::PathCreateOp)</a></li><li><a href=#ompath_empty-circtomemptypathop><code>om.path_empty</code> (::circt::om::EmptyPathOp)</a></li><li><a href=#omtuple_create-circtomtuplecreateop><code>om.tuple_create</code> (::circt::om::TupleCreateOp)</a></li><li><a href=#omtuple_get-circtomtuplegetop><code>om.tuple_get</code> (::circt::om::TupleGetOp)</a></li></ul></li><li><a href=#attributes-12>Attributes</a><ul><li><a href=#mapattr>MapAttr</a></li><li><a href=#integerattr>IntegerAttr</a></li><li><a href=#listattr>ListAttr</a></li><li><a href=#pathattr>PathAttr</a></li><li><a href=#symbolrefattr>SymbolRefAttr</a></li><li><a href=#referenceattr>ReferenceAttr</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#basepathtype>BasePathType</a></li><li><a href=#classtype>ClassType</a></li><li><a href=#frozenbasepathtype>FrozenBasePathType</a></li><li><a href=#frozenpathtype>FrozenPathType</a></li><li><a href=#listtype>ListType</a></li><li><a href=#maptype>MapType</a></li><li><a href=#anytype>AnyType</a></li><li><a href=#omintegertype>OMIntegerType</a></li><li><a href=#pathtype>PathType</a></li><li><a href=#referencetype>ReferenceType</a></li><li><a href=#stringtype>StringType</a></li><li><a href=#symbolreftype>SymbolRefType</a></li></ul></li></ul></nav><h2 id=operations>Operations</h2><h3 id=omany_cast-circtomanycastop><code>om.any_cast</code> (::circt::om::AnyCastOp)</h3><p><em>Cast any value to any type.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.any_cast` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Casts any value to AnyType. This is useful for situations where a value of
AnyType is needed, but a value of some concrete type is known.</p><p>In the evaluator, this is a noop, and the value of concrete type is used.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>A type that represents any valid OM type.</td></tr></tbody></table><h3 id=ombasepath_create-circtombasepathcreateop><code>om.basepath_create</code> (::circt::om::BasePathCreateOp)</h3><p><em>Produce a base path value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.basepath_create` $basePath $target attr-dict
</code></pre><p>Produces a value which represents a fragment of a hierarchical path to a
target. Given a base path, extend it with the name of a module instance, to
produce a new base path. The instance is identified via an NLA. Once the
final verilog name of the instance is known, this op can be converted into
a FrozenBasePathOp.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>hw<span class=p>.</span>module <span class=nf>@Foo</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  hw<span class=p>.</span>inst <span class=s>&#34;bar&#34;</span> sym <span class=nf>@bar</span> <span class=nf>@Bar</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>hw<span class=p>.</span>hierpath <span class=nf>@Path</span> <span class=p>[</span><span class=nf>@Foo</span><span class=p>::</span><span class=nf>@bar</span><span class=p>]</span>
</span></span><span class=line><span class=cl>om<span class=p>.</span>class <span class=nf>@OM</span><span class=p>(</span><span class=nv>%basepath</span><span class=p>:</span> <span class=p>!</span>om<span class=p>.</span>basepath<span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> om<span class=p>.</span>basepath_create <span class=nv>%base</span> <span class=nf>@Path</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>target</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>basePath</code></td><td>A fragment of a path to a hardware component</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>A fragment of a path to a hardware component</td></tr></tbody></table><h3 id=omclass-circtomclassop><code>om.class</code> (::circt::om::ClassOp)</h3><p>Traits: <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>ClassLike</code>, <code>OpAsmOpInterface</code>, <code>RegionKindInterface</code>, <code>Symbol</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>formalParamNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h3 id=omclassextern-circtomclassexternop><code>om.class.extern</code> (::circt::om::ClassExternOp)</h3><p>Traits: <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>ClassLike</code>, <code>OpAsmOpInterface</code>, <code>RegionKindInterface</code>, <code>Symbol</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>formalParamNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h3 id=omclassexternfield-circtomclassexternfieldop><code>om.class.extern.field</code> (::circt::om::ClassExternFieldOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.class.extern.field` $name attr-dict `:` $type
</code></pre><p>Traits: <code>HasParent&lt;ClassExternOp></code></p><p>Interfaces: <code>ClassFieldLike</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h3 id=omclassfield-circtomclassfieldop><code>om.class.field</code> (::circt::om::ClassFieldOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.class.field` $name `,` $value  attr-dict `:` type($value)
</code></pre><p>Traits: <code>HasParent&lt;ClassOp></code></p><p>Interfaces: <code>ClassFieldLike</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h3 id=omconstant-circtomconstantop><code>om.constant</code> (::circt::om::ConstantOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.constant` $value attr-dict
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::TypedAttr</td><td>TypedAttr instance</td></tr></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=omfrozenbasepath_create-circtomfrozenbasepathcreateop><code>om.frozenbasepath_create</code> (::circt::om::FrozenBasePathCreateOp)</h3><p><em>Produce a frozen base path value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.frozenbasepath_create` $basePath custom&lt;BasePathString&gt;($path) attr-dict
</code></pre><p>Produces a value which represents a fragment of a hierarchical path to a
target.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>om<span class=p>.</span>class <span class=nf>@OM</span><span class=p>(</span><span class=nv>%basepath</span><span class=p>:</span> <span class=p>!</span>om<span class=p>.</span>basepath<span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> om<span class=p>.</span>frozenbasepath_create <span class=nv>%basepath</span> <span class=s>&#34;Foo/bar:Bar/baz&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>path</code></td><td>::circt::om::PathAttr</td><td>An attribute that represents an instance path</td></tr></table><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>basePath</code></td><td>A frozen fragment of a path to a hardware component</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>A frozen fragment of a path to a hardware component</td></tr></tbody></table><h3 id=omfrozenpath_create-circtomfrozenpathcreateop><code>om.frozenpath_create</code> (::circt::om::FrozenPathCreateOp)</h3><p><em>Produce a frozen path value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.frozenpath_create` $targetKind $basePath custom&lt;PathString&gt;($path, $module, $ref, $field)
              attr-dict
</code></pre><p>Produces a value which represents a hierarchical path to a hardware
component from a base path to a target.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>om<span class=p>.</span>class <span class=nf>@OM</span><span class=p>(</span><span class=nv>%basepath</span><span class=p>:</span> <span class=p>!</span>om<span class=p>.</span>basepath<span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> om<span class=p>.</span>frozenpath_create reference <span class=nv>%base</span> <span class=s>&#34;Foo/bar:Bar&gt;w.a&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-7>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>targetKind</code></td><td>::circt::om::TargetKindAttr</td><td>object model target kind</td></tr><tr><td><code>path</code></td><td>::circt::om::PathAttr</td><td>An attribute that represents an instance path</td></tr><tr><td><code>module</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>ref</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>field</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>basePath</code></td><td>A frozen fragment of a path to a hardware component</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>A frozen path to a hardware component</td></tr></tbody></table><h3 id=omfrozenpath_empty-circtomfrozenemptypathop><code>om.frozenpath_empty</code> (::circt::om::FrozenEmptyPathOp)</h3><p><em>Produce a frozen path value to nothing</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.frozenpath_empty` attr-dict
</code></pre><p>Produces a value which represents a hierarchical path to nothing.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>om<span class=p>.</span>class <span class=nf>@OM</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> om<span class=p>.</span>frozenpath_empty
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>A frozen path to a hardware component</td></tr></tbody></table><h3 id=omintegeradd-circtomintegeraddop><code>om.integer.add</code> (::circt::om::IntegerAddOp)</h3><p><em>Add two OMIntegerType values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.integer.add` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Perform arbitrary precision signed integer addition of two OMIntegerType
values.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> om<span class=p>.</span>integer<span class=p>.</span>add <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>om<span class=p>.</span>integer
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>IntegerBinaryArithmeticOp</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type that represents an arbitrary width integer.</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type that represents an arbitrary width integer.</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>A type that represents an arbitrary width integer.</td></tr></tbody></table><h3 id=omintegermul-circtomintegermulop><code>om.integer.mul</code> (::circt::om::IntegerMulOp)</h3><p><em>Multiply two OMIntegerType values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.integer.mul` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Perform arbitrary prevision signed integer multiplication of two
OMIntegerType values.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> om<span class=p>.</span>integer<span class=p>.</span>mul <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>om<span class=p>.</span>integer
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>IntegerBinaryArithmeticOp</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type that represents an arbitrary width integer.</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type that represents an arbitrary width integer.</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>A type that represents an arbitrary width integer.</td></tr></tbody></table><h3 id=omintegershr-circtomintegershrop><code>om.integer.shr</code> (::circt::om::IntegerShrOp)</h3><p><em>Shift an OMIntegerType value right by an OMIntegerType value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.integer.shr` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Perform arbitrary precision signed integer arithmetic shift right of the lhs
OMIntegerType value by the rhs OMIntegerType value. The rhs value must be
non-negative.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> om<span class=p>.</span>integer<span class=p>.</span>shr <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>om<span class=p>.</span>integer
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>IntegerBinaryArithmeticOp</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>A type that represents an arbitrary width integer.</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>A type that represents an arbitrary width integer.</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>A type that represents an arbitrary width integer.</td></tr></tbody></table><h3 id=omlist_create-circtomlistcreateop><code>om.list_create</code> (::circt::om::ListCreateOp)</h3><p><em>Create a list of values</em></p><p>Creates a list from a sequence of inputs.</p><pre tabindex=0><code>%list = om.list_create %a, %b, %c : !om.ref
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>A type that represents a list.</td></tr></tbody></table><h3 id=ommap_create-circtommapcreateop><code>om.map_create</code> (::circt::om::MapCreateOp)</h3><p><em>Create a map</em></p><p>Creates a map from a sequence of inputs.</p><pre tabindex=0><code>%map = om.map_create %e1, %e2 : !om.string, i8
</code></pre><p>where <code>%e1</code> and <code>e2</code> have !om.tuple&lt;!om.string, i8> and
<code>%map</code> has <code>!om.map&lt;!om.string, i8></code> type.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of a pair whose first element is an attribute</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>A type that represents a map. A key type must be either</td></tr><tr><td style=text-align:center>an integer or string type</td><td></td></tr></tbody></table><h3 id=omobject-circtomobjectop><code>om.object</code> (::circt::om::ObjectOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.object` $className `(` $actualParams `)`  attr-dict `:`
              functional-type($actualParams, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-8>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>className</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>actualParams</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>A type that represents a reference to a Class.</td></tr></tbody></table><h3 id=omobjectfield-circtomobjectfieldop><code>om.object.field</code> (::circt::om::ObjectFieldOp)</h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.object.field` $object `,` $fieldPath attr-dict `:` functional-type($object, $result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-9>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fieldPath</code></td><td>::mlir::ArrayAttr</td><td>flat symbol ref array attribute</td></tr></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>object</code></td><td>A type that represents a reference to a Class.</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=ompath_create-circtompathcreateop><code>om.path_create</code> (::circt::om::PathCreateOp)</h3><p><em>Produce a path value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.path_create` $targetKind $basePath $target attr-dict
</code></pre><p>Produces a value which represents a hierarchical path to a hardware
target.
from a base path to a target.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>hw<span class=p>.</span>module <span class=nf>@Foo</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%wire</span> <span class=p>=</span> hw<span class=p>.</span>wire sym <span class=nf>@w</span><span class=p>:</span> <span class=p>!</span><span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>hw<span class=p>.</span>hierpath <span class=nf>@Path</span> <span class=p>[</span><span class=nf>@Foo</span><span class=p>::</span><span class=nf>@w</span><span class=p>]</span>
</span></span><span class=line><span class=cl>om<span class=p>.</span>class <span class=nf>@OM</span><span class=p>(</span><span class=nv>%basepath</span><span class=p>:</span> <span class=p>!</span>om<span class=p>.</span>basepath<span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> om<span class=p>.</span>path_create reference <span class=nv>%basepath</span> <span class=nf>@Path</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-10>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>targetKind</code></td><td>::circt::om::TargetKindAttr</td><td>object model target kind</td></tr><tr><td><code>target</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>basePath</code></td><td>A fragment of a path to a hardware component</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>A path to a hardware component</td></tr></tbody></table><h3 id=ompath_empty-circtomemptypathop><code>om.path_empty</code> (::circt::om::EmptyPathOp)</h3><p><em>Produce a path value to nothing</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.path_empty` attr-dict
</code></pre><p>Produces a value which represents a hierarchical path to nothing.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>om<span class=p>.</span>class <span class=nf>@OM</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> om<span class=p>.</span>path_empty
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>A path to a hardware component</td></tr></tbody></table><h3 id=omtuple_create-circtomtuplecreateop><code>om.tuple_create</code> (::circt::om::TupleCreateOp)</h3><p><em>Create a tuple of values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.tuple_create` $inputs attr-dict `:` type($inputs)
</code></pre><p>Create a tuple from a sequence of inputs.</p><pre tabindex=0><code>%tuple = om.tuple_create %a, %b, %c : !om.ref, !om.string, !om.list&lt;i32&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>tuple with any combination of any type values</td></tr></tbody></table><h3 id=omtuple_get-circtomtuplegetop><code>om.tuple_get</code> (::circt::om::TupleGetOp)</h3><p><em>Extract a value from a tuple</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `om.tuple_get` $input `[` $index `]` attr-dict `:` type($input)
</code></pre><p>Extract a value from a tuple.</p><pre tabindex=0><code>%value = om.tuple_get %a[0] : tuple&lt;!om.ref, !om.string, !om.list&lt;i32&gt;&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-11>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tuple with any combination of any type values</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h2 id=attributes-12>Attributes</h2><h3 id=mapattr>MapAttr</h3><p>An attribute that represents a string map</p><p>Syntax:</p><pre tabindex=0><code>#om.map&lt;
  mlir::Type,   # valueType
  mlir::DictionaryAttr   # elements
&gt;
</code></pre><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>valueType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>elements</td><td style=text-align:center><code>mlir::DictionaryAttr</code></td><td></td></tr></tbody></table><h3 id=integerattr>IntegerAttr</h3><p>An attribute that represents an arbitrary integer</p><p>Syntax:</p><pre tabindex=0><code>#om.integer&lt;
  mlir::IntegerAttr   # value
&gt;
</code></pre><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>mlir::IntegerAttr</code></td><td></td></tr></tbody></table><h3 id=listattr>ListAttr</h3><p>An attribute that represents a list</p><p>Syntax:</p><pre tabindex=0><code>#om.list&lt;
  mlir::Type,   # elementType
  mlir::ArrayAttr   # elements
&gt;
</code></pre><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>elements</td><td style=text-align:center><code>mlir::ArrayAttr</code></td><td></td></tr></tbody></table><h3 id=pathattr>PathAttr</h3><p>An attribute that represents an instance path</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>path</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::circt::om::PathElement></code></td><td></td></tr></tbody></table><h3 id=symbolrefattr>SymbolRefAttr</h3><p>An attribute that wraps a FlatSymbolRefAttr type</p><p>Syntax:</p><pre tabindex=0><code>#om.sym_ref&lt;
  mlir::FlatSymbolRefAttr   # ref
&gt;
</code></pre><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ref</td><td style=text-align:center><code>mlir::FlatSymbolRefAttr</code></td><td></td></tr></tbody></table><h3 id=referenceattr>ReferenceAttr</h3><p>An attribute that wraps a #hw.innerNameRef with !om.ref type</p><p>Syntax:</p><pre tabindex=0><code>#om.ref&lt;
  circt::hw::InnerRefAttr   # innerRef
&gt;
</code></pre><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>innerRef</td><td style=text-align:center><code>circt::hw::InnerRefAttr</code></td><td></td></tr></tbody></table><h2 id=types>Types</h2><h3 id=basepathtype>BasePathType</h3><p>A fragment of a path to a hardware component</p><p>Syntax: <code>!om.basepath</code></p><h3 id=classtype>ClassType</h3><p>A type that represents a reference to a Class.</p><p>Syntax:</p><pre tabindex=0><code>!om.class.type&lt;
  mlir::FlatSymbolRefAttr   # className
&gt;
</code></pre><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>className</td><td style=text-align:center><code>mlir::FlatSymbolRefAttr</code></td><td></td></tr></tbody></table><h3 id=frozenbasepathtype>FrozenBasePathType</h3><p>A frozen fragment of a path to a hardware component</p><p>Syntax: <code>!om.frozenbasepath</code></p><h3 id=frozenpathtype>FrozenPathType</h3><p>A frozen path to a hardware component</p><p>Syntax: <code>!om.frozenpath</code></p><h3 id=listtype>ListType</h3><p>A type that represents a list.</p><p>Syntax:</p><pre tabindex=0><code>!om.list&lt;
  mlir::Type   # elementType
&gt;
</code></pre><h4 id=parameters-7>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr></tbody></table><h3 id=maptype>MapType</h3><p>A type that represents a map. A key type must be either
an integer or string type</p><p>Syntax:</p><pre tabindex=0><code>!om.map&lt;
  mlir::Type,   # keyType
  mlir::Type   # valueType
&gt;
</code></pre><h4 id=parameters-8>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>keyType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>valueType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr></tbody></table><h3 id=anytype>AnyType</h3><p>A type that represents any valid OM type.</p><p>Syntax: <code>!om.any</code></p><h3 id=omintegertype>OMIntegerType</h3><p>A type that represents an arbitrary width integer.</p><p>Syntax: <code>!om.integer</code></p><h3 id=pathtype>PathType</h3><p>A path to a hardware component</p><p>Syntax: <code>!om.path</code></p><h3 id=referencetype>ReferenceType</h3><p>A type that represents a reference to a hardware entity.</p><p>Syntax: <code>!om.ref</code></p><h3 id=stringtype>StringType</h3><p>A type that represents a string.</p><p>Syntax: <code>!om.string</code></p><h3 id=symbolreftype>SymbolRefType</h3><p>A type that represents a reference to a flat symbol reference.</p><p>Syntax: <code>!om.sym_ref</code></p><h2>'om' Dialect Docs</h2><ul><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/MSFT/ title="'msft' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'msft' Dialect</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/ title="Object Model Dialect Rationale">Next - Object Model Dialect Rationale <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class="active has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>