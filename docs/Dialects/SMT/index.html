<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>SMT Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/SMT/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>SMT Dialect</h1><p>This dialect provides types and operations modeling the SMT (Satisfiability
Modulo Theories) operations and datatypes commonly found in SMT-LIB and SMT
solvers.</p><p><nav id=TableOfContents><ul><li><a href=#rationale>Rationale</a></li><li><a href=#dialect-structure>Dialect Structure</a></li><li><a href=#optimizations>Optimizations</a></li><li><a href=#backends>Backends</a><ul><li><a href=#llvm-ir>LLVM IR</a></li><li><a href=#smt-lib>SMT-LIB</a></li><li><a href=#cc>C/C++</a></li></ul></li><li><a href=#handling-counter-examples>Handling counter-examples</a></li><li><a href=#non-goals>Non-Goals</a></li><li><a href=#operations>Operations</a><ul><li><a href=#smtand-circtsmtandop><code>smt.and</code> (circt::smt::AndOp)</a></li><li><a href=#smtapply_func-circtsmtapplyfuncop><code>smt.apply_func</code> (circt::smt::ApplyFuncOp)</a></li><li><a href=#smtarraybroadcast-circtsmtarraybroadcastop><code>smt.array.broadcast</code> (circt::smt::ArrayBroadcastOp)</a></li><li><a href=#smtarrayselect-circtsmtarrayselectop><code>smt.array.select</code> (circt::smt::ArraySelectOp)</a></li><li><a href=#smtarraystore-circtsmtarraystoreop><code>smt.array.store</code> (circt::smt::ArrayStoreOp)</a></li><li><a href=#smtassert-circtsmtassertop><code>smt.assert</code> (circt::smt::AssertOp)</a></li><li><a href=#smtbvashr-circtsmtbvashrop><code>smt.bv.ashr</code> (circt::smt::BVAShrOp)</a></li><li><a href=#smtbvadd-circtsmtbvaddop><code>smt.bv.add</code> (circt::smt::BVAddOp)</a></li><li><a href=#smtbvand-circtsmtbvandop><code>smt.bv.and</code> (circt::smt::BVAndOp)</a></li><li><a href=#smtbvcmp-circtsmtbvcmpop><code>smt.bv.cmp</code> (circt::smt::BVCmpOp)</a></li><li><a href=#smtbvconstant-circtsmtbvconstantop><code>smt.bv.constant</code> (circt::smt::BVConstantOp)</a></li><li><a href=#smtbvlshr-circtsmtbvlshrop><code>smt.bv.lshr</code> (circt::smt::BVLShrOp)</a></li><li><a href=#smtbvmul-circtsmtbvmulop><code>smt.bv.mul</code> (circt::smt::BVMulOp)</a></li><li><a href=#smtbvneg-circtsmtbvnegop><code>smt.bv.neg</code> (circt::smt::BVNegOp)</a></li><li><a href=#smtbvnot-circtsmtbvnotop><code>smt.bv.not</code> (circt::smt::BVNotOp)</a></li><li><a href=#smtbvor-circtsmtbvorop><code>smt.bv.or</code> (circt::smt::BVOrOp)</a></li><li><a href=#smtbvsdiv-circtsmtbvsdivop><code>smt.bv.sdiv</code> (circt::smt::BVSDivOp)</a></li><li><a href=#smtbvsmod-circtsmtbvsmodop><code>smt.bv.smod</code> (circt::smt::BVSModOp)</a></li><li><a href=#smtbvsrem-circtsmtbvsremop><code>smt.bv.srem</code> (circt::smt::BVSRemOp)</a></li><li><a href=#smtbvshl-circtsmtbvshlop><code>smt.bv.shl</code> (circt::smt::BVShlOp)</a></li><li><a href=#smtbvudiv-circtsmtbvudivop><code>smt.bv.udiv</code> (circt::smt::BVUDivOp)</a></li><li><a href=#smtbvurem-circtsmtbvuremop><code>smt.bv.urem</code> (circt::smt::BVURemOp)</a></li><li><a href=#smtbvxor-circtsmtbvxorop><code>smt.bv.xor</code> (circt::smt::BVXOrOp)</a></li><li><a href=#smtconstant-circtsmtboolconstantop><code>smt.constant</code> (circt::smt::BoolConstantOp)</a></li><li><a href=#smtcheck-circtsmtcheckop><code>smt.check</code> (circt::smt::CheckOp)</a></li><li><a href=#smtbvconcat-circtsmtconcatop><code>smt.bv.concat</code> (circt::smt::ConcatOp)</a></li><li><a href=#smtdeclare_fun-circtsmtdeclarefunop><code>smt.declare_fun</code> (circt::smt::DeclareFunOp)</a></li><li><a href=#smtdistinct-circtsmtdistinctop><code>smt.distinct</code> (circt::smt::DistinctOp)</a></li><li><a href=#smteq-circtsmteqop><code>smt.eq</code> (circt::smt::EqOp)</a></li><li><a href=#smtexists-circtsmtexistsop><code>smt.exists</code> (circt::smt::ExistsOp)</a></li><li><a href=#smtbvextract-circtsmtextractop><code>smt.bv.extract</code> (circt::smt::ExtractOp)</a></li><li><a href=#smtforall-circtsmtforallop><code>smt.forall</code> (circt::smt::ForallOp)</a></li><li><a href=#smtimplies-circtsmtimpliesop><code>smt.implies</code> (circt::smt::ImpliesOp)</a></li><li><a href=#smtintabs-circtsmtintabsop><code>smt.int.abs</code> (circt::smt::IntAbsOp)</a></li><li><a href=#smtintadd-circtsmtintaddop><code>smt.int.add</code> (circt::smt::IntAddOp)</a></li><li><a href=#smtintcmp-circtsmtintcmpop><code>smt.int.cmp</code> (circt::smt::IntCmpOp)</a></li><li><a href=#smtintconstant-circtsmtintconstantop><code>smt.int.constant</code> (circt::smt::IntConstantOp)</a></li><li><a href=#smtintdiv-circtsmtintdivop><code>smt.int.div</code> (circt::smt::IntDivOp)</a></li><li><a href=#smtintmod-circtsmtintmodop><code>smt.int.mod</code> (circt::smt::IntModOp)</a></li><li><a href=#smtintmul-circtsmtintmulop><code>smt.int.mul</code> (circt::smt::IntMulOp)</a></li><li><a href=#smtintsub-circtsmtintsubop><code>smt.int.sub</code> (circt::smt::IntSubOp)</a></li><li><a href=#smtite-circtsmtiteop><code>smt.ite</code> (circt::smt::IteOp)</a></li><li><a href=#smtnot-circtsmtnotop><code>smt.not</code> (circt::smt::NotOp)</a></li><li><a href=#smtor-circtsmtorop><code>smt.or</code> (circt::smt::OrOp)</a></li><li><a href=#smtbvrepeat-circtsmtrepeatop><code>smt.bv.repeat</code> (circt::smt::RepeatOp)</a></li><li><a href=#smtsolver-circtsmtsolverop><code>smt.solver</code> (circt::smt::SolverOp)</a></li><li><a href=#smtxor-circtsmtxorop><code>smt.xor</code> (circt::smt::XOrOp)</a></li><li><a href=#smtyield-circtsmtyieldop><code>smt.yield</code> (circt::smt::YieldOp)</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#arraytype>ArrayType</a></li><li><a href=#bitvectortype>BitVectorType</a></li><li><a href=#booltype>BoolType</a></li><li><a href=#inttype>IntType</a></li><li><a href=#smtfunctype>SMTFuncType</a></li><li><a href=#sorttype>SortType</a></li></ul></li></ul></nav><h2 id=rationale>Rationale&nbsp;<a class=headline-hash href=#rationale>¶</a></h2><p>This dialect aims to provide a unified interface for expressing SMT problems
directly within MLIR, enabling seamless integration with other MLIR dialects and
optimization passes. It models the
<a href=https://smtlib.cs.uiowa.edu/>SMT-LIB standard
2.6</a>, but may also include features of commonly
used SMT solvers that are not part of the standard. In particular, the IR
constructs are designed to enable more interactive communication with the solver
(allowing if-statements, etc. to react on solver feedback).</p><p>The SMT dialect is motivated by the following advantages over directly printing
SMT-LIB or exporting to a solver:</p><ul><li>Reuse MLIR&rsquo;s infrastructure: passes and pass managers to select different SMT
encodings, operation builders and rewrite patterns to build SMT formulae (and
hide the solver&rsquo;s API in a provided lowering pass), common textual format to
share rather than dumping the solver&rsquo;s state, etc.</li><li>No need to add a link-dependency on SMT solvers to CIRCT (just provide the
path to the library as an argument to the JIT runner or manually link the
produced binary against it).</li><li>Using an SMT dialect as intermediary allows it to be mixed with concrete
computations, the debug dialect, etc. This is complicated to achieve and
reason about when building the external solver&rsquo;s state directly.</li><li>Enable easy addition of new backends</li><li>Have a common representation and infrastructure for all SMT related efforts,
such that people don&rsquo;t have to build their own isolated tools.</li></ul><p>The dialect follows these design principles:</p><ul><li><strong>Solver-independent</strong>: don&rsquo;t model one particular solver&rsquo;s API</li><li><strong>Seemless interoperability</strong> with other dialects. E.g., to allow using the
debug dialect to back-propagate counter examples</li><li><strong>Small surface for errors</strong>: try to keep the SMT dialect and its lowerings
simple to avoid mistakes, implement optimizations defensively or prove them
formally; since higher-level dialects will be lowered through the SMT dialect
to construct formal proofs it is essential that this dialect does not
introduce bugs</li><li><strong>Interactive</strong>: the IR should be designed such that it can be interleaved
with operations (from other dialects) that take the current feedback of the
solver to steer the execution of further SMT operations. It shouldn&rsquo;t just
model the very rigid SMT-LIB.</li><li>Don&rsquo;t heavily integrate the dialect itself with CIRCT to make potential
upstreaming easy</li></ul><h2 id=dialect-structure>Dialect Structure&nbsp;<a class=headline-hash href=#dialect-structure>¶</a></h2><p>The SMT dialect is structured into multiple &ldquo;sub-dialects&rdquo;, one for each of the
following theories (this separation is also made clear in the prefix of
operation and type names as indicated in parentheses):</p><ul><li>Core boolean logic including quantifiers and solver interaction (<code>smt.*</code>)</li><li>Bit-vectors (<code>smt.bv.*</code>)</li><li>Arbitrary-precision integers (<code>smt.int.*</code>)</li><li>Arrays (<code>smt.array.*</code>)</li><li>Floating-point numbers (<code>smt.real.*</code>)</li></ul><p>Several operations in the core part (e.g., quantifiers, equality, etc.) allow
operands of any SMT type (including bit-vectors, arrays, etc.). Therefore, all
type and attribute declarations are part of the core.</p><p>Certain arithmetic, bitwise, and comparison operations exist for multiple
theories. For example, there exists an AND operation for booleans and one for
bit-vectors, or there exists and ADD operation for integers and bit-vectors. In
such cases, each &ldquo;sub-dialect&rdquo; defines its own operation specific to its
datatypes. This simplifies the operations such that an optimization or
conversion pass only using bit-vectors does not have to take care of other
potentially supported datatypes.</p><h2 id=optimizations>Optimizations&nbsp;<a class=headline-hash href=#optimizations>¶</a></h2><p>The primary purpose of the SMT dialect is not to optimize SMT formulae. However,
SMT solvers can exhibit significant differences in runtime, even with slight
changes in input. Improving solver performance by implementing rewrite patterns
that slightly restructure the SMT formulae may be possible.</p><p>Moreover, SMT solvers may differ in terms of built-in operators. If a solver
lacks support for advanced operators, the problem can be simplified before
passing it to the solver.</p><h2 id=backends>Backends&nbsp;<a class=headline-hash href=#backends>¶</a></h2><p>Having an SMT dialect instead of directly interpreting the IR and building an
SMT expression enables multiple different backends to be used in addition to the
application of SMT dialect level optimizations that rewrite the formulae for
faster and more predictable runtime performance of the solver backend (e.g.,
Z3).</p><p>In the following, we outline the different backend lowerings and their
advantages and disadvantages.</p><h3 id=llvm-ir>LLVM IR&nbsp;<a class=headline-hash href=#llvm-ir>¶</a></h3><p>Lowering to LLVM IR that calls the C API of a given SMT solver is practical for
a few reasons:</p><ul><li>enables using LLVM JIT or compilation to a standalone binary</li><li>easy to mix with Debug dialect to report back nice counter examples</li><li>allows mixing concrete and symbolic executions (e.g., for dynamic BMC upper
bounds, or more dynamic interaction with the solver such as extraction of
multiple/all possible models)</li></ul><p>However, it is solver-dependent and more complicated to implement than an
SMT-LIB printer.</p><h3 id=smt-lib>SMT-LIB&nbsp;<a class=headline-hash href=#smt-lib>¶</a></h3><p>The SMT-LIB format is a standardized format supported by practically all SMT
solvers and thus an ideal target to support as many solver backends as possible.
However,</p><ul><li>this format is quite static and does not allow easy interaction with the
solver, in particular, it is not easily possible to make future asserts
dependent on current solver outputs,</li><li>providing good counter-examples to the user would mean parsing the textual
model output of the solver and mapping it to an CIRCT-internal datastructure.</li><li>it is impossible to mix symbolic and concrete executions, as well as debug
constructs (see Debug Dialect).</li><li>it is impossible to just use the LLVM JIT compiler to directly get a result,
but instead the external solver has to be called directly, either by adding a
compile-time dependency, or using a shell call.</li></ul><h3 id=cc>C/C++&nbsp;<a class=headline-hash href=#cc>¶</a></h3><p>A C/C++ exporter that produces code which calls the C/C++ API of a given solver
could allow for easier debugging and allows to support solvers without C API
without the restrictions of SMT-LIB. However, this means the JIT compilation
flow would not be available.</p><h2 id=handling-counter-examples>Handling counter-examples&nbsp;<a class=headline-hash href=#handling-counter-examples>¶</a></h2><p>SMT solvers check formulae for satisfiability. Typically, there are three kinds
of output a solver may give:</p><ul><li><strong>Satisfiable</strong>: In this case a model (counter-example) can be provided by the
solver. However, it may not be feasible to evaluate/interpret this model for a
given SMT constant to get a constant value. This is, in particular, the case
when the SMT encoding contains quantifiers which can lead to the model
containing quantifiers as well. Solvers (e.g., Z3) usually don&rsquo;t evaluate
quantifiers in models (even if they are closed). If constants can be
evaluated, a counter example can be provided and back-propagated to the
source-code, e.g., using the debug dialect.</li><li><strong>Unsatisfiable</strong>: formal verification problems are typically encoded such
that this output indicates correctness; a proof can be provided by the solver,
but is often not needed</li><li><strong>Unknown</strong>: there can be various reasons why the result is unknown; a common
one is the use of symbolic functions to represent operators and encode, e.g.,
a LEC problem as a rewrite task of patterns of function applications. This is
a frequent application and the unknown result is just treated like a
satisfiable result without counter example.</li></ul><h2 id=non-goals>Non-Goals&nbsp;<a class=headline-hash href=#non-goals>¶</a></h2><ul><li>The SMT Dialect does not aim to include any operations or types that model
verification constructs not specific to SMT, i.e., things that could also be
lowered to other kind of verification systems such as inductive theorem
provers (e.g., Lean4).</li></ul><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><h3 id=smtand-circtsmtandop><code>smt.and</code> (circt::smt::AndOp)&nbsp;<a class=headline-hash href=#smtand-circtsmtandop>¶</a></h3><p><em>A boolean conjunction</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.and` $inputs attr-dict
</code></pre><p>This operation performs a boolean conjunction.
The semantics are equivalent to the &lsquo;and&rsquo; operator in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a>.
of the SMT-LIB Standard 2.6.</p><pre><code>It supports a variadic number of operands, but requires at least two.
This is because the operator is annotated with the `:left-assoc` attribute
which means that `op a b c` is equivalent to `(op (op a b) c)`.
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtapply_func-circtsmtapplyfuncop><code>smt.apply_func</code> (circt::smt::ApplyFuncOp)&nbsp;<a class=headline-hash href=#smtapply_func-circtsmtapplyfuncop>¶</a></h3><p><em>Apply a function</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.apply_func` $func `(` $args `)` attr-dict `:` qualified(type($func))
</code></pre><p>This operation performs a function application as described in the
<a href=https://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2021-05-12.pdf>SMT-LIB 2.6 standard</a>.
It is part of the language itself rather than a theory or logic.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>func</code></td><td></td></tr><tr><td style=text-align:center><code>args</code></td><td>variadic of any non-function SMT value type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any non-function SMT value type</td></tr></tbody></table><h3 id=smtarraybroadcast-circtsmtarraybroadcastop><code>smt.array.broadcast</code> (circt::smt::ArrayBroadcastOp)&nbsp;<a class=headline-hash href=#smtarraybroadcast-circtsmtarraybroadcastop>¶</a></h3><p><em>Construct an array with the given value stored at every index</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.array.broadcast` $value attr-dict `:` qualified(type($result))
</code></pre><p>This operation represents a broadcast of the &lsquo;value&rsquo; operand to all indices
of the array. It is equivalent to</p><pre tabindex=0><code>%0 = smt.declare &#34;array&#34; : !smt.array&lt;[!smt.int -&gt; !smt.bool]&gt;
%1 = smt.forall [&#34;idx&#34;] {
^bb0(%idx: !smt.int):
  %2 = smt.array.select %0[%idx] : !smt.array&lt;[!smt.int -&gt; !smt.bool]&gt;
  %3 = smt.eq %value, %2 : !smt.bool
  smt.yield %3 : !smt.bool
}
smt.assert %1
// return %0
</code></pre><p>In SMT-LIB, this is frequently written as
<code>((as const (Array Int Bool)) value)</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any SMT value type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtarrayselect-circtsmtarrayselectop><code>smt.array.select</code> (circt::smt::ArraySelectOp)&nbsp;<a class=headline-hash href=#smtarrayselect-circtsmtarrayselectop>¶</a></h3><p><em>Get the value stored in the array at the given index</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.array.select` $array `[` $index `]` attr-dict `:` qualified(type($array))
</code></pre><p>This operation is retuns the value stored in the given array at the given
index. The semantics are equivalent to the <code>select</code> operator defined in the
<a href=https://smtlib.cs.uiowa.edu/Theories/ArraysEx.smt2>SMT ArrayEx theory</a> of
the SMT-LIB standard 2.6.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>array</code></td><td></td></tr><tr><td style=text-align:center><code>index</code></td><td>any SMT value type</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SMT value type</td></tr></tbody></table><h3 id=smtarraystore-circtsmtarraystoreop><code>smt.array.store</code> (circt::smt::ArrayStoreOp)&nbsp;<a class=headline-hash href=#smtarraystore-circtsmtarraystoreop>¶</a></h3><p><em>Stores a value at a given index and returns the new array</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.array.store` $array `[` $index `]` `,` $value attr-dict `:` qualified(type($array))
</code></pre><p>This operation returns a new array which is the same as the &lsquo;array&rsquo; operand
except that the value at the given &lsquo;index&rsquo; is changed to the given &lsquo;value&rsquo;.
The semantics are equivalent to the &lsquo;store&rsquo; operator described in the
<a href=https://smtlib.cs.uiowa.edu/Theories/ArraysEx.smt2>SMT ArrayEx theory</a> of
the SMT-LIB standard 2.6.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>array</code></td><td></td></tr><tr><td style=text-align:center><code>index</code></td><td>any SMT value type</td></tr><tr><td style=text-align:center><code>value</code></td><td>any SMT value type</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtassert-circtsmtassertop><code>smt.assert</code> (circt::smt::AssertOp)&nbsp;<a class=headline-hash href=#smtassert-circtsmtassertop>¶</a></h3><p><em>Assert that a boolean expression holds</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.assert` $input attr-dict
</code></pre><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h3 id=smtbvashr-circtsmtbvashrop><code>smt.bv.ashr</code> (circt::smt::BVAShrOp)&nbsp;<a class=headline-hash href=#smtbvashr-circtsmtbvashrop>¶</a></h3><p><em>Equivalent to bvashr in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.ashr` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs arithmetic shift right. The semantics are
equivalent to the <code>bvashr</code> operator defined in the SMT-LIB 2.6
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvadd-circtsmtbvaddop><code>smt.bv.add</code> (circt::smt::BVAddOp)&nbsp;<a class=headline-hash href=#smtbvadd-circtsmtbvaddop>¶</a></h3><p><em>Equivalent to bvadd in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.add` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs addition. The semantics are
equivalent to the <code>bvadd</code> operator defined in the SMT-LIB 2.6
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvand-circtsmtbvandop><code>smt.bv.and</code> (circt::smt::BVAndOp)&nbsp;<a class=headline-hash href=#smtbvand-circtsmtbvandop>¶</a></h3><p><em>Equivalent to bvand in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.and` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs bitwise AND. The semantics are
equivalent to the <code>bvand</code> operator defined in the SMT-LIB 2.6
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvcmp-circtsmtbvcmpop><code>smt.bv.cmp</code> (circt::smt::BVCmpOp)&nbsp;<a class=headline-hash href=#smtbvcmp-circtsmtbvcmpop>¶</a></h3><p><em>Compare bit-vectors interpreted as signed or unsigned</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.cmp` $pred $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
</code></pre><p>This operation compares bit-vector values, interpreting them as signed or
unsigned values depending on the predicate. The semantics are equivalent to
the <code>bvslt</code>, <code>bvsle</code>, <code>bvsgt</code>, <code>bvsge</code>, <code>bvult</code>, <code>bvule</code>, <code>bvugt</code>, or
<code>bvuge</code> operator defined in the SMT-LIB 2.6 standard depending on the
specified predicate. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pred</code></td><td>circt::smt::BVCmpPredicateAttr</td><td>smt bit-vector comparison predicate</td></tr></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvconstant-circtsmtbvconstantop><code>smt.bv.constant</code> (circt::smt::BVConstantOp)&nbsp;<a class=headline-hash href=#smtbvconstant-circtsmtbvconstantop>¶</a></h3><p><em>Produce a constant bit-vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.constant` qualified($value) attr-dict
</code></pre><p>This operation produces an SSA value equal to the bit-vector constant
specified by the &lsquo;value&rsquo; attribute.
Refer to the <code>BitVectorAttr</code> documentation for more information about
the semantics of bit-vector constants, their format, and associated sort.
The result type always matches the attribute&rsquo;s type.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%c92_bv8</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span><span class=kt>constant</span> <span class=nv>#smt.bv</span><span class=p>&lt;</span><span class=m>92</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>8</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%c5_bv4</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span><span class=kt>constant</span> <span class=nv>#smt.bv</span><span class=p>&lt;</span><span class=m>5</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code>, <code>FirstAttrDerivedResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>circt::smt::BitVectorAttr</td><td></td></tr></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvlshr-circtsmtbvlshrop><code>smt.bv.lshr</code> (circt::smt::BVLShrOp)&nbsp;<a class=headline-hash href=#smtbvlshr-circtsmtbvlshrop>¶</a></h3><p><em>Equivalent to bvlshr in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.lshr` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs logical shift right. The semantics are
equivalent to the <code>bvlshr</code> operator defined in the SMT-LIB 2.6
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvmul-circtsmtbvmulop><code>smt.bv.mul</code> (circt::smt::BVMulOp)&nbsp;<a class=headline-hash href=#smtbvmul-circtsmtbvmulop>¶</a></h3><p><em>Equivalent to bvmul in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.mul` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs multiplication. The semantics are
equivalent to the <code>bvmul</code> operator defined in the SMT-LIB 2.6
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvneg-circtsmtbvnegop><code>smt.bv.neg</code> (circt::smt::BVNegOp)&nbsp;<a class=headline-hash href=#smtbvneg-circtsmtbvnegop>¶</a></h3><p><em>Equivalent to bvneg in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.neg` $input attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs two&rsquo;s complement unary minus. The semantics are
equivalent to the <code>bvneg</code> operator defined in the SMT-LIB 2.6
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvnot-circtsmtbvnotop><code>smt.bv.not</code> (circt::smt::BVNotOp)&nbsp;<a class=headline-hash href=#smtbvnot-circtsmtbvnotop>¶</a></h3><p><em>Equivalent to bvnot in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.not` $input attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs bitwise negation. The semantics are
equivalent to the <code>bvnot</code> operator defined in the SMT-LIB 2.6
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvor-circtsmtbvorop><code>smt.bv.or</code> (circt::smt::BVOrOp)&nbsp;<a class=headline-hash href=#smtbvor-circtsmtbvorop>¶</a></h3><p><em>Equivalent to bvor in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.or` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs bitwise OR. The semantics are
equivalent to the <code>bvor</code> operator defined in the SMT-LIB 2.6
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvsdiv-circtsmtbvsdivop><code>smt.bv.sdiv</code> (circt::smt::BVSDivOp)&nbsp;<a class=headline-hash href=#smtbvsdiv-circtsmtbvsdivop>¶</a></h3><p><em>Equivalent to bvsdiv in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.sdiv` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs two&rsquo;s complement signed division. The semantics are
equivalent to the <code>bvsdiv</code> operator defined in the SMT-LIB 2.6
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvsmod-circtsmtbvsmodop><code>smt.bv.smod</code> (circt::smt::BVSModOp)&nbsp;<a class=headline-hash href=#smtbvsmod-circtsmtbvsmodop>¶</a></h3><p><em>Equivalent to bvsmod in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.smod` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs two&rsquo;s complement signed remainder (sign follows divisor). The semantics are
equivalent to the <code>bvsmod</code> operator defined in the SMT-LIB 2.6
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvsrem-circtsmtbvsremop><code>smt.bv.srem</code> (circt::smt::BVSRemOp)&nbsp;<a class=headline-hash href=#smtbvsrem-circtsmtbvsremop>¶</a></h3><p><em>Equivalent to bvsrem in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.srem` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs two&rsquo;s complement signed remainder (sign follows dividend). The semantics are
equivalent to the <code>bvsrem</code> operator defined in the SMT-LIB 2.6
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvshl-circtsmtbvshlop><code>smt.bv.shl</code> (circt::smt::BVShlOp)&nbsp;<a class=headline-hash href=#smtbvshl-circtsmtbvshlop>¶</a></h3><p><em>Equivalent to bvshl in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.shl` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs shift left. The semantics are
equivalent to the <code>bvshl</code> operator defined in the SMT-LIB 2.6
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvudiv-circtsmtbvudivop><code>smt.bv.udiv</code> (circt::smt::BVUDivOp)&nbsp;<a class=headline-hash href=#smtbvudiv-circtsmtbvudivop>¶</a></h3><p><em>Equivalent to bvudiv in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.udiv` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs unsigned division (rounded towards zero). The semantics are
equivalent to the <code>bvudiv</code> operator defined in the SMT-LIB 2.6
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvurem-circtsmtbvuremop><code>smt.bv.urem</code> (circt::smt::BVURemOp)&nbsp;<a class=headline-hash href=#smtbvurem-circtsmtbvuremop>¶</a></h3><p><em>Equivalent to bvurem in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.urem` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs unsigned remainder. The semantics are
equivalent to the <code>bvurem</code> operator defined in the SMT-LIB 2.6
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvxor-circtsmtbvxorop><code>smt.bv.xor</code> (circt::smt::BVXOrOp)&nbsp;<a class=headline-hash href=#smtbvxor-circtsmtbvxorop>¶</a></h3><p><em>Equivalent to bvxor in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.xor` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs bitwise exclusive OR. The semantics are
equivalent to the <code>bvxor</code> operator defined in the SMT-LIB 2.6
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtconstant-circtsmtboolconstantop><code>smt.constant</code> (circt::smt::BoolConstantOp)&nbsp;<a class=headline-hash href=#smtconstant-circtsmtboolconstantop>¶</a></h3><p><em>Produce a constant boolean</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.constant` $value attr-dict
</code></pre><p>Produces the constant expressions &rsquo;true&rsquo; and &lsquo;false&rsquo; as described in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a> of the SMT-LIB
Standard 2.6.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtcheck-circtsmtcheckop><code>smt.check</code> (circt::smt::CheckOp)&nbsp;<a class=headline-hash href=#smtcheck-circtsmtcheckop>¶</a></h3><p><em>Check if the current set of assertions is satisfiable</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.check` attr-dict `sat` $satRegion `unknown` $unknownRegion `unsat` $unsatRegion
              (`-&gt;` qualified(type($results))^ )?
</code></pre><p>This operation checks if all the assertions in the solver defined by the
nearest ancestor operation of type <code>smt.solver</code> are consistent. The outcome
an be &lsquo;satisfiable&rsquo;, &lsquo;unknown&rsquo;, or &lsquo;unsatisfiable&rsquo; and the corresponding
region will be executed. It is the corresponding construct to the
<code>check-sat</code> in SMT-LIB.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> smt<span class=p>.</span>check sat <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c1_i32</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  smt<span class=p>.</span>yield <span class=nv>%c1_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span> unknown <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c0_i32</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  smt<span class=p>.</span>yield <span class=nv>%c0_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span> unsat <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c</span><span class=m>-1</span><span class=nl>_i32 =</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>-1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  smt<span class=p>.</span>yield <span class=nv>%c</span><span class=m>-1</span>_i32 <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>NoRegionArguments</code>, <code>SingleBlockImplicitTerminator&lt;smt::YieldOp></code>, <code>SingleBlock</code></p><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=smtbvconcat-circtsmtconcatop><code>smt.bv.concat</code> (circt::smt::ConcatOp)&nbsp;<a class=headline-hash href=#smtbvconcat-circtsmtconcatop>¶</a></h3><p><em>Bit-vector concatenation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.concat` $lhs `,` $rhs attr-dict `:` qualified(type(operands))
</code></pre><p>This operation concatenates bit-vector values with semantics equivalent to
the <code>concat</code> operator defined in the SMT-LIB 2.6 standard. More precisely in
the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Note that the following equivalences hold:</p><ul><li><code>smt.bv.concat %a, %b : !smt.bv&lt;4>, !smt.bv&lt;4></code> is equivalent to
<code>(concat a b)</code> in SMT-LIB</li><li><code>(= (concat #xf #x0) #xf0)</code></li></ul><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtdeclare_fun-circtsmtdeclarefunop><code>smt.declare_fun</code> (circt::smt::DeclareFunOp)&nbsp;<a class=headline-hash href=#smtdeclare_fun-circtsmtdeclarefunop>¶</a></h3><p><em>Declare a symbolic value of a given sort</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.declare_fun` ($namePrefix^)? attr-dict `:` qualified(type($result))
</code></pre><p>This operation declares a symbolic value just as the <code>declare-const</code> and
<code>declare-func</code> statements in SMT-LIB 2.6. The result type determines the SMT
sort of the symbolic value. The returned value can then be used to refer to
the symbolic value instead of using the identifier like in SMT-LIB.</p><p>The optionally provided string will be used as a prefix for the newly
generated identifier (useful for easier readability when exporting to
SMT-LIB). Each <code>declare</code> will always provide a unique new symbolic value
even if the identifier strings are the same.</p><p>Note that there does not exist a separate operation equivalent to
SMT-LIBs <code>define-fun</code> since</p><pre tabindex=0><code>(define-fun f (a Int) Int (-a))
</code></pre><p>is only syntactic sugar for</p><pre tabindex=0><code>%f = smt.declare_fun : !smt.func&lt;(!smt.int) !smt.int&gt;
%0 = smt.forall {
^bb0(%arg0: !smt.int):
  %1 = smt.apply_func %f(%arg0) : !smt.func&lt;(!smt.int) !smt.int&gt;
  %2 = smt.int.neg %arg0
  %3 = smt.eq %1, %2 : !smt.int
  smt.yield %3 : !smt.bool
}
smt.assert %0
</code></pre><p>Note that this operation cannot be marked as Pure since two operations (even
with the same identifier string) could then be CSEd, leading to incorrect
behavior.</p><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>namePrefix</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SMT value type</td></tr></tbody></table><h3 id=smtdistinct-circtsmtdistinctop><code>smt.distinct</code> (circt::smt::DistinctOp)&nbsp;<a class=headline-hash href=#smtdistinct-circtsmtdistinctop>¶</a></h3><p><em>Returns true iff all operands are not identical to any other</em></p><p>This operation compares the operands and returns true iff all operands are
not identical to any of the other operands. The semantics are equivalent to
the <code>distinct</code> operator defined in the SMT-LIB Standard 2.6 in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a>.</p><p>Any SMT sort/type is allowed for the operands and it supports a variadic
number of operands, but requires at least two. This is because the
<code>distinct</code> operator is annotated with <code>:pairwise</code> which means that
<code>distinct a b c d</code> is equivalent to</p><pre tabindex=0><code>and (distinct a b) (distinct a c) (distinct a d)
    (distinct b c) (distinct b d)
    (distinct c d)
</code></pre><p>where <code>and</code> is annotated <code>:left-assoc</code>, i.e., it can be further rewritten to</p><pre tabindex=0><code>(and (and (and (and (and (distinct a b)
                         (distinct a c))
                    (distinct a d))
               (distinct b c))
          (distinct b d))
     (distinct c d)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any SMT value type</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smteq-circtsmteqop><code>smt.eq</code> (circt::smt::EqOp)&nbsp;<a class=headline-hash href=#smteq-circtsmteqop>¶</a></h3><p><em>Returns true iff all operands are identical</em></p><p>This operation compares the operands and returns true iff all operands are
identical. The semantics are equivalent to the <code>=</code> operator defined in the
SMT-LIB Standard 2.6 in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a>.</p><p>Any SMT sort/type is allowed for the operands and it supports a variadic
number of operands, but requires at least two. This is because the <code>=</code>
operator is annotated with <code>:chainable</code> which means that <code>= a b c d</code> is
equivalent to <code>and (= a b) (= b c) (= c d)</code> where <code>and</code> is annotated
<code>:left-assoc</code>, i.e., it can be further rewritten to
<code>and (and (= a b) (= b c)) (= c d)</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any SMT value type</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtexists-circtsmtexistsop><code>smt.exists</code> (circt::smt::ExistsOp)&nbsp;<a class=headline-hash href=#smtexists-circtsmtexistsop>¶</a></h3><p><em>Exists quantifier</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.exists` ($boundVarNames^)? (`no_pattern` $noPattern^)? (`weight` $weight^)?
              attr-dict-with-keyword $body (`patterns` $patterns^)?
</code></pre><p>This operation represents the exists quantifier as described in the
<a href=https://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2021-05-12.pdf>SMT-LIB 2.6 standard</a>.
It is part of the language itself rather than a theory or logic.</p><p>The operation specifies the name prefixes (as an optional attribute) and
types (as the types of the block arguments of the regions) of bound
variables that may be used in the &lsquo;body&rsquo; of the operation. If a &lsquo;patterns&rsquo;
region is specified, the block arguments must match the ones of the &lsquo;body&rsquo;
region and (other than there) must be used at least once in the &lsquo;patterns&rsquo;
region. It may also not contain any operations that bind variables, such as
quantifiers. While the &lsquo;body&rsquo; region must always yield exactly one
<code>!smt.bool</code>-typed value, the &lsquo;patterns&rsquo; region can yield an arbitrary number
(but at least one) of SMT values.</p><p>The bound variables can be any SMT type except of functions, since SMT only
supports first-order logic.</p><p>The &rsquo;no_patterns&rsquo; attribute is only allowed when no &lsquo;patterns&rsquo; region is
specified and forbids the solver to generate and use patterns for this
quantifier.</p><p>The &lsquo;weight&rsquo; attribute indicates the importance of this quantifier being
instantiated compared to other quantifiers that may be present. The default
value is zero.</p><p>Both the &rsquo;no_patterns&rsquo; and &lsquo;weight&rsquo; attributes are annotations to the
quantifiers body term. Annotations and attributes are described in the
standard in sections 3.4, and 3.6 (specifically 3.6.5). SMT-LIB allows
adding custom attributes to provide solvers with additional metadata, e.g.,
hints such as above mentioned attributes. They are not part of the standard
themselves, but supported by common SMT solvers (e.g., Z3).</p><p>Traits: <code>RecursiveMemoryEffects</code>, <code>RecursivelySpeculatableImplTrait</code>, <code>SingleBlockImplicitTerminator&lt;smt::YieldOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>weight</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>noPattern</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>boundVarNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvextract-circtsmtextractop><code>smt.bv.extract</code> (circt::smt::ExtractOp)&nbsp;<a class=headline-hash href=#smtbvextract-circtsmtextractop>¶</a></h3><p><em>Bit-vector extraction</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
</code></pre><p>This operation extracts the range of bits starting at the &rsquo;lowBit&rsquo; index
(inclusive) up to the &rsquo;lowBit&rsquo; + result-width index (exclusive). The
semantics are equivalent to the <code>extract</code> operator defined in the SMT-LIB
2.6 standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Note that <code>smt.bv.extract %bv from 2 : (!smt.bv&lt;32>) -> !smt.bv&lt;16></code> is
equivalent to <code>((_ extract 17 2) bv)</code>, i.e., the SMT-LIB operator takes the
low and high indices where both are inclusive. The following equivalence
holds: <code>(= ((_ extract 3 0) #x0f) #xf)</code></p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lowBit</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtforall-circtsmtforallop><code>smt.forall</code> (circt::smt::ForallOp)&nbsp;<a class=headline-hash href=#smtforall-circtsmtforallop>¶</a></h3><p><em>Forall quantifier</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.forall` ($boundVarNames^)? (`no_pattern` $noPattern^)? (`weight` $weight^)?
              attr-dict-with-keyword $body (`patterns` $patterns^)?
</code></pre><p>This operation represents the forall quantifier as described in the
<a href=https://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2021-05-12.pdf>SMT-LIB 2.6 standard</a>.
It is part of the language itself rather than a theory or logic.</p><p>The operation specifies the name prefixes (as an optional attribute) and
types (as the types of the block arguments of the regions) of bound
variables that may be used in the &lsquo;body&rsquo; of the operation. If a &lsquo;patterns&rsquo;
region is specified, the block arguments must match the ones of the &lsquo;body&rsquo;
region and (other than there) must be used at least once in the &lsquo;patterns&rsquo;
region. It may also not contain any operations that bind variables, such as
quantifiers. While the &lsquo;body&rsquo; region must always yield exactly one
<code>!smt.bool</code>-typed value, the &lsquo;patterns&rsquo; region can yield an arbitrary number
(but at least one) of SMT values.</p><p>The bound variables can be any SMT type except of functions, since SMT only
supports first-order logic.</p><p>The &rsquo;no_patterns&rsquo; attribute is only allowed when no &lsquo;patterns&rsquo; region is
specified and forbids the solver to generate and use patterns for this
quantifier.</p><p>The &lsquo;weight&rsquo; attribute indicates the importance of this quantifier being
instantiated compared to other quantifiers that may be present. The default
value is zero.</p><p>Both the &rsquo;no_patterns&rsquo; and &lsquo;weight&rsquo; attributes are annotations to the
quantifiers body term. Annotations and attributes are described in the
standard in sections 3.4, and 3.6 (specifically 3.6.5). SMT-LIB allows
adding custom attributes to provide solvers with additional metadata, e.g.,
hints such as above mentioned attributes. They are not part of the standard
themselves, but supported by common SMT solvers (e.g., Z3).</p><p>Traits: <code>RecursiveMemoryEffects</code>, <code>RecursivelySpeculatableImplTrait</code>, <code>SingleBlockImplicitTerminator&lt;smt::YieldOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>weight</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>noPattern</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>boundVarNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtimplies-circtsmtimpliesop><code>smt.implies</code> (circt::smt::ImpliesOp)&nbsp;<a class=headline-hash href=#smtimplies-circtsmtimpliesop>¶</a></h3><p><em>Boolean implication</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.implies` $lhs `,` $rhs attr-dict
</code></pre><p>This operation performs a boolean implication. The semantics are equivalent
to the &lsquo;=>&rsquo; operator in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a> of the SMT-LIB
Standard 2.6.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintabs-circtsmtintabsop><code>smt.int.abs</code> (circt::smt::IntAbsOp)&nbsp;<a class=headline-hash href=#smtintabs-circtsmtintabsop>¶</a></h3><p><em>The absolute value of an Int</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.int.abs` $input attr-dict
</code></pre><p>This operation represents the absolute value function for the <code>Int</code> sort.
The semantics are equivalent to the <code>abs</code> operator as described in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.6 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintadd-circtsmtintaddop><code>smt.int.add</code> (circt::smt::IntAddOp)&nbsp;<a class=headline-hash href=#smtintadd-circtsmtintaddop>¶</a></h3><p><em>Integer addition</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.int.add` $inputs attr-dict
</code></pre><p>This operation represents (infinite-precision) integer addition.
The semantics are equivalent to the corresponding operator described in
the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.6 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintcmp-circtsmtintcmpop><code>smt.int.cmp</code> (circt::smt::IntCmpOp)&nbsp;<a class=headline-hash href=#smtintcmp-circtsmtintcmpop>¶</a></h3><p><em>Integer comparison</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.int.cmp` $pred $lhs `,` $rhs attr-dict
</code></pre><p>This operation represents the comparison of (infinite-precision) integers.
The semantics are equivalent to the <code>&lt;= (le)</code>, <code>&lt; (lt)</code>, <code>>= (ge)</code>, or
<code>> (gt)</code> operator depending on the predicate (indicated in parentheses) as
described in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.6 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pred</code></td><td>circt::smt::IntPredicateAttr</td><td>smt comparison predicate for integers</td></tr></table><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintconstant-circtsmtintconstantop><code>smt.int.constant</code> (circt::smt::IntConstantOp)&nbsp;<a class=headline-hash href=#smtintconstant-circtsmtintconstantop>¶</a></h3><p><em>Produce a constant (infinite-precision) integer</em></p><p>This operation represents (infinite-precision) integer literals of the <code>Int</code>
sort. The set of values for the sort <code>Int</code> consists of all numerals and
all terms of the form <code>-n</code>where n is a numeral other than 0. For more
information refer to the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.6 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintdiv-circtsmtintdivop><code>smt.int.div</code> (circt::smt::IntDivOp)&nbsp;<a class=headline-hash href=#smtintdiv-circtsmtintdivop>¶</a></h3><p><em>Integer division</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.int.div` $lhs `,` $rhs attr-dict
</code></pre><p>This operation represents (infinite-precision) integer division.
The semantics are equivalent to the corresponding operator described in
the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.6 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintmod-circtsmtintmodop><code>smt.int.mod</code> (circt::smt::IntModOp)&nbsp;<a class=headline-hash href=#smtintmod-circtsmtintmodop>¶</a></h3><p><em>Integer remainder</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.int.mod` $lhs `,` $rhs attr-dict
</code></pre><p>This operation represents (infinite-precision) integer remainder.
The semantics are equivalent to the corresponding operator described in
the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.6 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintmul-circtsmtintmulop><code>smt.int.mul</code> (circt::smt::IntMulOp)&nbsp;<a class=headline-hash href=#smtintmul-circtsmtintmulop>¶</a></h3><p><em>Integer multiplication</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.int.mul` $inputs attr-dict
</code></pre><p>This operation represents (infinite-precision) integer multiplication.
The semantics are equivalent to the corresponding operator described in
the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.6 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of</td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintsub-circtsmtintsubop><code>smt.int.sub</code> (circt::smt::IntSubOp)&nbsp;<a class=headline-hash href=#smtintsub-circtsmtintsubop>¶</a></h3><p><em>Integer subtraction</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.int.sub` $lhs `,` $rhs attr-dict
</code></pre><p>This operation represents (infinite-precision) integer subtraction.
The semantics are equivalent to the corresponding operator described in
the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.6 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtite-circtsmtiteop><code>smt.ite</code> (circt::smt::IteOp)&nbsp;<a class=headline-hash href=#smtite-circtsmtiteop>¶</a></h3><p><em>An if-then-else function</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.ite` $cond `,` $thenValue `,` $elseValue attr-dict `:` qualified(type($result))
</code></pre><p>This operation returns its second operand or its third operand depending on
whether its first operand is true or not. The semantics are equivalent to
the <code>ite</code> operator defined in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a> of the SMT-LIB
2.6 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td></td></tr><tr><td style=text-align:center><code>thenValue</code></td><td>any SMT value type</td></tr><tr><td style=text-align:center><code>elseValue</code></td><td>any SMT value type</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SMT value type</td></tr></tbody></table><h3 id=smtnot-circtsmtnotop><code>smt.not</code> (circt::smt::NotOp)&nbsp;<a class=headline-hash href=#smtnot-circtsmtnotop>¶</a></h3><p><em>A boolean negation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.not` $input attr-dict
</code></pre><p>This operation performs a boolean negation. The semantics are equivalent to
the &rsquo;not&rsquo; operator in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a> of the SMT-LIB
Standard 2.6.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtor-circtsmtorop><code>smt.or</code> (circt::smt::OrOp)&nbsp;<a class=headline-hash href=#smtor-circtsmtorop>¶</a></h3><p><em>A boolean disjunction</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.or` $inputs attr-dict
</code></pre><p>This operation performs a boolean disjunction.
The semantics are equivalent to the &lsquo;or&rsquo; operator in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a>.
of the SMT-LIB Standard 2.6.</p><pre><code>It supports a variadic number of operands, but requires at least two.
This is because the operator is annotated with the `:left-assoc` attribute
which means that `op a b c` is equivalent to `(op (op a b) c)`.
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of</td></tr></tbody></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvrepeat-circtsmtrepeatop><code>smt.bv.repeat</code> (circt::smt::RepeatOp)&nbsp;<a class=headline-hash href=#smtbvrepeat-circtsmtrepeatop>¶</a></h3><p><em>Repeated bit-vector concatenation of one value</em></p><p>This operation is a shorthand for repeated concatenation of the same
bit-vector value, i.e.,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>smt<span class=p>.</span>bv<span class=p>.</span>repeat <span class=m>5</span> times <span class=nv>%a</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// is the same as
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span>repeat <span class=m>4</span> times <span class=nv>%a</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>smt<span class=p>.</span>bv<span class=p>.</span>concat <span class=nv>%a</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;,</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>16</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// or also 
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span>repeat <span class=m>4</span> times <span class=nv>%a</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>smt<span class=p>.</span>bv<span class=p>.</span>concat <span class=nv>%0</span><span class=p>,</span> <span class=nv>%a</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>16</span><span class=p>&gt;,</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>The semantics are equivalent to the <code>repeat</code> operator defined in the SMT-LIB
2.6 standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtsolver-circtsmtsolverop><code>smt.solver</code> (circt::smt::SolverOp)&nbsp;<a class=headline-hash href=#smtsolver-circtsmtsolverop>¶</a></h3><p><em>Create a solver instance within a lifespan</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.solver` `(` $inputs `)` attr-dict `:` functional-type($inputs, $results) $bodyRegion
</code></pre><p>This operation defines an SMT context with a solver instance. SMT operations
are only valid when being executed between the start and end of the region
of this operation. Any invocation outside is undefined. However, they do not
have to be direct children of this operation. For example, it is allowed to
have SMT operations in a <code>func.func</code> which is only called from within this
region. No SMT value may enter or exit the lifespan of this region (such
that no value created from another SMT context can be used in this scope and
the solver can deallocate all state required to keep track of SMT values at
the end).</p><p>As a result, the region is comparable to an entire SMT-LIB script, but
allows for concrete operations and control-flow. Concrete values may be
passed in and returned to influence the computations after the <code>smt.solver</code>
operation.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span><span class=p>:</span><span class=nl>2 =</span> smt<span class=p>.</span>solver <span class=p>(</span><span class=nv>%in</span><span class=p>)</span> <span class=p>{</span>smt<span class=p>.</span>some_attr<span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=k>i8</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i8</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c</span> <span class=p>=</span> smt<span class=p>.</span>declare_fun <span class=s>&#34;c&#34;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bool
</span></span><span class=line><span class=cl>  smt<span class=p>.</span>assert <span class=nv>%c</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> smt<span class=p>.</span>check sat <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%c1_i32</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    smt<span class=p>.</span>yield <span class=nv>%c1_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> unknown <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%c0_i32</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    smt<span class=p>.</span>yield <span class=nv>%c0_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> unsat <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%c</span><span class=m>-1</span><span class=nl>_i32 =</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>-1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    smt<span class=p>.</span>yield <span class=nv>%c</span><span class=m>-1</span>_i32 <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  smt<span class=p>.</span>yield <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>TODO: solver configuration attributes</p><p>Traits: <code>IsolatedFromAbove</code>, <code>SingleBlockImplicitTerminator&lt;smt::YieldOp></code>, <code>SingleBlock</code></p><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any non-smt type</td></tr></tbody></table><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any non-smt type</td></tr></tbody></table><h3 id=smtxor-circtsmtxorop><code>smt.xor</code> (circt::smt::XOrOp)&nbsp;<a class=headline-hash href=#smtxor-circtsmtxorop>¶</a></h3><p><em>A boolean exclusive OR</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.xor` $inputs attr-dict
</code></pre><p>This operation performs a boolean exclusive OR.
The semantics are equivalent to the &lsquo;xor&rsquo; operator in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a>.
of the SMT-LIB Standard 2.6.</p><pre><code>It supports a variadic number of operands, but requires at least two.
This is because the operator is annotated with the `:left-assoc` attribute
which means that `op a b c` is equivalent to `(op (op a b) c)`.
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of</td></tr></tbody></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtyield-circtsmtyieldop><code>smt.yield</code> (circt::smt::YieldOp)&nbsp;<a class=headline-hash href=#smtyield-circtsmtyieldop>¶</a></h3><p><em>Terminator operation for various regions of SMT operations</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.yield` ($values^ `:` qualified(type($values)))? attr-dict
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;smt::SolverOp, smt::CheckOp, smt::ForallOp, smt::ExistsOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values</code></td><td>variadic of any type</td></tr></tbody></table><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><h3 id=arraytype>ArrayType&nbsp;<a class=headline-hash href=#arraytype>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>!smt.array&lt;
  mlir::Type,   # domainType
  mlir::Type   # rangeType
&gt;
</code></pre><p>This type represents the <code>(Array X Y)</code> sort, where X and Y are any
sort/type, as described in the
<a href=https://smtlib.cs.uiowa.edu/Theories/ArraysEx.smt2>SMT ArrayEx theory</a> of
the SMT-LIB standard 2.6.</p><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>domainType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>rangeType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr></tbody></table><h3 id=bitvectortype>BitVectorType&nbsp;<a class=headline-hash href=#bitvectortype>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>!smt.bv&lt;
  uint64_t   # width
&gt;
</code></pre><p>This type represents the <code>(_ BitVec width)</code> sort as described in the
<a href=https://smtlib.cs.uiowa.edu/theories-FixedSizeBitVectors.shtml>SMT bit-vector
theory</a>.</p><p>The bit-width must be strictly greater than zero.</p><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>width</td><td style=text-align:center><code>uint64_t</code></td><td></td></tr></tbody></table><h3 id=booltype>BoolType&nbsp;<a class=headline-hash href=#booltype>¶</a></h3><p>Syntax: <code>!smt.bool</code></p><h3 id=inttype>IntType&nbsp;<a class=headline-hash href=#inttype>¶</a></h3><p>Syntax: <code>!smt.int</code></p><p>This type represents the <code>Int</code> sort as described in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.6 standard.</p><h3 id=smtfunctype>SMTFuncType&nbsp;<a class=headline-hash href=#smtfunctype>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>!smt.func&lt;
  ::llvm::ArrayRef&lt;mlir::Type&gt;,   # domainTypes
  mlir::Type   # rangeType
&gt;
</code></pre><p>This type represents the SMT function sort as described in the
<a href=https://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2021-05-12.pdf>SMT-LIB 2.6 standard</a>.
It is part of the language itself rather than a theory or logic.</p><p>A function in SMT can have an arbitrary domain size, but always has exactly
one range sort.</p><p>Since SMT only supports first-order logic, it is not possible to nest
function types.</p><p>Example: <code>!smt.func&lt;(!smt.bool, !smt.int) !smt.bool></code> is equivalent to
<code>((Bool Int) Bool)</code> in SMT-LIB.</p><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>domainTypes</td><td style=text-align:center><code>::llvm::ArrayRef&lt;mlir::Type></code></td><td>domain types</td></tr><tr><td style=text-align:center>rangeType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr></tbody></table><h3 id=sorttype>SortType&nbsp;<a class=headline-hash href=#sorttype>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>!smt.sort&lt;
  mlir::StringAttr,   # identifier
  ::llvm::ArrayRef&lt;mlir::Type&gt;   # sortParams
&gt;
</code></pre><p>This type represents uninterpreted sorts. The usage of a type like
<code>!smt.sort&lt;"sort_name"[!smt.bool, !smt.sort&lt;"other_sort">]></code> implies a
<code>declare-sort sort_name 2</code> and a <code>declare-sort other_sort 0</code> in SMT-LIB.
This type represents concrete use-sites of such declared sorts, in this
particular case it would be equivalent to <code>(sort_name Bool other_sort)</code> in
SMT-LIB. More details about the semantics can be found in the
<a href=https://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2021-05-12.pdf>SMT-LIB 2.6 standard</a>.</p><h4 id=parameters-3>Parameters:&nbsp;<a class=headline-hash href=#parameters-3>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>identifier</td><td style=text-align:center><code>mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>sortParams</td><td style=text-align:center><code>::llvm::ArrayRef&lt;mlir::Type></code></td><td>sort parameters</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/ title="Interoperability Dialect Rationale"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Interoperability Dialect Rationale</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/ToolsWorkarounds/ title="EDA Tool Workarounds">Next - EDA Tool Workarounds <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li class=active><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>