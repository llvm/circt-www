<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'sv' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/SV/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'sv' Dialect</h1><p>Types and operations for SV dialect
This dialect defines the <code>sv</code> dialect, which represents various
SystemVerilog-specific constructs in an AST-like representation.</p><p><nav id=TableOfContents><ul><li><a href=#operation-definition>Operation definition</a><ul><li><a href=#svalias-circtsvaliasop><code>sv.alias</code> (::circt::sv::AliasOp)</a></li><li><a href=#svalwayscomb-circtsvalwayscombop><code>sv.alwayscomb</code> (::circt::sv::AlwaysCombOp)</a></li><li><a href=#svalwaysff-circtsvalwaysffop><code>sv.alwaysff</code> (::circt::sv::AlwaysFFOp)</a></li><li><a href=#svalways-circtsvalwaysop><code>sv.always</code> (::circt::sv::AlwaysOp)</a></li><li><a href=#svarray_index_inout-circtsvarrayindexinoutop><code>sv.array_index_inout</code> (::circt::sv::ArrayIndexInOutOp)</a></li><li><a href=#svassertconcurrent-circtsvassertconcurrentop><code>sv.assert.concurrent</code> (::circt::sv::AssertConcurrentOp)</a></li><li><a href=#svassert-circtsvassertop><code>sv.assert</code> (::circt::sv::AssertOp)</a></li><li><a href=#svinterfacesignalassign-circtsvassigninterfacesignalop><code>sv.interface.signal.assign</code> (::circt::sv::AssignInterfaceSignalOp)</a></li><li><a href=#svassign-circtsvassignop><code>sv.assign</code> (::circt::sv::AssignOp)</a></li><li><a href=#svassumeconcurrent-circtsvassumeconcurrentop><code>sv.assume.concurrent</code> (::circt::sv::AssumeConcurrentOp)</a></li><li><a href=#svassume-circtsvassumeop><code>sv.assume</code> (::circt::sv::AssumeOp)</a></li><li><a href=#svbpassign-circtsvbpassignop><code>sv.bpassign</code> (::circt::sv::BPAssignOp)</a></li><li><a href=#svbindinterface-circtsvbindinterfaceop><code>sv.bind.interface</code> (::circt::sv::BindInterfaceOp)</a></li><li><a href=#svbind-circtsvbindop><code>sv.bind</code> (::circt::sv::BindOp)</a></li><li><a href=#svcase-circtsvcaseop><code>sv.case</code> (::circt::sv::CaseOp)</a></li><li><a href=#svconstantx-circtsvconstantxop><code>sv.constantX</code> (::circt::sv::ConstantXOp)</a></li><li><a href=#svconstantz-circtsvconstantzop><code>sv.constantZ</code> (::circt::sv::ConstantZOp)</a></li><li><a href=#svcoverconcurrent-circtsvcoverconcurrentop><code>sv.cover.concurrent</code> (::circt::sv::CoverConcurrentOp)</a></li><li><a href=#svcover-circtsvcoverop><code>sv.cover</code> (::circt::sv::CoverOp)</a></li><li><a href=#svnonstandarddeposit-circtsvdepositop><code>sv.nonstandard.deposit</code> (::circt::sv::DepositOp)</a></li><li><a href=#sverror-circtsverrorop><code>sv.error</code> (::circt::sv::ErrorOp)</a></li><li><a href=#svexit-circtsvexitop><code>sv.exit</code> (::circt::sv::ExitOp)</a></li><li><a href=#svfwrite-circtsvfwriteop><code>sv.fwrite</code> (::circt::sv::FWriteOp)</a></li><li><a href=#svfatal-circtsvfatalop><code>sv.fatal</code> (::circt::sv::FatalOp)</a></li><li><a href=#svfinish-circtsvfinishop><code>sv.finish</code> (::circt::sv::FinishOp)</a></li><li><a href=#svforce-circtsvforceop><code>sv.force</code> (::circt::sv::ForceOp)</a></li><li><a href=#svgeneratecase-circtsvgeneratecaseop><code>sv.generate.case</code> (::circt::sv::GenerateCaseOp)</a></li><li><a href=#svgenerate-circtsvgenerateop><code>sv.generate</code> (::circt::sv::GenerateOp)</a></li><li><a href=#svmodportget-circtsvgetmodportop><code>sv.modport.get</code> (::circt::sv::GetModportOp)</a></li><li><a href=#svifdef-circtsvifdefop><code>sv.ifdef</code> (::circt::sv::IfDefOp)</a></li><li><a href=#svifdefprocedural-circtsvifdefproceduralop><code>sv.ifdef.procedural</code> (::circt::sv::IfDefProceduralOp)</a></li><li><a href=#svif-circtsvifop><code>sv.if</code> (::circt::sv::IfOp)</a></li><li><a href=#svindexed_part_select_inout-circtsvindexedpartselectinoutop><code>sv.indexed_part_select_inout</code> (::circt::sv::IndexedPartSelectInOutOp)</a></li><li><a href=#svindexed_part_select-circtsvindexedpartselectop><code>sv.indexed_part_select</code> (::circt::sv::IndexedPartSelectOp)</a></li><li><a href=#svinfo-circtsvinfoop><code>sv.info</code> (::circt::sv::InfoOp)</a></li><li><a href=#svinitial-circtsvinitialop><code>sv.initial</code> (::circt::sv::InitialOp)</a></li><li><a href=#svinterfaceinstance-circtsvinterfaceinstanceop><code>sv.interface.instance</code> (::circt::sv::InterfaceInstanceOp)</a></li><li><a href=#svinterfacemodport-circtsvinterfacemodportop><code>sv.interface.modport</code> (::circt::sv::InterfaceModportOp)</a></li><li><a href=#svinterface-circtsvinterfaceop><code>sv.interface</code> (::circt::sv::InterfaceOp)</a></li><li><a href=#svinterfacesignal-circtsvinterfacesignalop><code>sv.interface.signal</code> (::circt::sv::InterfaceSignalOp)</a></li><li><a href=#svlocalparam-circtsvlocalparamop><code>sv.localparam</code> (::circt::sv::LocalParamOp)</a></li><li><a href=#svlogic-circtsvlogicop><code>sv.logic</code> (::circt::sv::LogicOp)</a></li><li><a href=#svmacroref-circtsvmacrorefexprop><code>sv.macro.ref</code> (::circt::sv::MacroRefExprOp)</a></li><li><a href=#svordered-circtsvorderedoutputop><code>sv.ordered</code> (::circt::sv::OrderedOutputOp)</a></li><li><a href=#svpassign-circtsvpassignop><code>sv.passign</code> (::circt::sv::PAssignOp)</a></li><li><a href=#svread_inout-circtsvreadinoutop><code>sv.read_inout</code> (::circt::sv::ReadInOutOp)</a></li><li><a href=#svinterfacesignalread-circtsvreadinterfacesignalop><code>sv.interface.signal.read</code> (::circt::sv::ReadInterfaceSignalOp)</a></li><li><a href=#svreg-circtsvregop><code>sv.reg</code> (::circt::sv::RegOp)</a></li><li><a href=#svrelease-circtsvreleaseop><code>sv.release</code> (::circt::sv::ReleaseOp)</a></li><li><a href=#svsystemsampled-circtsvsampledop><code>sv.system.sampled</code> (::circt::sv::SampledOp)</a></li><li><a href=#svstop-circtsvstopop><code>sv.stop</code> (::circt::sv::StopOp)</a></li><li><a href=#svstruct_field_inout-circtsvstructfieldinoutop><code>sv.struct_field_inout</code> (::circt::sv::StructFieldInOutOp)</a></li><li><a href=#svverbatimexpr-circtsvverbatimexprop><code>sv.verbatim.expr</code> (::circt::sv::VerbatimExprOp)</a></li><li><a href=#svverbatimexprse-circtsvverbatimexprseop><code>sv.verbatim.expr.se</code> (::circt::sv::VerbatimExprSEOp)</a></li><li><a href=#svverbatim-circtsvverbatimop><code>sv.verbatim</code> (::circt::sv::VerbatimOp)</a></li><li><a href=#svwarning-circtsvwarningop><code>sv.warning</code> (::circt::sv::WarningOp)</a></li><li><a href=#svwire-circtsvwireop><code>sv.wire</code> (::circt::sv::WireOp)</a></li><li><a href=#svxmr-circtsvxmrop><code>sv.xmr</code> (::circt::sv::XMROp)</a></li></ul></li><li><a href=#attribute-definition>Attribute definition</a><ul><li><a href=#macroidentattr>MacroIdentAttr</a></li><li><a href=#modportdirectionattr>ModportDirectionAttr</a></li><li><a href=#modportstructattr>ModportStructAttr</a></li><li><a href=#svattributeattr>SVAttributeAttr</a></li><li><a href=#validationqualifiertypeenumattr>ValidationQualifierTypeEnumAttr</a></li></ul></li><li><a href=#type-definition>Type definition</a><ul><li><a href=#interfacetype>InterfaceType</a></li><li><a href=#modporttype>ModportType</a></li></ul></li></ul></nav><h2 id=operation-definition>Operation definition</h2><h3 id=svalias-circtsvaliasop><code>sv.alias</code> (::circt::sv::AliasOp)</h3><p>SystemVerilog &lsquo;alias&rsquo; statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.alias` $operands attr-dict `:` qualified(type($operands))
</code></pre><p>An alias statement declares multiple names for the same physical net, or
bits within a net. Aliases always have at least two operands.</p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>InOutType</td></tr></tbody></table><h3 id=svalwayscomb-circtsvalwayscombop><code>sv.alwayscomb</code> (::circt::sv::AlwaysCombOp)</h3><p>&lsquo;alwayscomb block</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.alwayscomb` $body attr-dict
</code></pre><p>See SV Spec 9.2, and 9.2.2.2.
Traits: NoRegionArguments, NoTerminator, NonProceduralOp, ProceduralRegion, RecursiveSideEffects, SingleBlock</p><h3 id=svalwaysff-circtsvalwaysffop><code>sv.alwaysff</code> (::circt::sv::AlwaysFFOp)</h3><p>&lsquo;alwaysff @&rsquo; block with optional reset</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.alwaysff` `(` $clockEdge $clock `)` $bodyBlk
              ( `(` $resetStyle `:` $resetEdge^ $reset `)` $resetBlk )? attr-dict
</code></pre><p>alwaysff blocks represent always_ff verilog nodes, which enforce inference
of registers. This block takes a clock signal and edge sensitivity and
reset type. If the reset type is anything but &rsquo;noreset&rsquo;, the block takes a
reset signal, reset sensitivity, and reset block. Appropriate if conditions
are generated in the output code based on the reset type. A negative-edge,
asynchronous reset will check the inverse of the reset condition
(if (!reset) begin resetblock end) to match the sensitivity.</p><p>Traits: NoRegionArguments, NoTerminator, NonProceduralOp, ProceduralRegion, RecursiveSideEffects, SingleBlock</p><h4 id=attributes>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clockEdge</code></td><td style=text-align:center>circt::sv::EventControlAttr</td><td>edge control trigger</td></tr><tr><td style=text-align:center><code>resetStyle</code></td><td style=text-align:center>::ResetTypeAttr</td><td>reset type</td></tr><tr><td style=text-align:center><code>resetEdge</code></td><td style=text-align:center>circt::sv::EventControlAttr</td><td>edge control trigger</td></tr></tbody></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>reset</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=svalways-circtsvalwaysop><code>sv.always</code> (::circt::sv::AlwaysOp)</h3><p>&lsquo;always @&rsquo; block</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.always` custom&lt;EventList&gt;($events, $clocks) $body attr-dict
</code></pre><p>See SV Spec 9.2, and 9.4.2.2.
Traits: NoRegionArguments, NoTerminator, NonProceduralOp, ProceduralRegion, RecursiveSideEffects, SingleBlock</p><h4 id=attributes-1>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>events</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>events</td></tr></tbody></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clocks</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=svarray_index_inout-circtsvarrayindexinoutop><code>sv.array_index_inout</code> (::circt::sv::ArrayIndexInOutOp)</h3><p>Index an inout memory to produce an inout element</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.array_index_inout` $input`[`$index`]` attr-dict `:` qualified(type($input)) `,` qualified(type($index))
</code></pre><p>See SV Spec 11.5.2.
Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>an inout type with array element</td></tr><tr><td style=text-align:center><code>index</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svassertconcurrent-circtsvassertconcurrentop><code>sv.assert.concurrent</code> (::circt::sv::AssertConcurrentOp)</h3><p>concurrent assertion statement, i.e., assert property</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.assert.concurrent` $event $clock `,` $property
              (`label` $label^)?
              (`message` $message^ (`(` $operands^ `)` `:` qualified(type($operands)))?)?
              attr-dict
</code></pre><p>Specify that a property of the hardware design is true whenever the property
is evaluated. This can be used to both document the behavior of the design
and to test that the design behaves as expected. See section 16.5 of the
SystemVerilog 2017 specification.</p><h4 id=attributes-2>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>event</code></td><td style=text-align:center>circt::sv::EventControlAttr</td><td>edge control trigger</td></tr><tr><td style=text-align:center><code>label</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>property</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svassert-circtsvassertop><code>sv.assert</code> (::circt::sv::AssertOp)</h3><p>immediate assertion statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.assert` $expression `,` $defer
              (`label` $label^)?
              (`message` $message^ (`(` $operands^ `)` `:` qualified(type($operands)))?)?
              attr-dict
</code></pre><p>Specify that a Boolean expression is always true. This can be used to both
document the behavior of the design and to test that the design behaves as
expected. See Section 16.3 of the SystemVerilog 2017 specification.</p><p>Traits: ProceduralOp</p><h4 id=attributes-3>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>defer</code></td><td style=text-align:center>circt::sv::DeferAssertAttr</td><td>assertion deferring mode</td></tr><tr><td style=text-align:center><code>label</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>expression</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svinterfacesignalassign-circtsvassigninterfacesignalop><code>sv.interface.signal.assign</code> (::circt::sv::AssignInterfaceSignalOp)</h3><p>Assign an interfaces signal to some other signal.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.interface.signal.assign` $iface `(` custom&lt;IfaceTypeAndSignal&gt;(type($iface), $signalName) `)`
              `=` $rhs attr-dict `:` qualified(type($rhs))
</code></pre><p>Use this to continuously assign a signal inside an interface to a
value or other signal.</p><pre tabindex=0><code>  sv.interface.signal.assign %iface(@handshake_example::@data)
    = %zero32 : i32
</code></pre><p>Would result in the following SystemVerilog:</p><pre tabindex=0><code>  assign iface.data = zero32;
</code></pre><h4 id=attributes-4>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>signalName</code></td><td style=text-align:center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>iface</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>any type</td></tr></tbody></table><h3 id=svassign-circtsvassignop><code>sv.assign</code> (::circt::sv::AssignOp)</h3><p>Continuous assignment</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.assign` $dest `,` $src (`svattrs` $svAttributes^)? attr-dict
              `:` qualified(type($src))
</code></pre><p>A SystemVerilog assignment statement &lsquo;x = y;&rsquo;.
These occur in module scope. See SV Spec 10.3.2.</p><p>Traits: NonProceduralOp</p><h4 id=attributes-5>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>svAttributes</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>sv.attribute array attribute</td></tr></tbody></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>InOutType</td></tr><tr><td style=text-align:center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=svassumeconcurrent-circtsvassumeconcurrentop><code>sv.assume.concurrent</code> (::circt::sv::AssumeConcurrentOp)</h3><p>concurrent assume statement, i.e., assume property</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.assume.concurrent` $event $clock `,` $property
              (`label` $label^)?
              (`message` $message^ (`(` $operands^ `)` `:` qualified(type($operands)))?)?
              attr-dict
</code></pre><p>Specify that a property is assumed to be true whenever the property is
evaluated. This can be used to both document the behavior of the design and
to test that the design behaves as expected. See section 16.5 of the
SystemVerilog 2017 specification.</p><h4 id=attributes-6>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>event</code></td><td style=text-align:center>circt::sv::EventControlAttr</td><td>edge control trigger</td></tr><tr><td style=text-align:center><code>label</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>property</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svassume-circtsvassumeop><code>sv.assume</code> (::circt::sv::AssumeOp)</h3><p>immediate assume statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.assume` $expression `,` $defer
              (`label` $label^)?
              (`message` $message^ (`(` $operands^ `)` `:` qualified(type($operands)))?)?
              attr-dict
</code></pre><p>Specify that a Boolean expression is assumed to always be true. This can
either be used as an assertion-like check that the expression is, in fact,
always true or to bound legal input values during testing. See Section 16.3
of the SystemVerilog 2017 specification.</p><p>Traits: ProceduralOp</p><h4 id=attributes-7>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>defer</code></td><td style=text-align:center>circt::sv::DeferAssertAttr</td><td>assertion deferring mode</td></tr><tr><td style=text-align:center><code>label</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>expression</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svbpassign-circtsvbpassignop><code>sv.bpassign</code> (::circt::sv::BPAssignOp)</h3><p>Blocking procedural assignment</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.bpassign` $dest `,` $src  attr-dict `:` qualified(type($src))
</code></pre><p>A SystemVerilog blocking procedural assignment statement &lsquo;x = y;&rsquo;. These
occur in initial, always, task, and function blocks. The statement is
executed before any following statements are. See SV Spec 10.4.1.</p><p>Traits: ProceduralOp</p><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>InOutType</td></tr><tr><td style=text-align:center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=svbindinterface-circtsvbindinterfaceop><code>sv.bind.interface</code> (::circt::sv::BindInterfaceOp)</h3><p>indirectly instantiate an interface</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.bind.interface` $instance attr-dict
</code></pre><p>Indirectly instantiate an interface in the context of another module. This
operation must pair with a <code>sv.interface.instance</code>.</p><p>Interfaces: SymbolUserOpInterface</p><h4 id=attributes-8>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>instance</code></td><td style=text-align:center>::circt::hw::InnerRefAttr</td><td>Refer to a name inside a module</td></tr></tbody></table><h3 id=svbind-circtsvbindop><code>sv.bind</code> (::circt::sv::BindOp)</h3><p>indirect instantiation statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.bind` $instance attr-dict
</code></pre><p>Indirectly instantiate a module from the context of another module. BindOp
pairs with a <code>hw.instance</code> (identified by a <code>boundInstance</code> symbol) which
tracks all information except the emission point for the bind. BindOp also
tracks the <code>instanceModule</code> symbol for the <code>hw.module</code> that contains the
<code>hw.instance</code> to accelerate symbol lookup.</p><p>See 23.11 of SV 2017 spec for more information about bind.</p><p>Interfaces: SymbolUserOpInterface</p><h4 id=attributes-9>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>instance</code></td><td style=text-align:center>::circt::hw::InnerRefAttr</td><td>Refer to a name inside a module</td></tr></tbody></table><h3 id=svcase-circtsvcaseop><code>sv.case</code> (::circt::sv::CaseOp)</h3><p>&lsquo;case (cond)&rsquo; block</p><p>See SystemVerilog 2017 12.5.
Traits: NoRegionArguments, NoTerminator, ProceduralOp, ProceduralRegion, SingleBlock</p><h4 id=attributes-10>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>caseStyle</code></td><td style=text-align:center>::CaseStmtTypeAttr</td><td>case type</td></tr><tr><td style=text-align:center><code>casePatterns</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td style=text-align:center><code>validationQualifier</code></td><td style=text-align:center>::circt::sv::ValidationQualifierTypeEnumAttr</td><td>validation qualifier type</td></tr></tbody></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>any type</td></tr></tbody></table><h3 id=svconstantx-circtsvconstantxop><code>sv.constantX</code> (::circt::sv::ConstantXOp)</h3><p>A constant of value &lsquo;x&rsquo;</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.constantX` attr-dict `:` qualified(type($result))
</code></pre><p>This operation produces a constant value of &lsquo;x&rsquo;. This &lsquo;x&rsquo; follows the
System Verilog rules for &lsquo;x&rsquo; propagation.</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element</td></tr></tbody></table><h3 id=svconstantz-circtsvconstantzop><code>sv.constantZ</code> (::circt::sv::ConstantZOp)</h3><p>A constant of value &lsquo;z&rsquo;</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.constantZ` attr-dict `:` qualified(type($result))
</code></pre><p>This operation produces a constant value of &lsquo;z&rsquo;. This &lsquo;z&rsquo; follows the
System Verilog rules for &lsquo;z&rsquo; propagation.</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element</td></tr></tbody></table><h3 id=svcoverconcurrent-circtsvcoverconcurrentop><code>sv.cover.concurrent</code> (::circt::sv::CoverConcurrentOp)</h3><p>concurrent cover statement, i.e., cover property</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.cover.concurrent` $event $clock `,` $property
              (`label` $label^)?
              (`message` $message^ (`(` $operands^ `)` `:` qualified(type($operands)))?)?
              attr-dict
</code></pre><p>Specify that a specific property should be monitored for coverage, i.e., a
simulation will watch if it occurrs and how many times it occurs. See
section 16.5 of the SystemVerilog 2017 specification.</p><h4 id=attributes-11>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>event</code></td><td style=text-align:center>circt::sv::EventControlAttr</td><td>edge control trigger</td></tr><tr><td style=text-align:center><code>label</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>property</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svcover-circtsvcoverop><code>sv.cover</code> (::circt::sv::CoverOp)</h3><p>immediate cover statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.cover` $expression `,` $defer
              (`label` $label^)?
              (`message` $message^ (`(` $operands^ `)` `:` qualified(type($operands)))?)?
              attr-dict
</code></pre><p>Specify that a Boolean expression should be monitored for coverage, i.e., a
simulator will watch if it occurs and how many times it occurs. See section
16.3 of the SystemVerilog 2017 specification.</p><p>Traits: ProceduralOp</p><h4 id=attributes-12>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>defer</code></td><td style=text-align:center>circt::sv::DeferAssertAttr</td><td>assertion deferring mode</td></tr><tr><td style=text-align:center><code>label</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>expression</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svnonstandarddeposit-circtsvdepositop><code>sv.nonstandard.deposit</code> (::circt::sv::DepositOp)</h3><p><code>$deposit</code> system task</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.nonstandard.deposit` $dest `,` $src  attr-dict `:` qualified(type($src))
</code></pre><p>This system task sets the value of a net or variable, but doesn&rsquo;t hold it.
This is a common simulation vendor extension.</p><p>Traits: ProceduralOp, VendorExtension</p><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>InOutType</td></tr><tr><td style=text-align:center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=sverror-circtsverrorop><code>sv.error</code> (::circt::sv::ErrorOp)</h3><p><code>$error</code> severity message task</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.error` ($message^ (`(` $operands^ `)` `:` qualified(type($operands)))?)?
              attr-dict
</code></pre><p>This system task indicates a run-time error.</p><p>If present, the optional message is printed with any additional operands
interpolated into the message string.</p><p>Traits: ProceduralOp</p><h4 id=attributes-13>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svexit-circtsvexitop><code>sv.exit</code> (::circt::sv::ExitOp)</h3><p><code>$exit</code> system task</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.exit` attr-dict
</code></pre><p>Waits for all <code>program</code> blocks to complete and then makes an implicit call
to <code>$finish</code> with default verbosity (level 1) to conclude the simulation.</p><p>Traits: ProceduralOp</p><h3 id=svfwrite-circtsvfwriteop><code>sv.fwrite</code> (::circt::sv::FWriteOp)</h3><p>&lsquo;$fwrite&rsquo; statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.fwrite` $fd `,` $string attr-dict (`(` $operands^ `)` `:` qualified(type($operands)))?
</code></pre><p>Traits: ProceduralOp</p><h4 id=attributes-14>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>string</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fd</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svfatal-circtsvfatalop><code>sv.fatal</code> (::circt::sv::FatalOp)</h3><p><code>$fatal</code> severity message task</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.fatal` $verbosity
              (`,` $message^ (`(` $operands^ `)` `:` qualified(type($operands)))?)?
              attr-dict
</code></pre><p>Generates a run-time fatal error which terminates the simulation with an
error code. Makes an implicit call to <code>$finish</code>, forwarding the <code>verbosity</code>
operand. If present, the optional message is printed with any additional
operands interpolated into the message string.</p><p>Traits: ProceduralOp</p><h4 id=attributes-15>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>verbosity</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>8-bit signless integer attribute whose minimum value is 0 whose maximum value is 2</td></tr><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svfinish-circtsvfinishop><code>sv.finish</code> (::circt::sv::FinishOp)</h3><p><code>$finish</code> system task</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.finish` $verbosity attr-dict
</code></pre><p>Stops the simulation and exits/terminates the simulator process. In practice
most GUI-based simulators will show a prompt to the user offering them an
opportunity to not close the simulator altogether.</p><p>Other tasks such as <code>$exit</code> or <code>$fatal</code> implicitly call this system task.</p><p>The optional <code>verbosity</code> parameter controls how much diagnostic information
is printed when the system task is executed (see section 20.2 of IEEE
1800-2017):</p><ul><li><code>0</code>: Prints nothing</li><li><code>1</code>: Prints simulation time and location (default)</li><li><code>2</code>: Prints simulation time, location, and statistics about the memory and
CPU time used in simulation</li></ul><p>Traits: ProceduralOp</p><h4 id=attributes-16>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>verbosity</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>8-bit signless integer attribute whose minimum value is 0 whose maximum value is 2</td></tr></tbody></table><h3 id=svforce-circtsvforceop><code>sv.force</code> (::circt::sv::ForceOp)</h3><p>Force procedural statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.force` $dest `,` $src  attr-dict `:` qualified(type($src))
</code></pre><p>A SystemVerilog force procedural statement &lsquo;force x = y;&rsquo;. These
occur in initial, always, task, and function blocks.
A force statement shall override a procedural assignment until
a release statement is executed on the variable.
The left-hand side of the assignment can be a variable, a net,
a constant bit-select of a vector net, a part-select of a vector
net or a concatenation. It cannot be a memory word or a bit-select
or part-select of a vector variable. See SV Spec 10.6.2.</p><p>Traits: ProceduralOp</p><h4 id=operands-18>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>InOutType</td></tr><tr><td style=text-align:center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=svgeneratecase-circtsvgeneratecaseop><code>sv.generate.case</code> (::circt::sv::GenerateCaseOp)</h3><p>A &lsquo;case&rsquo; statement inside of a generate block</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.generate.case` $cond attr-dict `[`
              custom&lt;CaseRegions&gt;($casePatterns, $caseNames, $caseRegions)
              `]`
</code></pre><p>See SystemVerilog 2017 27.5.
Traits: HasParent<generateop>, NoRegionArguments, NoTerminator, SingleBlock</p><h4 id=attributes-17>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td style=text-align:center>::mlir::Attribute</td><td>any attribute</td></tr><tr><td style=text-align:center><code>casePatterns</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td style=text-align:center><code>caseNames</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>array attribute</td></tr></tbody></table><h3 id=svgenerate-circtsvgenerateop><code>sv.generate</code> (::circt::sv::GenerateOp)</h3><p>A generate block</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.generate` $sym_name attr-dict `:` $body
</code></pre><p>See SystemVerilog 2017 27.
Traits: NoRegionArguments, NoTerminator, SingleBlock</p><h4 id=attributes-18>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=svmodportget-circtsvgetmodportop><code>sv.modport.get</code> (::circt::sv::GetModportOp)</h3><p>Get a modport out of an interface instance</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.modport.get` $iface $field attr-dict `:` qualified(type($iface)) `-&gt;` qualified(type($result))
</code></pre><p>Use this to extract a modport view to an instantiated interface. For
example, to get the &lsquo;dataflow_in&rsquo; modport on the &lsquo;handshake_example&rsquo;
interface:</p><pre tabindex=0><code>%ifaceModport = sv.modport.get @dataflow_in %iface :
  !sv.interface&lt;@handshake_example&gt; -&gt;
  !sv.modport&lt;@handshake_example::@dataflow_in&gt;
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-19>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>field</code></td><td style=text-align:center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-19>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>iface</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>SystemVerilog type pointing to an InterfaceModportOp</td></tr></tbody></table><h3 id=svifdef-circtsvifdefop><code>sv.ifdef</code> (::circt::sv::IfDefOp)</h3><p>&lsquo;ifdef MACRO&rsquo; block</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.ifdef` $cond $thenRegion (`else` $elseRegion^)? attr-dict
</code></pre><p>This operation is an #ifdef block, which has a &ldquo;then&rdquo; and &ldquo;else&rdquo; region.
This operation is for non-procedural regions and its body is non-procedural.</p><p>Traits: NoRegionArguments, NoTerminator, NonProceduralOp, SingleBlock</p><h4 id=attributes-20>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td style=text-align:center>::circt::sv::MacroIdentAttr</td><td>Macro identifier</td></tr></tbody></table><h3 id=svifdefprocedural-circtsvifdefproceduralop><code>sv.ifdef.procedural</code> (::circt::sv::IfDefProceduralOp)</h3><p>&lsquo;ifdef MACRO&rsquo; block for procedural regions</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.ifdef.procedural` $cond $thenRegion (`else` $elseRegion^)? attr-dict
</code></pre><p>This operation is an #ifdef block, which has a &ldquo;then&rdquo; and &ldquo;else&rdquo; region.
This operation is for procedural regions and its body is procedural.</p><p>Traits: NoRegionArguments, NoTerminator, ProceduralOp, ProceduralRegion, SingleBlock</p><h4 id=attributes-21>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td style=text-align:center>::circt::sv::MacroIdentAttr</td><td>Macro identifier</td></tr></tbody></table><h3 id=svif-circtsvifop><code>sv.if</code> (::circt::sv::IfOp)</h3><p>&lsquo;if (cond)&rsquo; block</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.if` $cond $thenRegion (`else` $elseRegion^)? attr-dict
</code></pre><p>Traits: NoRegionArguments, NoTerminator, ProceduralOp, ProceduralRegion, SingleBlock</p><h4 id=operands-20>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=svindexed_part_select_inout-circtsvindexedpartselectinoutop><code>sv.indexed_part_select_inout</code> (::circt::sv::IndexedPartSelectInOutOp)</h3><p>Address several contiguous bits of an inout type (e.g. a wire or inout port). This is an indexed part-select operator.The base is an integer expression and the width is an integer constant. The bits start from base and the number of bits selected is equal to width. If $decrement is true, then part select decrements starting from $base.See SV Spec 11.5.1.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.indexed_part_select_inout` $input`[`$base (`decrement` $decrement^)?`:` $width`]` attr-dict `:` qualified(type($input)) `,` qualified(type($base))
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-22>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>width</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>decrement</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-21>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>InOutType</td></tr><tr><td style=text-align:center><code>base</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svindexed_part_select-circtsvindexedpartselectop><code>sv.indexed_part_select</code> (::circt::sv::IndexedPartSelectOp)</h3><p>Read several contiguous bits of an int type.This is an indexed part-select operator.The base is an integer expression and the width is an integer constant. The bits start from base and the number of bits selected is equal to width. If $decrement is true, then part select decrements starting from $base.See SV Spec 11.5.1.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.indexed_part_select` $input`[`$base (`decrement` $decrement^)?`:` $width`]` attr-dict `:` qualified(type($input)) `,` qualified(type($base))
</code></pre><p>Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-23>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>width</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td style=text-align:center><code>decrement</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr></tbody></table><h4 id=operands-22>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>an integer bitvector of one or more bits</td></tr><tr><td style=text-align:center><code>base</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>an integer bitvector of one or more bits</td></tr></tbody></table><h3 id=svinfo-circtsvinfoop><code>sv.info</code> (::circt::sv::InfoOp)</h3><p><code>$info</code> severity message task</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.info` ($message^ (`(` $operands^ `)` `:` qualified(type($operands)))?)?
              attr-dict
</code></pre><p>This system task indicates a message with no specific severity.</p><p>If present, the optional message is printed with any additional operands
interpolated into the message string.</p><p>Traits: ProceduralOp</p><h4 id=attributes-24>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-23>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svinitial-circtsvinitialop><code>sv.initial</code> (::circt::sv::InitialOp)</h3><p>&lsquo;initial&rsquo; block</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.initial` $body attr-dict
</code></pre><p>See SV Spec 9.2.1.
Traits: NoRegionArguments, NoTerminator, NonProceduralOp, ProceduralRegion, RecursiveSideEffects, SingleBlock</p><h3 id=svinterfaceinstance-circtsvinterfaceinstanceop><code>sv.interface.instance</code> (::circt::sv::InterfaceInstanceOp)</h3><p>Instantiate an interface</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.interface.instance` (`sym` $inner_sym^)? custom&lt;ImplicitSSAName&gt;(attr-dict)
              `:` qualified(type($result))
</code></pre><p>Use this to declare an instance of an interface:</p><pre tabindex=0><code>%iface = sv.interface.instance : !sv.interface&lt;@handshake_example&gt;
</code></pre><h4 id=attributes-25>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr></tbody></table><h3 id=svinterfacemodport-circtsvinterfacemodportop><code>sv.interface.modport</code> (::circt::sv::InterfaceModportOp)</h3><p>Operation to define a SystemVerilog modport for interfaces</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.interface.modport` attr-dict $sym_name custom&lt;ModportStructs&gt;($ports)
</code></pre><p>This operation defines a named modport within an interface. Its name is a
symbol that can be looked up inside its parent interface. There is an array
of structs that contains two fields: an enum to indicate the direction of
the signal in the modport, and a symbol reference to refer to the signal.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@input_port</span> <span class=p>(</span>input <span class=nf>@data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@output_port</span> <span class=p>(</span>output <span class=nf>@data</span><span class=p>)</span>
</span></span></code></pre></div><p>Traits: HasParent<interfaceop></p><p>Interfaces: Symbol</p><h4 id=attributes-26>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>ports</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>array of modport structs</td></tr></tbody></table><h3 id=svinterface-circtsvinterfaceop><code>sv.interface</code> (::circt::sv::InterfaceOp)</h3><p>Operation to define a SystemVerilog interface</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.interface` attr-dict $sym_name $body
</code></pre><p>This operation defines a named interface. Its name is a symbol that can
be looked up when declared inside a SymbolTable operation. This operation is
also a SymbolTable itself, so the symbols in its region can be looked up.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>sv<span class=p>.</span>interface <span class=nf>@myinterface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  sv<span class=p>.</span>interface<span class=p>.</span>signal <span class=nf>@data</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@input_port</span> <span class=p>(</span>input <span class=nf>@data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@output_port</span> <span class=p>(</span>output <span class=nf>@data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: NoTerminator, SingleBlock, SymbolTable</p><p>Interfaces: Symbol</p><h4 id=attributes-27>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h3 id=svinterfacesignal-circtsvinterfacesignalop><code>sv.interface.signal</code> (::circt::sv::InterfaceSignalOp)</h3><p>Operation to define a SystemVerilog signal for interfaces</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.interface.signal` attr-dict $sym_name `:` $type
</code></pre><p>This operation defines a named signal within an interface. Its type is
specified in an attribute, and currently supports IntegerTypes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>sv<span class=p>.</span>interface<span class=p>.</span>signal <span class=nf>@data</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: HasParent<interfaceop></p><p>Interfaces: Symbol</p><h4 id=attributes-28>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sym_name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>type</code></td><td style=text-align:center>::mlir::TypeAttr</td><td>Any SV/HW type</td></tr></tbody></table><h3 id=svlocalparam-circtsvlocalparamop><code>sv.localparam</code> (::circt::sv::LocalParamOp)</h3><p>Declare a localparam</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.localparam` `:` qualified(type($result)) custom&lt;ImplicitSSAName&gt;(attr-dict)
</code></pre><p>The localparam operation produces a <code>localparam</code> declaration. See SV spec
6.20.4 p125.</p><p>Traits: FirstAttrDerivedResultType</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-29>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td style=text-align:center>::mlir::Attribute</td><td>any attribute</td></tr><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element</td></tr></tbody></table><h3 id=svlogic-circtsvlogicop><code>sv.logic</code> (::circt::sv::LogicOp)</h3><p>Define a logic</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.logic` (`sym` $inner_sym^)? custom&lt;ImplicitSSAName&gt;(attr-dict) `:`
              qualified(type($result))
</code></pre><p>Declare a SystemVerilog Variable Declaration of &rsquo;logic&rsquo; type.
See SV Spec 6.8, pp100.</p><p>Interfaces: OpAsmOpInterface</p><h4 id=attributes-30>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svmacroref-circtsvmacrorefexprop><code>sv.macro.ref</code> (::circt::sv::MacroRefExprOp)</h3><p>Expression to refer to a SystemVerilog macro</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.macro.ref` `&lt;` $ident `&gt;` attr-dict `:` qualified(type($result))
</code></pre><p>This operation produces a value by referencing a named macro.</p><p>Presently, it is assumed that the referenced macro is a constant with no
side effects. This expression is subject to CSE. It can be duplicated
and emitted inline by the Verilog emitter.</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-31>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ident</code></td><td style=text-align:center>::circt::sv::MacroIdentAttr</td><td>Macro identifier</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element or InOutType</td></tr></tbody></table><h3 id=svordered-circtsvorderedoutputop><code>sv.ordered</code> (::circt::sv::OrderedOutputOp)</h3><p>a sub-graph region which guarantees to output statements in-order</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.ordered` $body attr-dict
</code></pre><p>This operation groups operations into a region whose purpose is to force
verilog emission to be statement-by-statement, in-order. This allows
side-effecting operations, or macro expansions which applie to subsequent
operations to be properly sequenced.
This operation is for non-procedural regions and its body is non-procedural.</p><p>Traits: NoRegionArguments, NoTerminator, NonProceduralOp, SingleBlock</p><h3 id=svpassign-circtsvpassignop><code>sv.passign</code> (::circt::sv::PAssignOp)</h3><p>Nonblocking procedural assignment</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.passign` $dest `,` $src  attr-dict `:` qualified(type($src))
</code></pre><p>A SystemVerilog nonblocking procedural assignment statement &lsquo;x &lt;= y;&rsquo;.
These occur in initial, always, task, and function blocks. The statement
can be scheduled without blocking procedural flow. See SV Spec 10.4.2.</p><p>Traits: ProceduralOp</p><h4 id=operands-24>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>InOutType</td></tr><tr><td style=text-align:center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=svread_inout-circtsvreadinoutop><code>sv.read_inout</code> (::circt::sv::ReadInOutOp)</h3><p>Get the value of from something of inout type (e.g. a wire or inout port) as the value itself.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.read_inout` $input attr-dict `:` qualified(type($input))
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=operands-25>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>InOutType</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element</td></tr></tbody></table><h3 id=svinterfacesignalread-circtsvreadinterfacesignalop><code>sv.interface.signal.read</code> (::circt::sv::ReadInterfaceSignalOp)</h3><p>Access the data in an interface&rsquo;s signal.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.interface.signal.read` $iface `(` custom&lt;IfaceTypeAndSignal&gt;(type($iface), $signalName) `)`
              attr-dict `:` qualified(type($signalData))
</code></pre><p>This is an expression to access a signal inside of an interface.</p><pre tabindex=0><code>  %ifaceData = sv.interface.signal.read %iface
      (@handshake_example::@data) : i32
</code></pre><p>Could result in the following SystemVerilog:</p><pre tabindex=0><code>  wire [31:0] ifaceData = iface.data;
</code></pre><p>Interfaces: NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-32>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>signalName</code></td><td style=text-align:center>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></tbody></table><h4 id=operands-26>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>iface</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>signalData</code></td><td>any type</td></tr></tbody></table><h3 id=svreg-circtsvregop><code>sv.reg</code> (::circt::sv::RegOp)</h3><p>Define a new <code>reg</code> in SystemVerilog</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.reg` (`sym` $inner_sym^)? custom&lt;ImplicitSSAName&gt;(attr-dict)
              (`svattrs` $svAttributes^)? `:` qualified(type($result))
</code></pre><p>Declare a SystemVerilog Variable Declaration of &lsquo;reg&rsquo; type.
See SV Spec 6.8, pp100.</p><p>Interfaces: OpAsmOpInterface</p><h4 id=attributes-33>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>svAttributes</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>sv.attribute array attribute</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svrelease-circtsvreleaseop><code>sv.release</code> (::circt::sv::ReleaseOp)</h3><p>Release procedural statement</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.release` $dest attr-dict `:` qualified(type($dest))
</code></pre><p>Release is used in conjunction with force. When released,
then if the variable does not currently have an active assign
procedural continuous assignment, the variable shall not immediately
change value. The variable shall maintain its current value until
the next procedural assignment or procedural continuous assignment
to the variable. Releasing a variable that currently has an
active assign procedural continuous assignment shall immediately
reestablish that assignment. See SV Spec 10.6.2.</p><p>Traits: ProceduralOp</p><h4 id=operands-27>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>InOutType</td></tr></tbody></table><h3 id=svsystemsampled-circtsvsampledop><code>sv.system.sampled</code> (::circt::sv::SampledOp)</h3><p><code>$sampled</code> system function to sample a value</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.system.sampled` $expression attr-dict `:` qualified(type($expression))
</code></pre><p>Sample a value using System Verilog sampling semantics (see Section 16.5.1
of the SV 2017 specification for more information).</p><p>A use of <code>$sampled</code> is to safely read the value of a net/variable in a
concurrent assertion action block such that the value will be the same as
the value used when the assertion is triggered. See Section 16.9.3 of the
SV 2017 specification for more information.</p><p>Traits: SameOperandsAndResultType</p><p>Interfaces: InferTypeOpInterface</p><h4 id=operands-28>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>expression</code></td><td>any type</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sampledValue</code></td><td>any type</td></tr></tbody></table><h3 id=svstop-circtsvstopop><code>sv.stop</code> (::circt::sv::StopOp)</h3><p><code>$stop</code> system task</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.stop` $verbosity attr-dict
</code></pre><p>Causes the simulation to be suspended. Does not terminate the simulator.</p><p>The optional <code>verbosity</code> parameter controls how much diagnostic information
is printed when the system task is executed (see section 20.2 of IEEE
1800-2017):</p><ul><li><code>0</code>: Prints nothing</li><li><code>1</code>: Prints simulation time and location (default)</li><li><code>2</code>: Prints simulation time, location, and statistics about the memory and
CPU time used in simulation</li></ul><p>Traits: ProceduralOp</p><h4 id=attributes-34>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>verbosity</code></td><td style=text-align:center>::mlir::IntegerAttr</td><td>8-bit signless integer attribute whose minimum value is 0 whose maximum value is 2</td></tr></tbody></table><h3 id=svstruct_field_inout-circtsvstructfieldinoutop><code>sv.struct_field_inout</code> (::circt::sv::StructFieldInOutOp)</h3><p>Create an subfield inout memory to produce an inout element.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.struct_field_inout` $input `[` $field `]` attr-dict `:` qualified(type($input))
</code></pre><p>See SV Spec 7.2.
Interfaces: InferTypeOpInterface, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-35>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>field</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-29>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>an inout type with struct field</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svverbatimexpr-circtsvverbatimexprop><code>sv.verbatim.expr</code> (::circt::sv::VerbatimExprOp)</h3><p>Expression that expands to a value given SystemVerilog text</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.verbatim.expr` $string (`(` $operands^ `)`)?
              `:` functional-type($operands, $result) attr-dict
</code></pre><p>This operation produces a typed value expressed by a string of
SystemVerilog. This can be used to access macros and other values that are
only sensible as Verilog text.</p><p>The text string is expected to have the highest precedence, so you should
include parentheses in the string if it isn&rsquo;t a single token. This is also
assumed to not have side effects (use sv.verbatim.expr.se) if you need them.</p><p>sv.verbatim.expr allows operand substitutions with {{0}} syntax.</p><p>Interfaces: HasCustomSSAName, NoSideEffect (MemoryEffectOpInterface)</p><p>Effects: MemoryEffects::Effect{}</p><h4 id=attributes-36>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>string</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>symbols</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></tbody></table><h4 id=operands-30>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element or InOutType</td></tr></tbody></table><h3 id=svverbatimexprse-circtsvverbatimexprseop><code>sv.verbatim.expr.se</code> (::circt::sv::VerbatimExprSEOp)</h3><p>Expression that expands to a value given SystemVerilog text</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.verbatim.expr.se` $string (`(` $operands^ `)`)?
              `:` functional-type($operands, $result) attr-dict
</code></pre><p>This operation produces a typed value expressed by a string of
SystemVerilog. This can be used to access macros and other values that are
only sensible as Verilog text.</p><p>The text string is expected to have the highest precedence, so you should
include parentheses in the string if it isn&rsquo;t a single token. This is
allowed to have side effects.</p><p>sv.verbatim.se.expr allows operand substitutions with {{0}} syntax.</p><p>Interfaces: HasCustomSSAName</p><h4 id=attributes-37>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>string</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>symbols</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></tbody></table><h4 id=operands-31>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element or InOutType</td></tr></tbody></table><h3 id=svverbatim-circtsvverbatimop><code>sv.verbatim</code> (::circt::sv::VerbatimOp)</h3><p>Verbatim opaque text emitted inline.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.verbatim` $string (`(` $operands^ `)` `:` qualified(type($operands)))? attr-dict
</code></pre><p>This operation produces opaque text inline in the SystemVerilog output.</p><p>sv.verbatim allows operand substitutions with {{0}} syntax.</p><h4 id=attributes-38>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>string</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>symbols</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></tbody></table><h4 id=operands-32>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svwarning-circtsvwarningop><code>sv.warning</code> (::circt::sv::WarningOp)</h3><p><code>$warning</code> severity message task</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.warning` ($message^ (`(` $operands^ `)` `:` qualified(type($operands)))?)?
              attr-dict
</code></pre><p>This system task indicates a run-time warning.</p><p>If present, the optional message is printed with any additional operands
interpolated into the message string.</p><p>Traits: ProceduralOp</p><h4 id=attributes-39>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>message</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=operands-33>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>any type</td></tr></tbody></table><h3 id=svwire-circtsvwireop><code>sv.wire</code> (::circt::sv::WireOp)</h3><p>Define a new wire</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.wire` (`sym` $inner_sym^)? custom&lt;ImplicitSSAName&gt;(attr-dict)
              (`svattrs` $svAttributes^)? `:` qualified(type($result))
</code></pre><p>Declare a SystemVerilog Net Declaration of &lsquo;wire&rsquo; type.
See SV Spec 6.7, pp97.</p><p>Traits: NonProceduralOp</p><p>Interfaces: OpAsmOpInterface</p><h4 id=attributes-40>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>name</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>inner_sym</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td style=text-align:center><code>svAttributes</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>sv.attribute array attribute</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svxmr-circtsvxmrop><code>sv.xmr</code> (::circt::sv::XMROp)</h3><p>Encode a reference to a non-local net.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.xmr` (`isRooted` $isRooted^)? custom&lt;XMRPath&gt;($path, $terminal) attr-dict `:` qualified(type($result))
</code></pre><p>This represents a non-local hierarchical name to a net, sometimes called a
cross-module reference. A hierarchical name may be absolute, when prefixed
with &lsquo;$root&rsquo;, in which case it is resolved from the set of top-level modules
(any non-instantiated modules). Non-absolute paths are resolved by
attempting resolution of the path locally, then recursively up the instance
graph. See SV Spec 23.6, pp721.</p><p>It is impossible to completely resolve a hierarchical name without making a
closed-world assumption in the compiler. We therefore don&rsquo;t try to link
hierarchical names to what they resolve to at compile time. A frontend
generating this op should ensure that any instance or object in the intended
path has public visibility so paths are not invalidated.</p><h4 id=attributes-41>Attributes:</h4><table><thead><tr><th style=text-align:center>Attribute</th><th style=text-align:center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>isRooted</code></td><td style=text-align:center>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td style=text-align:center><code>path</code></td><td style=text-align:center>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td style=text-align:center><code>terminal</code></td><td style=text-align:center>::mlir::StringAttr</td><td>string attribute</td></tr></tbody></table><h4 id=results-18>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>InOutType</td></tr></tbody></table><h2 id=attribute-definition>Attribute definition</h2><h3 id=macroidentattr>MacroIdentAttr</h3><p>Macro identifier</p><p>Syntax:</p><pre tabindex=0><code>!sv.macro.ident&lt;
  ::mlir::StringAttr   # ident
&gt;
</code></pre><p>Represents a reference to a macro identifier.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ident</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr></tbody></table><h3 id=modportdirectionattr>ModportDirectionAttr</h3><p>Defines direction in a modport</p><p>Syntax:</p><pre tabindex=0><code>!sv.modport_direction&lt;
  ::ModportDirection   # value
&gt;
</code></pre><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::ModportDirection</code></td><td>an enum of type ModportDirection</td></tr></tbody></table><h3 id=modportstructattr>ModportStructAttr</h3><p>Syntax:</p><pre tabindex=0><code>!sv.mod_port&lt;
  ::circt::sv::ModportDirectionAttr,   # direction
  mlir::FlatSymbolRefAttr   # signal
&gt;
</code></pre><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>direction</td><td style=text-align:center><code>::circt::sv::ModportDirectionAttr</code></td><td>Defines direction in a modport</td></tr><tr><td style=text-align:center>signal</td><td style=text-align:center><code>mlir::FlatSymbolRefAttr</code></td><td></td></tr></tbody></table><h3 id=svattributeattr>SVAttributeAttr</h3><p>a Verilog Attribute</p><p>Syntax:</p><pre tabindex=0><code>!sv.attribute&lt;
  ::mlir::StringAttr,   # name
  ::mlir::StringAttr   # expression
&gt;
</code></pre><p>This attribute is used to encode a Verilog <em>attribute</em>. A Verilog attribute
(not to be confused with an LLVM or MLIR attribute) is a syntactic mechanism
for adding metadata to specific declarations, statements, and expressions in
the Verilog language. <em>There are no &ldquo;standard&rdquo; attributes</em>. Specific tools
define and handle their own attributes.</p><p>Verilog attributes have a mandatory name and an optional constant
expression. This is encoded as a key (name) value (expression) pair.
Multiple attributes may be specified, either with multiple separate
attributes or by comman-separating name&ndash;expression pairs.</p><p>For more information, refer to Section 5.12 of the SystemVerilog (1800-2017)
specification.</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>expression</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr></tbody></table><h3 id=validationqualifiertypeenumattr>ValidationQualifierTypeEnumAttr</h3><p>validation qualifier type</p><p>Syntax:</p><pre tabindex=0><code>!sv.validation_qualifier&lt;
  ::circt::sv::ValidationQualifierTypeEnum   # value
&gt;
</code></pre><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::circt::sv::ValidationQualifierTypeEnum</code></td><td>an enum of type ValidationQualifierTypeEnum</td></tr></tbody></table><h2 id=type-definition>Type definition</h2><h3 id=interfacetype>InterfaceType</h3><p>SystemVerilog interface type pointing to an InterfaceOp</p><p>Syntax:</p><pre tabindex=0><code>!sv.interface&lt;
  ::mlir::FlatSymbolRefAttr   # interface
&gt;
</code></pre><p>A MLIR type for the SV dialect&rsquo;s <code>InterfaceOp</code> to allow instances in any
dialect with an open type system. Points at the InterfaceOp which defines
the SystemVerilog interface.</p><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>interface</td><td style=text-align:center><code>::mlir::FlatSymbolRefAttr</code></td><td></td></tr></tbody></table><h3 id=modporttype>ModportType</h3><p>SystemVerilog type pointing to an InterfaceModportOp</p><p>Syntax:</p><pre tabindex=0><code>!sv.modport&lt;
  ::mlir::SymbolRefAttr   # modport
&gt;
</code></pre><p>A MLIR type for the SV dialect&rsquo;s <code>InterfaceModportOp</code> to allow
interactions with any open type system dialect. Points at the
InterfaceModportOp which defines the SystemVerilog interface&rsquo;s modport.</p><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>modport</td><td style=text-align:center><code>::mlir::SymbolRefAttr</code></td><td></td></tr></tbody></table><h2>'sv' Dialect Docs</h2><ul><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/StaticLogic/ title="'staticlogic' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'staticlogic' Dialect</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/ title="SV Dialect Rationale">Next - SV Dialect Rationale <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/StaticLogic/>'staticlogic' Dialect</a></li><li class="active has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li></ul></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/>PyCDE</a></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>