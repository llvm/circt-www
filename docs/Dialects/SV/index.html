<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'sv' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/SV/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'sv' Dialect</h1><p>Types and operations for SV dialect
This dialect defines the <code>sv</code> dialect, which represents various
SystemVerilog-specific constructs in an AST-like representation.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#svalias-circtsvaliasop><code>sv.alias</code> (::circt::sv::AliasOp)</a></li><li><a href=#svalways-circtsvalwaysop><code>sv.always</code> (::circt::sv::AlwaysOp)</a></li><li><a href=#svalwayscomb-circtsvalwayscombop><code>sv.alwayscomb</code> (::circt::sv::AlwaysCombOp)</a></li><li><a href=#svalwaysff-circtsvalwaysffop><code>sv.alwaysff</code> (::circt::sv::AlwaysFFOp)</a></li><li><a href=#svarray_index_inout-circtsvarrayindexinoutop><code>sv.array_index_inout</code> (::circt::sv::ArrayIndexInOutOp)</a></li><li><a href=#svassert-circtsvassertop><code>sv.assert</code> (::circt::sv::AssertOp)</a></li><li><a href=#svassertconcurrent-circtsvassertconcurrentop><code>sv.assert.concurrent</code> (::circt::sv::AssertConcurrentOp)</a></li><li><a href=#svassign-circtsvassignop><code>sv.assign</code> (::circt::sv::AssignOp)</a></li><li><a href=#svassume-circtsvassumeop><code>sv.assume</code> (::circt::sv::AssumeOp)</a></li><li><a href=#svassumeconcurrent-circtsvassumeconcurrentop><code>sv.assume.concurrent</code> (::circt::sv::AssumeConcurrentOp)</a></li><li><a href=#svbind-circtsvbindop><code>sv.bind</code> (::circt::sv::BindOp)</a></li><li><a href=#svbindinterface-circtsvbindinterfaceop><code>sv.bind.interface</code> (::circt::sv::BindInterfaceOp)</a></li><li><a href=#svbpassign-circtsvbpassignop><code>sv.bpassign</code> (::circt::sv::BPAssignOp)</a></li><li><a href=#svcase-circtsvcaseop><code>sv.case</code> (::circt::sv::CaseOp)</a></li><li><a href=#svconstantstr-circtsvconstantstrop><code>sv.constantStr</code> (::circt::sv::ConstantStrOp)</a></li><li><a href=#svconstantx-circtsvconstantxop><code>sv.constantX</code> (::circt::sv::ConstantXOp)</a></li><li><a href=#svconstantz-circtsvconstantzop><code>sv.constantZ</code> (::circt::sv::ConstantZOp)</a></li><li><a href=#svcover-circtsvcoverop><code>sv.cover</code> (::circt::sv::CoverOp)</a></li><li><a href=#svcoverconcurrent-circtsvcoverconcurrentop><code>sv.cover.concurrent</code> (::circt::sv::CoverConcurrentOp)</a></li><li><a href=#sverror-circtsverrorop><code>sv.error</code> (::circt::sv::ErrorOp)</a></li><li><a href=#svexit-circtsvexitop><code>sv.exit</code> (::circt::sv::ExitOp)</a></li><li><a href=#svfatal-circtsvfatalop><code>sv.fatal</code> (::circt::sv::FatalOp)</a></li><li><a href=#svfinish-circtsvfinishop><code>sv.finish</code> (::circt::sv::FinishOp)</a></li><li><a href=#svfor-circtsvforop><code>sv.for</code> (::circt::sv::ForOp)</a></li><li><a href=#svforce-circtsvforceop><code>sv.force</code> (::circt::sv::ForceOp)</a></li><li><a href=#svfwrite-circtsvfwriteop><code>sv.fwrite</code> (::circt::sv::FWriteOp)</a></li><li><a href=#svgenerate-circtsvgenerateop><code>sv.generate</code> (::circt::sv::GenerateOp)</a></li><li><a href=#svgeneratecase-circtsvgeneratecaseop><code>sv.generate.case</code> (::circt::sv::GenerateCaseOp)</a></li><li><a href=#svif-circtsvifop><code>sv.if</code> (::circt::sv::IfOp)</a></li><li><a href=#svifdef-circtsvifdefop><code>sv.ifdef</code> (::circt::sv::IfDefOp)</a></li><li><a href=#svifdefprocedural-circtsvifdefproceduralop><code>sv.ifdef.procedural</code> (::circt::sv::IfDefProceduralOp)</a></li><li><a href=#svindexed_part_select-circtsvindexedpartselectop><code>sv.indexed_part_select</code> (::circt::sv::IndexedPartSelectOp)</a></li><li><a href=#svindexed_part_select_inout-circtsvindexedpartselectinoutop><code>sv.indexed_part_select_inout</code> (::circt::sv::IndexedPartSelectInOutOp)</a></li><li><a href=#svinfo-circtsvinfoop><code>sv.info</code> (::circt::sv::InfoOp)</a></li><li><a href=#svinitial-circtsvinitialop><code>sv.initial</code> (::circt::sv::InitialOp)</a></li><li><a href=#svinterface-circtsvinterfaceop><code>sv.interface</code> (::circt::sv::InterfaceOp)</a></li><li><a href=#svinterfaceinstance-circtsvinterfaceinstanceop><code>sv.interface.instance</code> (::circt::sv::InterfaceInstanceOp)</a></li><li><a href=#svinterfacemodport-circtsvinterfacemodportop><code>sv.interface.modport</code> (::circt::sv::InterfaceModportOp)</a></li><li><a href=#svinterfacesignal-circtsvinterfacesignalop><code>sv.interface.signal</code> (::circt::sv::InterfaceSignalOp)</a></li><li><a href=#svinterfacesignalassign-circtsvassigninterfacesignalop><code>sv.interface.signal.assign</code> (::circt::sv::AssignInterfaceSignalOp)</a></li><li><a href=#svinterfacesignalread-circtsvreadinterfacesignalop><code>sv.interface.signal.read</code> (::circt::sv::ReadInterfaceSignalOp)</a></li><li><a href=#svlocalparam-circtsvlocalparamop><code>sv.localparam</code> (::circt::sv::LocalParamOp)</a></li><li><a href=#svlogic-circtsvlogicop><code>sv.logic</code> (::circt::sv::LogicOp)</a></li><li><a href=#svmacrodecl-circtsvmacrodeclop><code>sv.macro.decl</code> (::circt::sv::MacroDeclOp)</a></li><li><a href=#svmacrodef-circtsvmacrodefop><code>sv.macro.def</code> (::circt::sv::MacroDefOp)</a></li><li><a href=#svmacroref-circtsvmacrorefexprop><code>sv.macro.ref</code> (::circt::sv::MacroRefExprOp)</a></li><li><a href=#svmacrorefse-circtsvmacrorefexprseop><code>sv.macro.ref.se</code> (::circt::sv::MacroRefExprSEOp)</a></li><li><a href=#svmodportget-circtsvgetmodportop><code>sv.modport.get</code> (::circt::sv::GetModportOp)</a></li><li><a href=#svnonstandarddeposit-circtsvdepositop><code>sv.nonstandard.deposit</code> (::circt::sv::DepositOp)</a></li><li><a href=#svordered-circtsvorderedoutputop><code>sv.ordered</code> (::circt::sv::OrderedOutputOp)</a></li><li><a href=#svpassign-circtsvpassignop><code>sv.passign</code> (::circt::sv::PAssignOp)</a></li><li><a href=#svread_inout-circtsvreadinoutop><code>sv.read_inout</code> (::circt::sv::ReadInOutOp)</a></li><li><a href=#svreadmem-circtsvreadmemop><code>sv.readmem</code> (::circt::sv::ReadMemOp)</a></li><li><a href=#svreg-circtsvregop><code>sv.reg</code> (::circt::sv::RegOp)</a></li><li><a href=#svrelease-circtsvreleaseop><code>sv.release</code> (::circt::sv::ReleaseOp)</a></li><li><a href=#svstop-circtsvstopop><code>sv.stop</code> (::circt::sv::StopOp)</a></li><li><a href=#svstruct_field_inout-circtsvstructfieldinoutop><code>sv.struct_field_inout</code> (::circt::sv::StructFieldInOutOp)</a></li><li><a href=#svsystem-circtsvsystemfunctionop><code>sv.system</code> (::circt::sv::SystemFunctionOp)</a></li><li><a href=#svsystemsampled-circtsvsampledop><code>sv.system.sampled</code> (::circt::sv::SampledOp)</a></li><li><a href=#svverbatim-circtsvverbatimop><code>sv.verbatim</code> (::circt::sv::VerbatimOp)</a></li><li><a href=#svverbatimexpr-circtsvverbatimexprop><code>sv.verbatim.expr</code> (::circt::sv::VerbatimExprOp)</a></li><li><a href=#svverbatimexprse-circtsvverbatimexprseop><code>sv.verbatim.expr.se</code> (::circt::sv::VerbatimExprSEOp)</a></li><li><a href=#svwarning-circtsvwarningop><code>sv.warning</code> (::circt::sv::WarningOp)</a></li><li><a href=#svwire-circtsvwireop><code>sv.wire</code> (::circt::sv::WireOp)</a></li><li><a href=#svxmr-circtsvxmrop><code>sv.xmr</code> (::circt::sv::XMROp)</a></li><li><a href=#svxmrref-circtsvxmrrefop><code>sv.xmr.ref</code> (::circt::sv::XMRRefOp)</a></li></ul></li><li><a href=#attributes-49>Attributes</a><ul><li><a href=#macroidentattr>MacroIdentAttr</a></li><li><a href=#modportdirectionattr>ModportDirectionAttr</a></li><li><a href=#modportstructattr>ModportStructAttr</a></li><li><a href=#svattributeattr>SVAttributeAttr</a></li><li><a href=#validationqualifiertypeenumattr>ValidationQualifierTypeEnumAttr</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#interfacetype>InterfaceType</a></li><li><a href=#modporttype>ModportType</a></li></ul></li></ul></nav><h2 id=operations>Operations</h2><h3 id=svalias-circtsvaliasop><code>sv.alias</code> (::circt::sv::AliasOp)</h3><p><em>SystemVerilog &lsquo;alias&rsquo; statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.alias` $aliases attr-dict `:` qualified(type($aliases))
</code></pre><p>An alias statement declares multiple names for the same physical net, or
bits within a net. Aliases always have at least two operands.</p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>aliases</code></td><td>variadic of InOutType</td></tr></tbody></table><h3 id=svalways-circtsvalwaysop><code>sv.always</code> (::circt::sv::AlwaysOp)</h3><p><em>&lsquo;always @&rsquo; block</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.always` custom&lt;EventList&gt;($events, $clocks) $body attr-dict
</code></pre><p>See SV Spec 9.2, and 9.4.2.2.
Traits: <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>NonProceduralOp</code>, <code>ProceduralRegion</code>, <code>RecursiveMemoryEffects</code>, <code>RecursivelySpeculatableImplTrait</code>, <code>SingleBlock</code></p><p>Interfaces: <code>ConditionallySpeculatable</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>events</code></td><td>::mlir::ArrayAttr</td><td>events</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clocks</code></td><td>variadic of 1-bit signless integer</td></tr></tbody></table><h3 id=svalwayscomb-circtsvalwayscombop><code>sv.alwayscomb</code> (::circt::sv::AlwaysCombOp)</h3><p><em>&lsquo;alwayscomb block</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.alwayscomb` $body attr-dict
</code></pre><p>See SV Spec 9.2, and 9.2.2.2.
Traits: <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>NonProceduralOp</code>, <code>ProceduralRegion</code>, <code>RecursiveMemoryEffects</code>, <code>RecursivelySpeculatableImplTrait</code>, <code>SingleBlock</code></p><p>Interfaces: <code>ConditionallySpeculatable</code></p><h3 id=svalwaysff-circtsvalwaysffop><code>sv.alwaysff</code> (::circt::sv::AlwaysFFOp)</h3><p><em>&lsquo;alwaysff @&rsquo; block with optional reset</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.alwaysff` `(` $clockEdge $clock `)` $bodyBlk
              ( `(` $resetStyle `:` $resetEdge^ $reset `)` $resetBlk )? attr-dict
</code></pre><p>alwaysff blocks represent always_ff verilog nodes, which enforce inference
of registers. This block takes a clock signal and edge sensitivity and
reset type. If the reset type is anything but &rsquo;noreset&rsquo;, the block takes a
reset signal, reset sensitivity, and reset block. Appropriate if conditions
are generated in the output code based on the reset type. A negative-edge,
asynchronous reset will check the inverse of the reset condition
(if (!reset) begin resetblock end) to match the sensitivity.</p><p>Traits: <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>NonProceduralOp</code>, <code>ProceduralRegion</code>, <code>RecursiveMemoryEffects</code>, <code>RecursivelySpeculatableImplTrait</code>, <code>SingleBlock</code></p><p>Interfaces: <code>ConditionallySpeculatable</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>clockEdge</code></td><td>circt::sv::EventControlAttr</td><td>edge control trigger</td></tr><tr><td><code>resetStyle</code></td><td>::ResetTypeAttr</td><td>reset type</td></tr><tr><td><code>resetEdge</code></td><td>circt::sv::EventControlAttr</td><td>edge control trigger</td></tr></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>reset</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=svarray_index_inout-circtsvarrayindexinoutop><code>sv.array_index_inout</code> (::circt::sv::ArrayIndexInOutOp)</h3><p><em>Index an inout memory to produce an inout element</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.array_index_inout` $input`[`$index`]` attr-dict `:` qualified(type($input)) `,` qualified(type($index))
</code></pre><p>See SV Spec 11.5.2.
Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>an inout type with array element</td></tr><tr><td style=text-align:center><code>index</code></td><td>a signless integer bitvector</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svassert-circtsvassertop><code>sv.assert</code> (::circt::sv::AssertOp)</h3><p><em>Immediate assertion statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.assert` $expression `,` $defer
              (`label` $label^)?
              (`message` $message^ (`(` $substitutions^ `)` `:`
              qualified(type($substitutions)))?)? attr-dict
</code></pre><p>Specify that a Boolean expression is always true. This can be used to both
document the behavior of the design and to test that the design behaves as
expected. See Section 16.3 of the SystemVerilog 2017 specification.</p><p>Traits: <code>ProceduralOp</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>defer</code></td><td>circt::sv::DeferAssertAttr</td><td>assertion deferring mode</td></tr><tr><td><code>label</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>message</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>expression</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=svassertconcurrent-circtsvassertconcurrentop><code>sv.assert.concurrent</code> (::circt::sv::AssertConcurrentOp)</h3><p><em>Concurrent assertion statement, i.e., assert property</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.assert.concurrent` $event $clock `,` $property
              (`label` $label^)?
              (`message` $message^ (`(` $substitutions^ `)` `:`
              qualified(type($substitutions)))?)? attr-dict
</code></pre><p>Specify that a property of the hardware design is true whenever the property
is evaluated. This can be used to both document the behavior of the design
and to test that the design behaves as expected. See section 16.5 of the
SystemVerilog 2017 specification.</p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>event</code></td><td>circt::sv::EventControlAttr</td><td>edge control trigger</td></tr><tr><td><code>label</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>message</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>property</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=svassign-circtsvassignop><code>sv.assign</code> (::circt::sv::AssignOp)</h3><p><em>Continuous assignment</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.assign` $dest `,` $src attr-dict `:` qualified(type($src))
</code></pre><p>A SystemVerilog assignment statement &lsquo;x = y;&rsquo;.
These occur in module scope. See SV Spec 10.3.2.</p><p>Traits: <code>NonProceduralOp</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>InOutType</td></tr><tr><td style=text-align:center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=svassume-circtsvassumeop><code>sv.assume</code> (::circt::sv::AssumeOp)</h3><p><em>Immediate assume statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.assume` $expression `,` $defer
              (`label` $label^)?
              (`message` $message^ (`(` $substitutions^ `)` `:`
              qualified(type($substitutions)))?)? attr-dict
</code></pre><p>Specify that a Boolean expression is assumed to always be true. This can
either be used as an assertion-like check that the expression is, in fact,
always true or to bound legal input values during testing. See Section 16.3
of the SystemVerilog 2017 specification.</p><p>Traits: <code>ProceduralOp</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>defer</code></td><td>circt::sv::DeferAssertAttr</td><td>assertion deferring mode</td></tr><tr><td><code>label</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>message</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>expression</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=svassumeconcurrent-circtsvassumeconcurrentop><code>sv.assume.concurrent</code> (::circt::sv::AssumeConcurrentOp)</h3><p><em>Concurrent assume statement, i.e., assume property</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.assume.concurrent` $event $clock `,` $property
              (`label` $label^)?
              (`message` $message^ (`(` $substitutions^ `)` `:`
              qualified(type($substitutions)))?)? attr-dict
</code></pre><p>Specify that a property is assumed to be true whenever the property is
evaluated. This can be used to both document the behavior of the design and
to test that the design behaves as expected. See section 16.5 of the
SystemVerilog 2017 specification.</p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>event</code></td><td>circt::sv::EventControlAttr</td><td>edge control trigger</td></tr><tr><td><code>label</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>message</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>property</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=svbind-circtsvbindop><code>sv.bind</code> (::circt::sv::BindOp)</h3><p><em>Indirect instantiation statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.bind` $instance attr-dict
</code></pre><p>Indirectly instantiate a module from the context of another module. BindOp
pairs with a <code>hw.instance</code> (identified by a <code>boundInstance</code> symbol) which
tracks all information except the emission point for the bind. BindOp also
tracks the <code>instanceModule</code> symbol for the <code>hw.module</code> that contains the
<code>hw.instance</code> to accelerate symbol lookup.</p><p>See 23.11 of SV 2017 spec for more information about bind.</p><p>Interfaces: <code>SymbolUserOpInterface</code></p><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>instance</code></td><td>::circt::hw::InnerRefAttr</td><td>Refer to a name inside a module</td></tr></table><h3 id=svbindinterface-circtsvbindinterfaceop><code>sv.bind.interface</code> (::circt::sv::BindInterfaceOp)</h3><p><em>Indirectly instantiate an interface</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.bind.interface` $instance attr-dict
</code></pre><p>Indirectly instantiate an interface in the context of another module. This
operation must pair with a <code>sv.interface.instance</code>.</p><p>Interfaces: <code>SymbolUserOpInterface</code></p><h4 id=attributes-7>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>instance</code></td><td>::circt::hw::InnerRefAttr</td><td>Refer to a name inside a module</td></tr></table><h3 id=svbpassign-circtsvbpassignop><code>sv.bpassign</code> (::circt::sv::BPAssignOp)</h3><p><em>Blocking procedural assignment</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.bpassign` $dest `,` $src  attr-dict `:` qualified(type($src))
</code></pre><p>A SystemVerilog blocking procedural assignment statement &lsquo;x = y;&rsquo;. These
occur in initial, always, task, and function blocks. The statement is
executed before any following statements are. See SV Spec 10.4.1.</p><p>Traits: <code>ProceduralOp</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>InOutType</td></tr><tr><td style=text-align:center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=svcase-circtsvcaseop><code>sv.case</code> (::circt::sv::CaseOp)</h3><p><em>&lsquo;case (cond)&rsquo; block</em></p><p>See SystemVerilog 2017 12.5.
Traits: <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>ProceduralOp</code>, <code>ProceduralRegion</code>, <code>SingleBlock</code></p><h4 id=attributes-8>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>caseStyle</code></td><td>::CaseStmtTypeAttr</td><td>case type</td></tr><tr><td><code>casePatterns</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>validationQualifier</code></td><td>::circt::sv::ValidationQualifierTypeEnumAttr</td><td>validation qualifier type</td></tr></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>any type</td></tr></tbody></table><h3 id=svconstantstr-circtsvconstantstrop><code>sv.constantStr</code> (::circt::sv::ConstantStrOp)</h3><p><em>A constant of string value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.constantStr` $str attr-dict
</code></pre><p>This operation produces a constant string literal.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-9>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>str</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a HW string</td></tr></tbody></table><h3 id=svconstantx-circtsvconstantxop><code>sv.constantX</code> (::circt::sv::ConstantXOp)</h3><p><em>A constant of value &lsquo;x&rsquo;</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.constantX` attr-dict `:` qualified(type($result))
</code></pre><p>This operation produces a constant value of &lsquo;x&rsquo;. This &lsquo;x&rsquo; follows the
System Verilog rules for &lsquo;x&rsquo; propagation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element</td></tr></tbody></table><h3 id=svconstantz-circtsvconstantzop><code>sv.constantZ</code> (::circt::sv::ConstantZOp)</h3><p><em>A constant of value &lsquo;z&rsquo;</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.constantZ` attr-dict `:` qualified(type($result))
</code></pre><p>This operation produces a constant value of &lsquo;z&rsquo;. This &lsquo;z&rsquo; follows the
System Verilog rules for &lsquo;z&rsquo; propagation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element</td></tr></tbody></table><h3 id=svcover-circtsvcoverop><code>sv.cover</code> (::circt::sv::CoverOp)</h3><p><em>Immediate cover statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.cover` $expression `,` $defer
              (`label` $label^)?
              (`message` $message^ (`(` $substitutions^ `)` `:`
              qualified(type($substitutions)))?)? attr-dict
</code></pre><p>Specify that a Boolean expression should be monitored for coverage, i.e., a
simulator will watch if it occurs and how many times it occurs. See section
16.3 of the SystemVerilog 2017 specification.</p><p>Traits: <code>ProceduralOp</code></p><h4 id=attributes-10>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>defer</code></td><td>circt::sv::DeferAssertAttr</td><td>assertion deferring mode</td></tr><tr><td><code>label</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>message</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>expression</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=svcoverconcurrent-circtsvcoverconcurrentop><code>sv.cover.concurrent</code> (::circt::sv::CoverConcurrentOp)</h3><p><em>Concurrent cover statement, i.e., cover property</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.cover.concurrent` $event $clock `,` $property
              (`label` $label^)?
              (`message` $message^ (`(` $substitutions^ `)` `:`
              qualified(type($substitutions)))?)? attr-dict
</code></pre><p>Specify that a specific property should be monitored for coverage, i.e., a
simulation will watch if it occurrs and how many times it occurs. See
section 16.5 of the SystemVerilog 2017 specification.</p><h4 id=attributes-11>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>event</code></td><td>circt::sv::EventControlAttr</td><td>edge control trigger</td></tr><tr><td><code>label</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>message</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clock</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>property</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=sverror-circtsverrorop><code>sv.error</code> (::circt::sv::ErrorOp)</h3><p><em><code>$error</code> severity message task</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.error` ($message^ (`(` $substitutions^ `)` `:` qualified(type($substitutions)))?)?
              attr-dict
</code></pre><p>This system task indicates a run-time error.</p><p>If present, the optional message is printed with any additional operands
interpolated into the message string.</p><p>Traits: <code>ProceduralOp</code></p><h4 id=attributes-12>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=svexit-circtsvexitop><code>sv.exit</code> (::circt::sv::ExitOp)</h3><p><em><code>$exit</code> system task</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.exit` attr-dict
</code></pre><p>Waits for all <code>program</code> blocks to complete and then makes an implicit call
to <code>$finish</code> with default verbosity (level 1) to conclude the simulation.</p><p>Traits: <code>ProceduralOp</code></p><h3 id=svfatal-circtsvfatalop><code>sv.fatal</code> (::circt::sv::FatalOp)</h3><p><em><code>$fatal</code> severity message task</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.fatal` $verbosity
              (`,` $message^ (`(` $substitutions^ `)` `:`
              qualified(type($substitutions)))?)? attr-dict
</code></pre><p>Generates a run-time fatal error which terminates the simulation with an
error code. Makes an implicit call to <code>$finish</code>, forwarding the <code>verbosity</code>
operand. If present, the optional message is printed with any additional
operands interpolated into the message string.</p><p>Traits: <code>ProceduralOp</code></p><h4 id=attributes-13>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>verbosity</code></td><td>::mlir::IntegerAttr</td><td>8-bit signless integer attribute whose minimum value is 0 whose maximum value is 2</td></tr><tr><td><code>message</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=svfinish-circtsvfinishop><code>sv.finish</code> (::circt::sv::FinishOp)</h3><p><em><code>$finish</code> system task</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.finish` $verbosity attr-dict
</code></pre><p>Stops the simulation and exits/terminates the simulator process. In practice
most GUI-based simulators will show a prompt to the user offering them an
opportunity to not close the simulator altogether.</p><p>Other tasks such as <code>$exit</code> or <code>$fatal</code> implicitly call this system task.</p><p>The optional <code>verbosity</code> parameter controls how much diagnostic information
is printed when the system task is executed (see section 20.2 of IEEE
1800-2017):</p><ul><li><code>0</code>: Prints nothing</li><li><code>1</code>: Prints simulation time and location (default)</li><li><code>2</code>: Prints simulation time, location, and statistics about the memory and
CPU time used in simulation</li></ul><p>Traits: <code>ProceduralOp</code></p><h4 id=attributes-14>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>verbosity</code></td><td>::mlir::IntegerAttr</td><td>8-bit signless integer attribute whose minimum value is 0 whose maximum value is 2</td></tr></table><h3 id=svfor-circtsvforop><code>sv.for</code> (::circt::sv::ForOp)</h3><p><em>System verilog for loop</em></p><p>The <code>sv.for</code> operation in System Verilog defines a for statement that requires
three SSA operands: <code>lowerBounds</code>, <code>upperBound</code>, and <code>step</code>. It functions
similarly to <code>scf.for</code>, where the loop iterates the induction variable from
<code>lowerBound</code> to <code>upperBound</code> with a step size of <code>step</code>, i.e:</p><pre tabindex=0><code> for (logic ... indVar = lowerBound; indVar &lt; upperBound; indVar += step) begin
 end
</code></pre><p>It&rsquo;s important to note that since we are using a bit precise type instead of a Verilog
<code>integer</code> type, users must be cautious about potential overflow. For example, if
you wish to iterate over all 2-bit values, you must use a 3-bit value as the
induction variable type.</p><p>Traits: <code>NoTerminator</code>, <code>ProceduralOp</code>, <code>ProceduralRegion</code>, <code>SingleBlock</code></p><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=attributes-15>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inductionVarName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lowerBound</code></td><td>a signless integer bitvector</td></tr><tr><td style=text-align:center><code>upperBound</code></td><td>a signless integer bitvector</td></tr><tr><td style=text-align:center><code>step</code></td><td>a signless integer bitvector</td></tr></tbody></table><h3 id=svforce-circtsvforceop><code>sv.force</code> (::circt::sv::ForceOp)</h3><p><em>Force procedural statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.force` $dest `,` $src  attr-dict `:` qualified(type($src))
</code></pre><p>A SystemVerilog force procedural statement &lsquo;force x = y;&rsquo;. These
occur in initial, always, task, and function blocks.
A force statement shall override a procedural assignment until
a release statement is executed on the variable.
The left-hand side of the assignment can be a variable, a net,
a constant bit-select of a vector net, a part-select of a vector
net or a concatenation. It cannot be a memory word or a bit-select
or part-select of a vector variable. See SV Spec 10.6.2.</p><p>Traits: <code>ProceduralOp</code></p><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>InOutType</td></tr><tr><td style=text-align:center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=svfwrite-circtsvfwriteop><code>sv.fwrite</code> (::circt::sv::FWriteOp)</h3><p><em>&rsquo;$fwrite&rsquo; statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.fwrite` $fd `,` $format_string attr-dict (`(` $substitutions^ `)` `:`
              qualified(type($substitutions)))?
</code></pre><p>Traits: <code>ProceduralOp</code></p><h4 id=attributes-16>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>format_string</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-17>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fd</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=svgenerate-circtsvgenerateop><code>sv.generate</code> (::circt::sv::GenerateOp)</h3><p><em>A generate block</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.generate` $sym_name attr-dict `:` $body
</code></pre><p>See SystemVerilog 2017 27.
Traits: <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><h4 id=attributes-17>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=svgeneratecase-circtsvgeneratecaseop><code>sv.generate.case</code> (::circt::sv::GenerateCaseOp)</h3><p><em>A &lsquo;case&rsquo; statement inside of a generate block</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.generate.case` $cond attr-dict ` ` `[`
              custom&lt;CaseRegions&gt;($casePatterns, $caseNames, $caseRegions)
              `]`
</code></pre><p>See SystemVerilog 2017 27.5.
Traits: <code>HasParent&lt;GenerateOp></code>, <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><h4 id=attributes-18>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>cond</code></td><td>::mlir::TypedAttr</td><td>TypedAttr instance</td></tr><tr><td><code>casePatterns</code></td><td>::mlir::ArrayAttr</td><td>case pattern array</td></tr><tr><td><code>caseNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h3 id=svif-circtsvifop><code>sv.if</code> (::circt::sv::IfOp)</h3><p><em>&lsquo;if (cond)&rsquo; block</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.if` $cond $thenRegion (`else` $elseRegion^)? attr-dict
</code></pre><p>Traits: <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>ProceduralOp</code>, <code>ProceduralRegion</code>, <code>SingleBlock</code></p><h4 id=operands-18>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=svifdef-circtsvifdefop><code>sv.ifdef</code> (::circt::sv::IfDefOp)</h3><p><em>&lsquo;ifdef MACRO&rsquo; block</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.ifdef` $cond $thenRegion (`else` $elseRegion^)? attr-dict
</code></pre><p>This operation is an #ifdef block, which has a &ldquo;then&rdquo; and &ldquo;else&rdquo; region.
This operation is for non-procedural regions and its body is non-procedural.</p><p>Traits: <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>NonProceduralOp</code>, <code>SingleBlock</code></p><p>Interfaces: <code>SymbolUserOpInterface</code></p><h4 id=attributes-19>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>cond</code></td><td>::circt::sv::MacroIdentAttr</td><td>Macro identifier</td></tr></table><h3 id=svifdefprocedural-circtsvifdefproceduralop><code>sv.ifdef.procedural</code> (::circt::sv::IfDefProceduralOp)</h3><p><em>&lsquo;ifdef MACRO&rsquo; block for procedural regions</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.ifdef.procedural` $cond $thenRegion (`else` $elseRegion^)? attr-dict
</code></pre><p>This operation is an #ifdef block, which has a &ldquo;then&rdquo; and &ldquo;else&rdquo; region.
This operation is for procedural regions and its body is procedural.</p><p>Traits: <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>ProceduralOp</code>, <code>ProceduralRegion</code>, <code>SingleBlock</code></p><p>Interfaces: <code>SymbolUserOpInterface</code></p><h4 id=attributes-20>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>cond</code></td><td>::circt::sv::MacroIdentAttr</td><td>Macro identifier</td></tr></table><h3 id=svindexed_part_select-circtsvindexedpartselectop><code>sv.indexed_part_select</code> (::circt::sv::IndexedPartSelectOp)</h3><p><em>Read several contiguous bits of an int type.This is an indexed part-select operator.The base is an integer expression and the width is an integer constant. The bits start from base and the number of bits selected is equal to width. If $decrement is true, then part select decrements starting from $base.See SV Spec 11.5.1.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.indexed_part_select` $input`[`$base (`decrement` $decrement^)?`:` $width`]` attr-dict `:` qualified(type($input)) `,` qualified(type($base))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-21>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>width</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>decrement</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-19>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a signless integer bitvector</td></tr><tr><td style=text-align:center><code>base</code></td><td>a signless integer bitvector</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a signless integer bitvector</td></tr></tbody></table><h3 id=svindexed_part_select_inout-circtsvindexedpartselectinoutop><code>sv.indexed_part_select_inout</code> (::circt::sv::IndexedPartSelectInOutOp)</h3><p><em>Address several contiguous bits of an inout type (e.g. a wire or inout port). This is an indexed part-select operator.The base is an integer expression and the width is an integer constant. The bits start from base and the number of bits selected is equal to width. If $decrement is true, then part select decrements starting from $base.See SV Spec 11.5.1.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.indexed_part_select_inout` $input`[`$base (`decrement` $decrement^)?`:` $width`]` attr-dict `:` qualified(type($input)) `,` qualified(type($base))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-22>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>width</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>decrement</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-20>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>InOutType</td></tr><tr><td style=text-align:center><code>base</code></td><td>a signless integer bitvector</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svinfo-circtsvinfoop><code>sv.info</code> (::circt::sv::InfoOp)</h3><p><em><code>$info</code> severity message task</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.info` ($message^ (`(` $substitutions^ `)` `:` qualified(type($substitutions)))?)?
              attr-dict
</code></pre><p>This system task indicates a message with no specific severity.</p><p>If present, the optional message is printed with any additional operands
interpolated into the message string.</p><p>Traits: <code>ProceduralOp</code></p><h4 id=attributes-23>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-21>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=svinitial-circtsvinitialop><code>sv.initial</code> (::circt::sv::InitialOp)</h3><p><em>&lsquo;initial&rsquo; block</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.initial` $body attr-dict
</code></pre><p>See SV Spec 9.2.1.
Traits: <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>NonProceduralOp</code>, <code>ProceduralRegion</code>, <code>RecursiveMemoryEffects</code>, <code>RecursivelySpeculatableImplTrait</code>, <code>SingleBlock</code></p><p>Interfaces: <code>ConditionallySpeculatable</code></p><h3 id=svinterface-circtsvinterfaceop><code>sv.interface</code> (::circt::sv::InterfaceOp)</h3><p><em>Operation to define a SystemVerilog interface</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.interface` $sym_name attr-dict-with-keyword $body
</code></pre><p>This operation defines a named interface. Its name is a symbol that can
be looked up when declared inside a SymbolTable operation. This operation is
also a SymbolTable itself, so the symbols in its region can be looked up.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>sv<span class=p>.</span>interface <span class=nf>@myinterface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  sv<span class=p>.</span>interface<span class=p>.</span>signal <span class=nf>@data</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@input_port</span> <span class=p>(</span>input <span class=nf>@data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@output_port</span> <span class=p>(</span>output <span class=nf>@data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>NoTerminator</code>, <code>SingleBlock</code>, <code>SymbolTable</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-24>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>comment</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=svinterfaceinstance-circtsvinterfaceinstanceop><code>sv.interface.instance</code> (::circt::sv::InterfaceInstanceOp)</h3><p><em>Instantiate an interface</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.interface.instance` (`sym` $inner_sym^)? `` custom&lt;ImplicitSSAName&gt;($name) attr-dict
              `:` qualified(type($result))
</code></pre><p>Use this to declare an instance of an interface:</p><pre tabindex=0><code>%iface = sv.interface.instance : !sv.interface&lt;@handshake_example&gt;
</code></pre><p>Interfaces: <code>HasCustomSSAName</code>, <code>InnerSymbolOpInterface</code></p><h4 id=attributes-25>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr></tbody></table><h3 id=svinterfacemodport-circtsvinterfacemodportop><code>sv.interface.modport</code> (::circt::sv::InterfaceModportOp)</h3><p><em>Operation to define a SystemVerilog modport for interfaces</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.interface.modport` attr-dict $sym_name custom&lt;ModportStructs&gt;($ports)
</code></pre><p>This operation defines a named modport within an interface. Its name is a
symbol that can be looked up inside its parent interface. There is an array
of structs that contains two fields: an enum to indicate the direction of
the signal in the modport, and a symbol reference to refer to the signal.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@input_port</span> <span class=p>(</span>input <span class=nf>@data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>sv<span class=p>.</span>interface<span class=p>.</span>modport <span class=nf>@output_port</span> <span class=p>(</span>output <span class=nf>@data</span><span class=p>)</span>
</span></span></code></pre></div><p>Traits: <code>HasParent&lt;InterfaceOp></code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-26>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>ports</code></td><td>::mlir::ArrayAttr</td><td>array of modport structs</td></tr></table><h3 id=svinterfacesignal-circtsvinterfacesignalop><code>sv.interface.signal</code> (::circt::sv::InterfaceSignalOp)</h3><p><em>Operation to define a SystemVerilog signal for interfaces</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.interface.signal` attr-dict $sym_name `:` $type
</code></pre><p>This operation defines a named signal within an interface. Its type is
specified in an attribute, and currently supports IntegerTypes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>sv<span class=p>.</span>interface<span class=p>.</span>signal <span class=nf>@data</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>HasParent&lt;InterfaceOp></code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-27>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>Any SV/HW type</td></tr></table><h3 id=svinterfacesignalassign-circtsvassigninterfacesignalop><code>sv.interface.signal.assign</code> (::circt::sv::AssignInterfaceSignalOp)</h3><p><em>Assign an interfaces signal to some other signal.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.interface.signal.assign` $iface `(` custom&lt;IfaceTypeAndSignal&gt;(type($iface), $signalName) `)`
              `=` $rhs attr-dict `:` qualified(type($rhs))
</code></pre><p>Use this to continuously assign a signal inside an interface to a
value or other signal.</p><pre tabindex=0><code>  sv.interface.signal.assign %iface(@handshake_example::@data)
    = %zero32 : i32
</code></pre><p>Would result in the following SystemVerilog:</p><pre tabindex=0><code>  assign iface.data = zero32;
</code></pre><h4 id=attributes-28>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>signalName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=operands-22>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>iface</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>any type</td></tr></tbody></table><h3 id=svinterfacesignalread-circtsvreadinterfacesignalop><code>sv.interface.signal.read</code> (::circt::sv::ReadInterfaceSignalOp)</h3><p><em>Access the data in an interface&rsquo;s signal.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.interface.signal.read` $iface `(` custom&lt;IfaceTypeAndSignal&gt;(type($iface), $signalName) `)`
              attr-dict `:` qualified(type($signalData))
</code></pre><p>This is an expression to access a signal inside of an interface.</p><pre tabindex=0><code>  %ifaceData = sv.interface.signal.read %iface
      (@handshake_example::@data) : i32
</code></pre><p>Could result in the following SystemVerilog:</p><pre tabindex=0><code>  wire [31:0] ifaceData = iface.data;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-29>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>signalName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=operands-23>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>iface</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>signalData</code></td><td>any type</td></tr></tbody></table><h3 id=svlocalparam-circtsvlocalparamop><code>sv.localparam</code> (::circt::sv::LocalParamOp)</h3><p><em>Declare a localparam</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.localparam` `` custom&lt;ImplicitSSAName&gt;($name) attr-dict `:` qualified(type($result))
</code></pre><p>The localparam operation produces a <code>localparam</code> declaration. See SV spec
6.20.4 p125.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>FirstAttrDerivedResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-30>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::Attribute</td><td>any attribute</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element</td></tr></tbody></table><h3 id=svlogic-circtsvlogicop><code>sv.logic</code> (::circt::sv::LogicOp)</h3><p><em>Define a logic</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.logic` (`sym` $inner_sym^)? `` custom&lt;ImplicitSSAName&gt;($name) attr-dict
              `:` qualified(type($result))
</code></pre><p>Declare a SystemVerilog Variable Declaration of &rsquo;logic&rsquo; type.
See SV Spec 6.8, pp100.</p><p>Interfaces: <code>InnerSymbolOpInterface</code>, <code>OpAsmOpInterface</code></p><h4 id=attributes-31>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svmacrodecl-circtsvmacrodeclop><code>sv.macro.decl</code> (::circt::sv::MacroDeclOp)</h3><p><em>System verilog macro declaration</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.macro.decl` $sym_name (`[` $verilogName^ `]`)? (`(` $args^ `)`)?  attr-dict
</code></pre><p>The <code>sv.macro.def</code> declares a macro in System Verilog. This is a
declaration; the body of the macro, which produces a verilog macro
definition is created with a <code>macro.def</code> operation.</p><p>Lacking args will be a macro without &ldquo;()&rdquo;. An empty args will be an empty &ldquo;()&rdquo;.</p><p>The verilog name is the spelling of the macro when emitting verilog.</p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-32>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>args</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>verilogName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=svmacrodef-circtsvmacrodefop><code>sv.macro.def</code> (::circt::sv::MacroDefOp)</h3><p><em>System verilog macro definition</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.macro.def` $macroName $format_string (`(` $symbols^ `)`)? attr-dict
</code></pre><p>The <code>sv.macro.def</code> defines a macro in System Verilog which optionally takes
a body.</p><p>This is modeled similarly to verbatim in that the contents of the macro are
opaque (plain string). Given the general power of macros, this op does not
try to capture a return type.</p><p>This operation produces a definition for the macro declaration referenced by
<code>sym_name</code>. Argument lists are picked up from that operation.</p><p>sv.macro.def allows operand substitutions with {{0}} syntax.</p><p>Interfaces: <code>SymbolUserOpInterface</code></p><h4 id=attributes-33>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>macroName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>format_string</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>symbols</code></td><td>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></table><h3 id=svmacroref-circtsvmacrorefexprop><code>sv.macro.ref</code> (::circt::sv::MacroRefExprOp)</h3><p><em>Expression to refer to a SystemVerilog macro</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.macro.ref` $macroName `(` $inputs `)` attr-dict `:` functional-type($inputs, $result)
</code></pre><p>This operation produces a value by referencing a named macro.</p><p>Presently, it is assumed that the referenced macro is a constant with no
side effects. This expression is subject to CSE. It can be duplicated
and emitted inline by the Verilog emitter.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-34>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>macroName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=operands-24>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element or InOutType</td></tr></tbody></table><h3 id=svmacrorefse-circtsvmacrorefexprseop><code>sv.macro.ref.se</code> (::circt::sv::MacroRefExprSEOp)</h3><p><em>Expression to refer to a SystemVerilog macro</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.macro.ref.se` $macroName `(` $inputs `)` attr-dict `:` functional-type($inputs, $result)
</code></pre><p>This operation produces a value by referencing a named macro.</p><p>Presently, it is assumed that the referenced macro is not constant and has
side effects. This expression is not subject to CSE. It can not be
duplicated, but can be emitted inline by the Verilog emitter.</p><p>Interfaces: <code>HasCustomSSAName</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-35>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>macroName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=operands-25>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element or InOutType</td></tr></tbody></table><h3 id=svmodportget-circtsvgetmodportop><code>sv.modport.get</code> (::circt::sv::GetModportOp)</h3><p><em>Get a modport out of an interface instance</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.modport.get` $iface $field attr-dict `:` qualified(type($iface)) `-&gt;` qualified(type($result))
</code></pre><p>Use this to extract a modport view to an instantiated interface. For
example, to get the &lsquo;dataflow_in&rsquo; modport on the &lsquo;handshake_example&rsquo;
interface:</p><pre tabindex=0><code>%ifaceModport = sv.modport.get @dataflow_in %iface :
  !sv.interface&lt;@handshake_example&gt; -&gt;
  !sv.modport&lt;@handshake_example::@dataflow_in&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-36>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>field</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=operands-26>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>iface</code></td><td>SystemVerilog interface type pointing to an InterfaceOp</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>SystemVerilog type pointing to an InterfaceModportOp</td></tr></tbody></table><h3 id=svnonstandarddeposit-circtsvdepositop><code>sv.nonstandard.deposit</code> (::circt::sv::DepositOp)</h3><p><em><code>$deposit</code> system task</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.nonstandard.deposit` $dest `,` $src  attr-dict `:` qualified(type($src))
</code></pre><p>This system task sets the value of a net or variable, but doesn&rsquo;t hold it.
This is a common simulation vendor extension.</p><p>Traits: <code>ProceduralOp</code>, <code>VendorExtension</code></p><h4 id=operands-27>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>InOutType</td></tr><tr><td style=text-align:center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=svordered-circtsvorderedoutputop><code>sv.ordered</code> (::circt::sv::OrderedOutputOp)</h3><p><em>A sub-graph region which guarantees to output statements in-order</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.ordered` $body attr-dict
</code></pre><p>This operation groups operations into a region whose purpose is to force
verilog emission to be statement-by-statement, in-order. This allows
side-effecting operations, or macro expansions which applie to subsequent
operations to be properly sequenced.
This operation is for non-procedural regions and its body is non-procedural.</p><p>Traits: <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>NonProceduralOp</code>, <code>SingleBlock</code></p><h3 id=svpassign-circtsvpassignop><code>sv.passign</code> (::circt::sv::PAssignOp)</h3><p><em>Nonblocking procedural assignment</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.passign` $dest `,` $src  attr-dict `:` qualified(type($src))
</code></pre><p>A SystemVerilog nonblocking procedural assignment statement &lsquo;x &lt;= y;&rsquo;.
These occur in initial, always, task, and function blocks. The statement
can be scheduled without blocking procedural flow. See SV Spec 10.4.2.</p><p>Traits: <code>ProceduralOp</code></p><h4 id=operands-28>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>InOutType</td></tr><tr><td style=text-align:center><code>src</code></td><td>a valid inout element</td></tr></tbody></table><h3 id=svread_inout-circtsvreadinoutop><code>sv.read_inout</code> (::circt::sv::ReadInOutOp)</h3><p><em>Get the value of from something of inout type (e.g. a wire or inout port) as the value itself.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.read_inout` $input attr-dict `:` qualified(type($input))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-29>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>InOutType</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element</td></tr></tbody></table><h3 id=svreadmem-circtsvreadmemop><code>sv.readmem</code> (::circt::sv::ReadMemOp)</h3><p><em>Load a memory from a file in either binary or hex format</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.readmem` $dest `,` $filename `,` $base attr-dict `:` qualified(type($dest))
</code></pre><p>Load a memory from a file using either <code>$readmemh</code> or <code>$readmemb</code> based on
an attribute.</p><p>See Section 21.4 of IEEE 1800-2017 for more information.</p><p>Traits: <code>ProceduralOp</code></p><h4 id=attributes-37>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>filename</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>base</code></td><td>::MemBaseTypeAttrAttr</td><td>the numeric base of a memory file</td></tr></table><h4 id=operands-30>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>InOutType</td></tr></tbody></table><h3 id=svreg-circtsvregop><code>sv.reg</code> (::circt::sv::RegOp)</h3><p><em>Define a new <code>reg</code> in SystemVerilog</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.reg` (`init` $init^)? (`sym` $inner_sym^)? `` custom&lt;ImplicitSSAName&gt;($name) attr-dict
              `:` qualified(type($result))
              custom&lt;ImplicitInitType&gt;(ref(type($result)),ref($init), type($init))
</code></pre><p>Declare a SystemVerilog Variable Declaration of &lsquo;reg&rsquo; type.
See SV Spec 6.8, pp100.</p><p>Interfaces: <code>InnerSymbolOpInterface</code>, <code>OpAsmOpInterface</code></p><h4 id=attributes-38>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h4 id=operands-31>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>init</code></td><td>any type</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svrelease-circtsvreleaseop><code>sv.release</code> (::circt::sv::ReleaseOp)</h3><p><em>Release procedural statement</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.release` $dest attr-dict `:` qualified(type($dest))
</code></pre><p>Release is used in conjunction with force. When released,
then if the variable does not currently have an active assign
procedural continuous assignment, the variable shall not immediately
change value. The variable shall maintain its current value until
the next procedural assignment or procedural continuous assignment
to the variable. Releasing a variable that currently has an
active assign procedural continuous assignment shall immediately
reestablish that assignment. See SV Spec 10.6.2.</p><p>Traits: <code>ProceduralOp</code></p><h4 id=operands-32>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>InOutType</td></tr></tbody></table><h3 id=svstop-circtsvstopop><code>sv.stop</code> (::circt::sv::StopOp)</h3><p><em><code>$stop</code> system task</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.stop` $verbosity attr-dict
</code></pre><p>Causes the simulation to be suspended. Does not terminate the simulator.</p><p>The optional <code>verbosity</code> parameter controls how much diagnostic information
is printed when the system task is executed (see section 20.2 of IEEE
1800-2017):</p><ul><li><code>0</code>: Prints nothing</li><li><code>1</code>: Prints simulation time and location (default)</li><li><code>2</code>: Prints simulation time, location, and statistics about the memory and
CPU time used in simulation</li></ul><p>Traits: <code>ProceduralOp</code></p><h4 id=attributes-39>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>verbosity</code></td><td>::mlir::IntegerAttr</td><td>8-bit signless integer attribute whose minimum value is 0 whose maximum value is 2</td></tr></table><h3 id=svstruct_field_inout-circtsvstructfieldinoutop><code>sv.struct_field_inout</code> (::circt::sv::StructFieldInOutOp)</h3><p><em>Create an subfield inout memory to produce an inout element.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.struct_field_inout` $input `[` $field `]` attr-dict `:` qualified(type($input))
</code></pre><p>See SV Spec 7.2.
Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-40>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>field</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-33>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>an inout type with struct field</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svsystem-circtsvsystemfunctionop><code>sv.system</code> (::circt::sv::SystemFunctionOp)</h3><p><em>Simple SV System Function calls</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.system` $fnName `(` $args `)` attr-dict `:` functional-type($args, $out)
</code></pre><p>This operation calls the indicated system verilog system function. This
supports functions which take normal expression arguments.</p><p>See section 20 of the 2012 SV spec.</p><h4 id=attributes-41>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fnName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-34>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>any type</td></tr></tbody></table><h3 id=svsystemsampled-circtsvsampledop><code>sv.system.sampled</code> (::circt::sv::SampledOp)</h3><p><em><code>$sampled</code> system function to sample a value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.system.sampled` $expression attr-dict `:` qualified(type($expression))
</code></pre><p>Sample a value using System Verilog sampling semantics (see Section 16.5.1
of the SV 2017 specification for more information).</p><p>A use of <code>$sampled</code> is to safely read the value of a net/variable in a
concurrent assertion action block such that the value will be the same as
the value used when the assertion is triggered. See Section 16.9.3 of the
SV 2017 specification for more information.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-35>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>expression</code></td><td>any type</td></tr></tbody></table><h4 id=results-17>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sampledValue</code></td><td>any type</td></tr></tbody></table><h3 id=svverbatim-circtsvverbatimop><code>sv.verbatim</code> (::circt::sv::VerbatimOp)</h3><p><em>Verbatim opaque text emitted inline.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.verbatim` $format_string (`(` $substitutions^ `)` `:`
              qualified(type($substitutions)))? attr-dict
</code></pre><p>This operation produces opaque text inline in the SystemVerilog output.</p><p>sv.verbatim allows operand substitutions with {{0}} syntax.</p><h4 id=attributes-42>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>format_string</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>symbols</code></td><td>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></table><h4 id=operands-36>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=svverbatimexpr-circtsvverbatimexprop><code>sv.verbatim.expr</code> (::circt::sv::VerbatimExprOp)</h3><p><em>Expression that expands to a value given SystemVerilog text</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.verbatim.expr` $format_string (`(` $substitutions^ `)`)?
              `:` functional-type($substitutions, $result) attr-dict
</code></pre><p>This operation produces a typed value expressed by a string of
SystemVerilog. This can be used to access macros and other values that are
only sensible as Verilog text.</p><p>The text string is expected to have the highest precedence, so you should
include parentheses in the string if it isn&rsquo;t a single token. This is also
assumed to not have side effects (use sv.verbatim.expr.se) if you need them.</p><p>sv.verbatim.expr allows operand substitutions with {{0}} syntax.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>HasCustomSSAName</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-43>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>format_string</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>symbols</code></td><td>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></table><h4 id=operands-37>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-18>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element or InOutType</td></tr></tbody></table><h3 id=svverbatimexprse-circtsvverbatimexprseop><code>sv.verbatim.expr.se</code> (::circt::sv::VerbatimExprSEOp)</h3><p><em>Expression that expands to a value given SystemVerilog text</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.verbatim.expr.se` $format_string (`(` $substitutions^ `)`)?
              `:` functional-type($substitutions, $result) attr-dict
</code></pre><p>This operation produces a typed value expressed by a string of
SystemVerilog. This can be used to access macros and other values that are
only sensible as Verilog text.</p><p>The text string is expected to have the highest precedence, so you should
include parentheses in the string if it isn&rsquo;t a single token. This is
allowed to have side effects.</p><p>sv.verbatim.se.expr allows operand substitutions with {{0}} syntax.</p><p>Interfaces: <code>HasCustomSSAName</code></p><h4 id=attributes-44>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>format_string</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>symbols</code></td><td>::mlir::ArrayAttr</td><td>name reference array attribute</td></tr></table><h4 id=operands-38>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-19>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a known primitive element or InOutType</td></tr></tbody></table><h3 id=svwarning-circtsvwarningop><code>sv.warning</code> (::circt::sv::WarningOp)</h3><p><em><code>$warning</code> severity message task</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.warning` ($message^ (`(` $substitutions^ `)` `:` qualified(type($substitutions)))?)?
              attr-dict
</code></pre><p>This system task indicates a run-time warning.</p><p>If present, the optional message is printed with any additional operands
interpolated into the message string.</p><p>Traits: <code>ProceduralOp</code></p><h4 id=attributes-45>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-39>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>substitutions</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=svwire-circtsvwireop><code>sv.wire</code> (::circt::sv::WireOp)</h3><p><em>Define a new wire</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.wire` (`sym` $inner_sym^)? `` custom&lt;ImplicitSSAName&gt;($name) attr-dict
              `:` qualified(type($result))
</code></pre><p>Declare a SystemVerilog Net Declaration of &lsquo;wire&rsquo; type.
See SV Spec 6.7, pp97.</p><p>Traits: <code>NonProceduralOp</code></p><p>Interfaces: <code>InnerSymbolOpInterface</code>, <code>OpAsmOpInterface</code></p><h4 id=attributes-46>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h4 id=results-20>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svxmr-circtsvxmrop><code>sv.xmr</code> (::circt::sv::XMROp)</h3><p><em>Encode a reference to a non-local net.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.xmr` (`isRooted` $isRooted^)? custom&lt;XMRPath&gt;($path, $terminal) attr-dict `:` qualified(type($result))
</code></pre><p>This represents a non-local hierarchical name to a net, sometimes called a
cross-module reference. A hierarchical name may be absolute, when prefixed
with &lsquo;$root&rsquo;, in which case it is resolved from the set of top-level modules
(any non-instantiated modules). Non-absolute paths are resolved by
attempting resolution of the path locally, then recursively up the instance
graph. See SV Spec 23.6, pp721.</p><p>It is impossible to completely resolve a hierarchical name without making a
closed-world assumption in the compiler. We therefore don&rsquo;t try to link
hierarchical names to what they resolve to at compile time. A frontend
generating this op should ensure that any instance or object in the intended
path has public visibility so paths are not invalidated.</p><h4 id=attributes-47>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>isRooted</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>path</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>terminal</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-21>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>InOutType</td></tr></tbody></table><h3 id=svxmrref-circtsvxmrrefop><code>sv.xmr.ref</code> (::circt::sv::XMRRefOp)</h3><p><em>Encode a reference to something with a hw.hierpath.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `sv.xmr.ref` $ref ( $verbatimSuffix^ )? attr-dict `:` qualified(type($result))
</code></pre><p>This represents a hierarchical path, but using something which the compiler
can understand. In contrast to the XMROp (which models pure Verilog
hierarchical paths which may not map to anything knowable in the circuit),
this op uses a <code>hw.hierpath</code> to refer to something which exists in the
circuit.</p><p>Generally, this operation is always preferred for situations where
hierarchical paths cannot be known statically and may change.</p><p><code>verbatimSuffix</code> should only be populated when the final operation on the
path is an instance of an external module.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-48>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>ref</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>verbatimSuffix</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-22>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>InOutType</td></tr></tbody></table><h2 id=attributes-49>Attributes</h2><h3 id=macroidentattr>MacroIdentAttr</h3><p>Macro identifier</p><p>Syntax:</p><pre tabindex=0><code>#sv.macro.ident&lt;
  ::mlir::FlatSymbolRefAttr   # ident
&gt;
</code></pre><p>Represents a reference to a macro identifier.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>ident</td><td style=text-align:center><code>::mlir::FlatSymbolRefAttr</code></td><td></td></tr></tbody></table><h3 id=modportdirectionattr>ModportDirectionAttr</h3><p>Defines direction in a modport</p><p>Syntax:</p><pre tabindex=0><code>#sv.modport_direction&lt;
  ::circt::sv::ModportDirection   # value
&gt;
</code></pre><p>Enum cases:</p><ul><li>input (<code>input</code>)</li><li>output (<code>output</code>)</li><li>inout (<code>inout</code>)</li></ul><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::circt::sv::ModportDirection</code></td><td>an enum of type ModportDirection</td></tr></tbody></table><h3 id=modportstructattr>ModportStructAttr</h3><p>Syntax:</p><pre tabindex=0><code>#sv.mod_port&lt;
  ::circt::sv::ModportDirectionAttr,   # direction
  mlir::FlatSymbolRefAttr   # signal
&gt;
</code></pre><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>direction</td><td style=text-align:center><code>::circt::sv::ModportDirectionAttr</code></td><td></td></tr><tr><td style=text-align:center>signal</td><td style=text-align:center><code>mlir::FlatSymbolRefAttr</code></td><td></td></tr></tbody></table><h3 id=svattributeattr>SVAttributeAttr</h3><p>a Verilog Attribute</p><p>This attribute is used to encode a Verilog <em>attribute</em>. A Verilog attribute
(not to be confused with an LLVM or MLIR attribute) is a syntactic mechanism
for adding metadata to specific declarations, statements, and expressions in
the Verilog language. <em>There are no &ldquo;standard&rdquo; attributes</em>. Specific tools
define and handle their own attributes.</p><p>Verilog attributes have a mandatory name and an optional constant
expression. This is encoded as a key (name) value (expression) pair.
Multiple attributes may be specified, either with multiple separate
attributes or by comman-separating name&ndash;expression pairs.</p><p>Currently, SV attributes don&rsquo;t block most optimizations; therefore, users should
not expect that sv attributes always appear in the output verilog.
However, we must block optimizations that updating ops in-place
since it is mostly invalid to transfer SV attributes one to another.</p><p>For more information, refer to Section 5.12 of the SystemVerilog (1800-2017)
specification.</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>name</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>expression</td><td style=text-align:center><code>::mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>emitAsComment</td><td style=text-align:center><code>mlir::BoolAttr</code></td><td></td></tr></tbody></table><h3 id=validationqualifiertypeenumattr>ValidationQualifierTypeEnumAttr</h3><p>validation qualifier type</p><p>Syntax:</p><pre tabindex=0><code>#sv.validation_qualifier&lt;
  ::circt::sv::ValidationQualifierTypeEnum   # value
&gt;
</code></pre><p>Enum cases:</p><ul><li>plain (<code>ValidationQualifierPlain</code>)</li><li>unique (<code>ValidationQualifierUnique</code>)</li><li>unique0 (<code>ValidationQualifierUnique0</code>)</li><li>priority (<code>ValidationQualifierPriority</code>)</li></ul><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::circt::sv::ValidationQualifierTypeEnum</code></td><td>an enum of type ValidationQualifierTypeEnum</td></tr></tbody></table><h2 id=types>Types</h2><h3 id=interfacetype>InterfaceType</h3><p>SystemVerilog interface type pointing to an InterfaceOp</p><p>Syntax:</p><pre tabindex=0><code>!sv.interface&lt;
  ::mlir::FlatSymbolRefAttr   # interface
&gt;
</code></pre><p>A MLIR type for the SV dialect&rsquo;s <code>InterfaceOp</code> to allow instances in any
dialect with an open type system. Points at the InterfaceOp which defines
the SystemVerilog interface.</p><h4 id=parameters-5>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>interface</td><td style=text-align:center><code>::mlir::FlatSymbolRefAttr</code></td><td></td></tr></tbody></table><h3 id=modporttype>ModportType</h3><p>SystemVerilog type pointing to an InterfaceModportOp</p><p>Syntax:</p><pre tabindex=0><code>!sv.modport&lt;
  ::mlir::SymbolRefAttr   # modport
&gt;
</code></pre><p>A MLIR type for the SV dialect&rsquo;s <code>InterfaceModportOp</code> to allow
interactions with any open type system dialect. Points at the
InterfaceModportOp which defines the SystemVerilog interface&rsquo;s modport.</p><h4 id=parameters-6>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>modport</td><td style=text-align:center><code>::mlir::SymbolRefAttr</code></td><td></td></tr></tbody></table><h2>'sv' Dialect Docs</h2><ul><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/ title="SSP Dialect Rationale"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - SSP Dialect Rationale</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/ title="SV Dialect Rationale">Next - SV Dialect Rationale <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class="active has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>