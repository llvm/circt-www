<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Seq(uential) Dialect Rationale - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>Seq(uential) Dialect Rationale</h1><p>This document describes various design points of the <code>seq</code> dialect, why it is
the way it is, and current status. This follows in the spirit of other
<a href=https://mlir.llvm.org/docs/Rationale/>MLIR
Rationale docs</a>.</p><h2 id=introduction>Introduction&nbsp;<a class=headline-hash href=#introduction>¶</a></h2><p>Digital logic is generally split into two categories: combinational and
sequential. CIRCT contains a <code>comb</code> dialect to model the basic combinational
operations and the (future) <code>seq</code> dialect which is discussed here. The
intention of the <code>seq</code> dialect is to provide a set of stateful constructs
which can be used to model sequential logic, independent of the output method
(e.g. SystemVerilog).</p><h2 id=definitions>Definitions&nbsp;<a class=headline-hash href=#definitions>¶</a></h2><p>For the sake of precision, we use the following definitions:</p><ul><li>Physical devices:<ul><li><strong>Unclocked Latch:</strong> A memory element which is only sensitive to the
levels of its inputs. Has no clock. Example: SR Latch.</li><li>Clocked (gated) <strong>latch:</strong> A latch wherein the inputs are gated by a
clock. Transparent the entire time the clock is high. Generally referred to
as a &ldquo;latch&rdquo;. Examples: &ldquo;gated SR latch&rdquo;, &ldquo;D latch&rdquo;.</li><li>Edge-triggered <strong>flip-flop:</strong> An edge-sensitive memory element. Captures
the input value on one or both clock edges. Variants: posedge FF, negedge
FF, &ldquo;edge-sensitive&rdquo; FF (captures the input value on both edges),
resettable FF.</li></ul></li><li>Abstract models:<ul><li><strong>Register:</strong> A synchronous, resettable memory element. Can be
implemented using any of the above &ldquo;circuit level&rdquo; elements.</li></ul></li></ul><h2 id=the-computational-register-operation>The computational register operation&nbsp;<a class=headline-hash href=#the-computational-register-operation>¶</a></h2><p>The <code>seq.compreg</code> op models an abstract notion of a &ldquo;register&rdquo;, independent
of its implementation (e.g. latch, D flip-flop). This specific register op is
intended to support &ldquo;computation support&rdquo; or &ldquo;reset-agnostic code&rdquo; and thus
it cannot be used to model all the behaviors of a SystemVerilog register.
(E.g. FSM and pipeline registers.) It is intended to be &rsquo;lowered&rsquo; to a
specific implementation, which may be an <code>sv.always_ff</code> block, a device
primitive instantiation, or even a feedback loop in all <code>comb</code> logic.</p><p>Our intention is to allow analysis and optimization of sequential logic
without having to reason about implementation-specific behavior. This makes
it somewhat distinct from the SystemVerilog register wherein one has to
account for details like reset behavior and implementation (latch vs.
flip-flop).</p><p><code>CompReg</code> has four operands:</p><ul><li><strong>input</strong>: The value to be captured at &lsquo;clock&rsquo;. Generally called &rsquo;d&rsquo;.
Accepts any type, results in the same type. Does not support any notion of
addressing, meaning that this operation sets / reads the entire value.</li><li><strong>clock</strong>: Capture &lsquo;value&rsquo; on the positive edge of this signal.</li><li><strong>reset</strong>: Signal to set the state to &lsquo;resetValue&rsquo;. Optional.</li><li><strong>resetValue</strong>: A value which the state is set to upon reset. Required iff
&lsquo;reset&rsquo; is present.</li><li><strong>powerOn</strong>: A value which will be assigned to the register upon system power-on.</li><li><strong>name</strong>: A name for the register, defaults to <code>""</code>. Inferred from the textual
SSA value name, or passed explicitly in builder APIs. The name will be passed to
the <code>sv.reg</code> during lowering.</li><li><strong>innerSym</strong>: An optional symbol to refer to the register. The symbol will be
passed to the <code>sv.reg</code> during lowering if present.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%q</span> <span class=p>=</span> seq<span class=p>.</span>compreg <span class=nv>%input</span><span class=p>,</span> <span class=nv>%clk</span> <span class=p>[</span> reset <span class=nv>%reset</span><span class=p>,</span> <span class=nv>%resetValue</span> <span class=p>]</span> <span class=p>[</span>powerOn <span class=nv>%powerOn</span><span class=p>]</span> <span class=p>:</span> <span class=err>$</span>type<span class=p>(</span>input<span class=p>)</span>
</span></span></code></pre></div><p>Upon initialization, the state is defined to be uninitialized.</p><h3 id=variant-seqcompregce>Variant: <code>seq.compreg.ce</code>&nbsp;<a class=headline-hash href=#variant-seqcompregce>¶</a></h3><p>This op is a version of compreg with the addition of a clock enable signal.
Having the clock enable explicit (instead of a mux feeding it) is convenient for
mapping to SV behavioral and will be (in the future) easier to map to device
primitives or standard cells.</p><h3 id=rationale>Rationale&nbsp;<a class=headline-hash href=#rationale>¶</a></h3><p>Several design decisions were made in defining this op. Mostly, they were
made to simplify it while still providing the common case. Providing support
for all flavors of registers is an anti-goal of this op. If an omitted
feature is needed, it can be added or (if not common or precludes
optimization) another op could be added.</p><ul><li><p>Logical features:</p><ul><li>Inclusion of optional &lsquo;reset&rsquo; signal: This operand makes lowering to an
efficient implementation of reset easier. Omission of it would require some
(potentially complex) analysis to find the reset mux if required</li><li>Inclusion of &lsquo;resetValue&rsquo;: if we have a &lsquo;reset&rsquo; signal, we need to
include a value.</li></ul></li><li><p>Timing / clocking:</p><ul><li>Omission of &rsquo;negedge&rsquo; event on &lsquo;clock&rsquo;: this is easily modeled by
inverting the clock value.</li><li>Omission of &lsquo;dual edge&rsquo; event on &lsquo;clock&rsquo;: this is not expected to be
terribly common.</li><li>Omission of edge conditions on &lsquo;reset&rsquo;: Since this op specifically
targets &ldquo;reset-agnostic code&rdquo;, the reset style shouldn&rsquo;t affect logical
correctness. It should, therefore, be determined by a lowering pass.</li></ul></li></ul><h2 id=the-firrtl-register-operation-provisional>The FIRRTL register operation [Provisional]&nbsp;<a class=headline-hash href=#the-firrtl-register-operation-provisional>¶</a></h2><p>The <code>seq.firreg</code> carries all the information required to represent a FIRRTL
register and lower it to SystemVerilog.</p><p><code>FirReg</code> has the following operands:</p><ul><li><strong>input</strong>: Value to set the register to on the positive edge of the clock
signal.</li><li><strong>clk</strong>: Clock signal driving the register.</li><li><strong>name</strong>: A name for the register, passed directly to the <code>sv.reg</code>.</li><li><strong>inner_sym</strong>: A optional symbol for the register, passed directly to the
<code>sv.reg</code>. Is a symbol is not specified and the register is randomised, one is
created during the lowering to SV. Registers without symbols can be removed
from the design.</li><li><strong>reset</strong>: Signal to trigger the reset.</li><li><strong>resetValue</strong>: A value which is set upon reset. Must be a constant if the
reset is asynchronous.</li><li><strong>isAsync</strong>: Optional boolean flag indicating whether the reset is
asynchronous.</li><li><strong>preset</strong>: Optional attribute specifying a preset value. If no preset
attribute is present, the register is random-initialized.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%reg</span> <span class=p>=</span> seq<span class=p>.</span>firreg <span class=nv>%input</span> clock <span class=nv>%clk</span> <span class=p>[</span> sym <span class=nf>@sym</span> <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span> reset <span class=p>(</span>sync<span class=err>|</span>async<span class=p>)</span> <span class=nv>%reset</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span> preset value <span class=p>]</span> <span class=p>:</span> <span class=err>$</span>type<span class=p>(</span>input<span class=p>)</span>
</span></span></code></pre></div><p>Examples of registers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%reg_no_reset</span> <span class=p>=</span> seq<span class=p>.</span>firreg <span class=nv>%input</span> clock <span class=nv>%clk</span> sym <span class=nf>@sym</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%reg_sync_reset_rand</span>  <span class=p>=</span> seq<span class=p>.</span>firreg <span class=nv>%input</span> clock <span class=nv>%clk</span> sym <span class=nf>@sym</span>
</span></span><span class=line><span class=cl>    reset sync <span class=nv>%reset</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%reg_async_reset</span> <span class=p>=</span> seq<span class=p>.</span>firreg <span class=nv>%input</span> clock <span class=nv>%clk</span> sym <span class=nf>@sym</span>
</span></span><span class=line><span class=cl>    reset async <span class=nv>%reset</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span> <span class=k>i1</span>f
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%reg_preset</span> <span class=p>=</span> seq<span class=p>.</span>firreg <span class=nv>%next</span> clock <span class=nv>%clock</span> preset <span class=m>123</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>A register without a reset lowers directly to an always block:</p><pre tabindex=0><code>always @(posedge clk or [posedge reset]) begin
  a &lt;= [%input]
end
</code></pre><p>In the presence of a reset, an if statement and an always block with the
proper triggers are emitted:</p><pre tabindex=0><code>always @(posedge clk or [posedge reset]) begin
  if ([%reset])
    a &lt;= [%resetValue]
  else
    a &lt;= [%input]
end
</code></pre><p>Additionally, <code>sv</code> operations are also included to provide the register with
a randomized preset value or an explicit preset constant.
Since items assigned in an <code>always_ff</code> block cannot be initialised in an
<code>initial</code> block, this register lowers to <code>always</code>.</p><pre tabindex=0><code>`ifndef SYNTHESIS
  `ifdef RANDOMIZE_REG_INIT
    reg [31:0] _RANDOM;
  `endif
  initial begin
    `INIT_RANDOM_PROLOG_
    `ifdef RANDOMIZE_REG_INIT
      _RANDOM = {`RANDOM};
      a = _RANDOM;
    `endif
  end
`endif
</code></pre><p>Registers expect the logic assignment to them to be in SSA form.
For example, a strict connect to a field of a structure:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>%field = firrtl.subfield %a[field]
firrtl.strictconnect %field, %value
</code></pre><p>Is converted into a <code>hw.struct_inject</code> operation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%reg</span> <span class=p>=</span> seq<span class=p>.</span>firreg <span class=nv>%value</span> clock <span class=nv>%clk</span> sym <span class=nf>@sym</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%value</span> <span class=p>=</span> hw<span class=p>.</span>struct_inject <span class=nv>%reg</span><span class=p>[</span><span class=s>&#34;x&#34;</span><span class=p>],</span> <span class=nv>%value</span>
</span></span></code></pre></div><p>In order to avoid generating unnecessary assignments, the lowering of the
register to <code>sv</code> eliminates the SSA form and emits a single parallel assignment
to the field (<code>reg.x = value</code>).</p><h3 id=rationale-1>Rationale&nbsp;<a class=headline-hash href=#rationale-1>¶</a></h3><p>A register specific for FIRRTL is desired as it has a specific lowering while
also requiring a preset value and asynchronous resets.
The lowering must also be compatible with the reference FIRRTL lowering, which
might diverge from the lowering of the computation register.</p><h3 id=future-considerations>Future considerations&nbsp;<a class=headline-hash href=#future-considerations>¶</a></h3><ul><li>Enable signal: if this proves difficult to detect (or non-performant if we
do not detect and generate the SystemVerilog correctly), we can build it into
the compreg op.</li><li>Reset style and clock style: how should we model posedge vs negedge clocks?
Async vs sync resets? There are some reasonable options here: attributes on
this op or <code>clock</code> and <code>reset</code> types which are parameterized with that
information.</li><li>Initial value: this register is uninitialized. Using an uninitialized value
results in undefined behavior. We will add an <code>initialValue</code> attribute if
this proves insufficient.</li></ul><h2 id=the-high-level-memory-abstraction>The High-Level Memory Abstraction&nbsp;<a class=headline-hash href=#the-high-level-memory-abstraction>¶</a></h2><p>The <code>seq.hlmem</code> (high-level memory operation) intends to capture the semantics
of a memory which eventually map to some form on-chip resources - whether being
FPGA or ASIC-based.
The abstraction aims to abstract away the physical implementation details of the
memory, and instead focus on the external interface and access semantics of the
memory. this, in turn, facilitates analysis and transformation (e.g. memory
merging, read/write conflicts, etc.) and may serve as a target for other
high-level abstractions.</p><p>The high-level memory abstraction is split into two parts:</p><ul><li>Memory <em>allocation</em> is defined by the <code>seq.hlmem</code> operation. This operation
defines the internal memory structure. For now, this strictly pertains to the
layout of the memory (dimensionality) and element type.</li><li>Memory <em>access</em> is defined by separate port operations which reference the
allocated memory. Port access operations are defined at the same level of
abstraction as the core RTL dialects and contain no notion of control
flow. As such, for e.g. a write port with a non-zero latency, the encapsulating
IR must already have accounted for this latency.
The behavior of conflicting writes is defined by the lowering. Generally speaking, it should be considered as undefined.</li></ul><p>Example usage:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>%myMemory</span> <span class=p>=</span> seq<span class=p>.</span>hlmem <span class=nf>@myMemory</span> <span class=nv>%clk</span> <span class=p>:</span> <span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c0_i2</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i2</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c1_i1</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c42_i32</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%myMemory_rdata</span> <span class=p>=</span> seq<span class=p>.</span>read <span class=nv>%myMemory</span><span class=p>[</span><span class=nv>%c0_i2</span><span class=p>]</span> rden <span class=nv>%c1_i1</span> <span class=p>{</span> <span class=nl>latency =</span> <span class=m>0</span><span class=p>}</span> <span class=p>:</span> <span class=p>!</span>seq<span class=p>.</span>hlmem<span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  seq<span class=p>.</span>write <span class=nv>%myMemory</span><span class=p>[</span><span class=nv>%c0_i2</span><span class=p>]</span> <span class=nv>%c42_i32</span> wren <span class=nv>%c1_i1</span> <span class=p>{</span> <span class=nl>latency =</span> <span class=m>1</span> <span class=p>}</span> <span class=p>:</span> <span class=p>!</span>seq<span class=p>.</span>hlmem<span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Lowering the op is intended to be performed by matching on the <code>seq.hlmem</code>,
collecting the port ops which access the memory, and based on this
perform a lowering to an appropriate memory structure. This memory
could either be behavioral (able to support any combination of memory allocation
and port accesses) or specialized (e.g. specifically target FPGA resources,
call a memory compiler, &mldr; which may only be possible for a subset of
allocation and access combinations).</p><h3 id=rationale-2>Rationale&nbsp;<a class=headline-hash href=#rationale-2>¶</a></h3><p>The high-level memory abstraction, as presented here, represents a useful
albeit limited abstraction when considering the complexity of instantiating
memory resources in both FPGAs and ASICs.</p><p>The scope of what the <code>hlmem</code> operations can represent is large. Examples
being: multidimensional memories, arbitrary # of read/write ports, and mixed
port latencies (all of which could occur together).<br>In reality, it will only be a limited subset of the possible combinations of
these operations which can be lowered reasonably to an FPGA or ASIC implementation.<br>However, by allowing for such complexity, we ensure that we have a unified IR
which can represent such varying levels of complexity, thus ensuring maximum
reusability of analysis and transformation passes.</p><h3 id=future-considerations-1>Future considerations&nbsp;<a class=headline-hash href=#future-considerations-1>¶</a></h3><h4 id=port-refinements><strong>Port refinements</strong>&nbsp;<a class=headline-hash href=#port-refinements>¶</a></h4><p>The main design decision of <code>seq.hlmem</code> is the choice of abstracting away
the structural details of a port into separate ops of which we currently
only provide rudimentary read- and write ops.
Example future ports could be:</p><ul><li><strong>Asymmetric port widths</strong>
Specified as a new <code>seq.asym_read</code> port which defines a read data width
of some fraction of the native data size.<div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%rdata</span> <span class=p>=</span> seq<span class=p>.</span>asym_read <span class=nv>%rp</span><span class=p>[</span><span class=nv>%addr</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>seq<span class=p>.</span>hlmem<span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>i16</span>
</span></span></code></pre></div>which would then put different typing requirements on the <code>%addr</code> signal.
Given the halfing of the word size, the expected address type would then
be <code>ceil(log2(4)) &lt;&lt; 1 = i3</code></li><li><strong>Byte-enable write ports</strong>
Specified as a new <code>seq.write_be</code> port with an additional byte enable
signal.<div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%wdata</span> <span class=p>=</span> seq<span class=p>.</span>write_be <span class=nv>%wp</span><span class=p>[</span><span class=nv>%addr</span><span class=p>]</span> <span class=nv>%wdata</span><span class=p>,</span> <span class=nv>%be</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i4</span> <span class=p>-&gt;</span> <span class=p>!</span>seq<span class=p>.</span>hlmem<span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div></li><li><strong>Debug ports</strong>
Could be specified as either an additional read port, or (if further
specialization is needed) attached to the memory symbol.<div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%mem</span> <span class=p>=</span> seq<span class=p>.</span>debug <span class=nf>@myMemory</span> <span class=p>:</span> <span class=p>!</span>seq<span class=p>.</span>hlmem<span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div></li></ul><h2 id=the-fifo-operation>The FIFO operation&nbsp;<a class=headline-hash href=#the-fifo-operation>¶</a></h2><p>The <code>seq.fifo</code> operation intends to capture the semantics of a FIFO which
eventually map to some form of on-chip resources. By having a FIFO abstraction,
we provide an abstraction that can be targeted for target-specialized implementations,
as well as default behavioral lowerings (based on <code>seq.hlmem</code>).</p><p>The FIFO interface consists of:</p><ul><li><strong>Inputs</strong>:<ul><li>clock, reset</li><li>input data</li><li>read/write enable</li></ul></li><li><strong>Outputs</strong>:<ul><li>output data</li><li>full, empty flags</li><li>optional almost full, almost empty flags</li></ul></li></ul><p>The fifo operation is configurable with the following parameters:</p><ol><li>Depth (cycles)</li><li>Differing in- and output widths</li><li>Almost empty/full thresholds (optional)</li></ol><p>Like <code>seq.hlmem</code> there are no guarantees that all possible fifo configuration
are able to be lowered. Available lowering passes will pattern match on the
requested fifo configuration and attempt to provide a legal lowering.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/Seq/ title="'seq' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'seq' Dialect</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/Sim/ title="'sim' Dialect">Next - 'sim' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark opened">-</span></a><ul class=sub-menu><li class=active><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>