<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'seq' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/Seq/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'seq' Dialect</h1><p>Types and operations for seq dialect
The <code>seq</code> dialect is intended to model digital sequential logic.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#seqclock_div-circtseqclockdividerop><code>seq.clock_div</code> (::circt::seq::ClockDividerOp)</a></li><li><a href=#seqclock_gate-circtseqclockgateop><code>seq.clock_gate</code> (::circt::seq::ClockGateOp)</a></li><li><a href=#seqclock_inv-circtseqclockinverterop><code>seq.clock_inv</code> (::circt::seq::ClockInverterOp)</a></li><li><a href=#seqclock_mux-circtseqclockmuxop><code>seq.clock_mux</code> (::circt::seq::ClockMuxOp)</a></li><li><a href=#seqcompreg-circtseqcompregop><code>seq.compreg</code> (::circt::seq::CompRegOp)</a></li><li><a href=#seqcompregce-circtseqcompregclockenabledop><code>seq.compreg.ce</code> (::circt::seq::CompRegClockEnabledOp)</a></li><li><a href=#seqconst_clock-circtseqconstclockop><code>seq.const_clock</code> (::circt::seq::ConstClockOp)</a></li><li><a href=#seqfifo-circtseqfifoop><code>seq.fifo</code> (::circt::seq::FIFOOp)</a></li><li><a href=#seqfirmem-circtseqfirmemop><code>seq.firmem</code> (::circt::seq::FirMemOp)</a></li><li><a href=#seqfirmemread_port-circtseqfirmemreadop><code>seq.firmem.read_port</code> (::circt::seq::FirMemReadOp)</a></li><li><a href=#seqfirmemread_write_port-circtseqfirmemreadwriteop><code>seq.firmem.read_write_port</code> (::circt::seq::FirMemReadWriteOp)</a></li><li><a href=#seqfirmemwrite_port-circtseqfirmemwriteop><code>seq.firmem.write_port</code> (::circt::seq::FirMemWriteOp)</a></li><li><a href=#seqfirreg-circtseqfirregop><code>seq.firreg</code> (::circt::seq::FirRegOp)</a></li><li><a href=#seqfrom_clock-circtseqfromclockop><code>seq.from_clock</code> (::circt::seq::FromClockOp)</a></li><li><a href=#seqhlmem-circtseqhlmemop><code>seq.hlmem</code> (::circt::seq::HLMemOp)</a></li><li><a href=#seqread-circtseqreadportop><code>seq.read</code> (::circt::seq::ReadPortOp)</a></li><li><a href=#seqshiftreg-circtseqshiftregop><code>seq.shiftreg</code> (::circt::seq::ShiftRegOp)</a></li><li><a href=#seqto_clock-circtseqtoclockop><code>seq.to_clock</code> (::circt::seq::ToClockOp)</a></li><li><a href=#seqwrite-circtseqwriteportop><code>seq.write</code> (::circt::seq::WritePortOp)</a></li></ul></li><li><a href=#attributes-12>Attributes</a><ul><li><a href=#clockconstattr>ClockConstAttr</a></li><li><a href=#firmeminitattr>FirMemInitAttr</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#clocktype>ClockType</a></li><li><a href=#firmemtype>FirMemType</a></li><li><a href=#hlmemtype>HLMemType</a></li></ul></li></ul></nav><h2 id=operations>Operations</h2><h3 id=seqclock_div-circtseqclockdividerop><code>seq.clock_div</code> (::circt::seq::ClockDividerOp)</h3><p><em>Produces a clock divided by a power of two</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.clock_div` $clockIn `by` $pow2 attr-dict
</code></pre><p>The output clock is phase-aligned to the input clock.</p><pre tabindex=0><code>%div_clock = seq.clock_div %clock by 1
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pow2</code></td><td>::mlir::IntegerAttr</td><td>8-bit signless integer attribute</td></tr></table><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clockIn</code></td><td>A type for clock-carrying wires</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clockOut</code></td><td>A type for clock-carrying wires</td></tr></tbody></table><h3 id=seqclock_gate-circtseqclockgateop><code>seq.clock_gate</code> (::circt::seq::ClockGateOp)</h3><p><em>Safely gates a clock with an enable signal</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.clock_gate` $input `,` $enable (`,` $test_enable^)? (`sym` $inner_sym^)? attr-dict
</code></pre><p>The <code>seq.clock_gate</code> enables and disables a clock safely, without glitches,
based on a boolean enable value. If the enable operand is 1, the output
clock produced by the clock gate is identical to the input clock. If the
enable operand is 0, the output clock is a constant zero.</p><p>The <code>enable</code> operand is sampled at the rising edge of the input clock; any
changes on the enable before or after that edge are ignored and do not
affect the output clock.</p><p>The <code>test_enable</code> operand is optional and if present is OR&rsquo;d together with
the <code>enable</code> operand to determine whether the output clock is gated or not.</p><p>The op can be referred to using an inner symbol. Upon translation, the
symbol will target the instance to the external module it lowers to.</p><pre tabindex=0><code>%gatedClock = seq.clock_gate %clock, %enable
%gatedClock = seq.clock_gate %clock, %enable, %test_enable
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>InnerSymbolOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>test_enable</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for clock-carrying wires</td></tr></tbody></table><h3 id=seqclock_inv-circtseqclockinverterop><code>seq.clock_inv</code> (::circt::seq::ClockInverterOp)</h3><p><em>Inverts the clock signal</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.clock_inv` $input attr-dict
</code></pre><p>Note that the compiler can optimize inverters away, preventing their
use as part of explicit clock buffers.</p><pre tabindex=0><code>%inv_clock = seq.clock_inv %clock
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for clock-carrying wires</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for clock-carrying wires</td></tr></tbody></table><h3 id=seqclock_mux-circtseqclockmuxop><code>seq.clock_mux</code> (::circt::seq::ClockMuxOp)</h3><p><em>Safely selects a clock based on a condition</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.clock_mux` $cond `,` $trueClock `,` $falseClock attr-dict
</code></pre><p>The <code>seq.clock_mux</code> op selects a clock from two options. If <code>cond</code> is
true, the first clock operand is selected to drive downstream logic.
Otherwise, the second clock is used.</p><pre tabindex=0><code>%clock = seq.clock_mux %cond, %trueClock, %falseClock
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>trueClock</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>falseClock</code></td><td>A type for clock-carrying wires</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>A type for clock-carrying wires</td></tr></tbody></table><h3 id=seqcompreg-circtseqcompregop><code>seq.compreg</code> (::circt::seq::CompRegOp)</h3><p><em>Register a value, storing it for one cycle</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.compreg` (`sym` $inner_sym^)? custom&lt;ImplicitSSAName&gt;($name) $input `,` $clk
              (`reset` $reset^ `,` $resetValue)?
              (`powerOn` $powerOnValue^)? attr-dict `:` type($data)
              custom&lt;OptionalTypeMatch&gt;(ref(type($data)), ref($resetValue), type($resetValue))
              custom&lt;OptionalTypeMatch&gt;(ref(type($data)), ref($powerOnValue), type($powerOnValue))
</code></pre><p>See the Seq dialect rationale for a longer description
Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>Clocked</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>InnerSymbolOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code>, <code>Resettable</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>reset</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>resetValue</code></td><td>any type</td></tr><tr><td style=text-align:center><code>powerOnValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr></tbody></table><h3 id=seqcompregce-circtseqcompregclockenabledop><code>seq.compreg.ce</code> (::circt::seq::CompRegClockEnabledOp)</h3><p><em>When enabled, register a value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.compreg.ce` (`sym` $inner_sym^)? custom&lt;ImplicitSSAName&gt;($name) $input `,` $clk `,` $clockEnable
              (`reset` $reset^ `,` $resetValue)?
              (`powerOn` $powerOnValue^)? attr-dict `:` type($data)
              custom&lt;OptionalTypeMatch&gt;(ref(type($data)), ref($resetValue), type($resetValue))
              custom&lt;OptionalTypeMatch&gt;(ref(type($data)), ref($powerOnValue), type($powerOnValue))
</code></pre><p>See the Seq dialect rationale for a longer description
Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>Clocked</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>InnerSymbolOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code>, <code>Resettable</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>clockEnable</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>reset</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>resetValue</code></td><td>any type</td></tr><tr><td style=text-align:center><code>powerOnValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr></tbody></table><h3 id=seqconst_clock-circtseqconstclockop><code>seq.const_clock</code> (::circt::seq::ConstClockOp)</h3><p><em>Produce constant clock value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.const_clock` $value attr-dict
</code></pre><p>The constant operation produces a constant clock value.</p><pre tabindex=0><code>  %clock = seq.const_clock low
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::circt::seq::ClockConstAttr</td><td>clock constant</td></tr></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>A type for clock-carrying wires</td></tr></tbody></table><h3 id=seqfifo-circtseqfifoop><code>seq.fifo</code> (::circt::seq::FIFOOp)</h3><p><em>A high-level FIFO operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.fifo` `depth` $depth
              custom&lt;FIFOAFThreshold&gt;($almostFullThreshold, type($almostFull))
              custom&lt;FIFOAEThreshold&gt;($almostEmptyThreshold, type($almostEmpty))
              `in` $input `rdEn` $rdEn `wrEn` $wrEn `clk` $clk `rst` $rst attr-dict `:` type($input)
</code></pre><p>This operation represents a high-level abstraction of a FIFO. Access to the
FIFO is structural, and thus may be composed with other core RTL dialect
operations.
The fifo operation is configurable with the following parameters:</p><ol><li>Depth (cycles)</li><li>Almost full/empty thresholds (optional). If not provided, these will
be asserted when the FIFO is full/empty.</li></ol><p>Like <code>seq.hlmem</code> there are no guarantees that all possible fifo configuration
are able to be lowered. Available lowering passes will pattern match on the
requested fifo configuration and attempt to provide a legal lowering.</p><p>Traits: <code>AttrSizedResultSegments</code></p><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>depth</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 1</td></tr><tr><td><code>almostFullThreshold</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 0</td></tr><tr><td><code>almostEmptyThreshold</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 0</td></tr></table><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a signless integer bitvector</td></tr><tr><td style=text-align:center><code>rdEn</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>wrEn</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>a signless integer bitvector</td></tr><tr><td style=text-align:center><code>full</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>empty</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>almostFull</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>almostEmpty</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=seqfirmem-circtseqfirmemop><code>seq.firmem</code> (::circt::seq::FirMemOp)</h3><p><em>A FIRRTL-flavored memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.firmem` (`sym` $inner_sym^)? `` custom&lt;ImplicitSSAName&gt;($name)
              $readLatency `,` $writeLatency `,` $ruw `,` $wuw
              attr-dict `:` type($memory)
</code></pre><p>The <code>seq.firmem</code> op represents memories lowered from the FIRRTL dialect. It
is used to capture some of the peculiarities of what FIRRTL expects from
memories, while still representing them at the HW dialect level.</p><p>A <code>seq.firmem</code> declares the memory and captures the memory-level parameters
such as width and depth or how read/write collisions are resolved. The read,
write, and read-write ports are expressed as separate operations that take
the declared memory as an operand.</p><p>Interfaces: <code>InnerSymbolOpInterface</code>, <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>readLatency</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>writeLatency</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>ruw</code></td><td>circt::seq::RUWAttr</td><td>Read-Under-Write Behavior</td></tr><tr><td><code>wuw</code></td><td>circt::seq::WUWAttr</td><td>Write-Under-Write Behavior</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td><code>init</code></td><td>::circt::seq::FirMemInitAttr</td><td>Memory initialization information</td></tr><tr><td><code>prefix</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>output_file</code></td><td>::mlir::Attribute</td><td>any attribute</td></tr></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td>A FIRRTL-flavored memory</td></tr></tbody></table><h3 id=seqfirmemread_port-circtseqfirmemreadop><code>seq.firmem.read_port</code> (::circt::seq::FirMemReadOp)</h3><p><em>A memory read port</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.firmem.read_port` $memory `[` $address `]` `,` `clock` $clk
              (`enable` $enable^)?
              attr-dict `:` type($memory)
</code></pre><p>The <code>seq.firmem.read_port</code> op represents a read port on a <code>seq.firmem</code>
memory. It takes the memory as an operand, together with the address to
be read, the clock on which the read is synchronized, and an optional
enable. Omitting the enable operand has the same effect as passing a
constant <code>true</code> to it.</p><p>Interfaces: <code>Clocked</code>, <code>InferTypeOpInterface</code>, <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td>A FIRRTL-flavored memory</td></tr><tr><td style=text-align:center><code>address</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>signless integer</td></tr></tbody></table><h3 id=seqfirmemread_write_port-circtseqfirmemreadwriteop><code>seq.firmem.read_write_port</code> (::circt::seq::FirMemReadWriteOp)</h3><p><em>A memory read-write port</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.firmem.read_write_port` $memory `[` $address `]` `=` $writeData `if` $mode `,` `clock` $clk
              (`enable` $enable^)? (`mask` $mask^)?
              attr-dict `:` type($memory) (`,` type($mask)^)?
</code></pre><p>The <code>seq.firmem.read_write_port</code> op represents a read-write port on a
<code>seq.firmem</code> memory. It takes the memory as an operand, together with the
address and data to be written, a mode operand indicating whether the port
should perform a read (<code>mode=0</code>) or a write (<code>mode=1</code>), the clock on which
the read and write is synchronized, an optional enable, and and optional
write mask. Omitting the enable operand has the same effect as passing a
constant <code>true</code> to it. Omitting the write mask operand has the same effect
as passing an all-ones value to it. A write mask operand can only be present
if the <code>seq.firmem</code> specifies a mask width; otherwise it must be omitted.</p><p>Traits: <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>Clocked</code>, <code>InferTypeOpInterface</code>, <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource, MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td>A FIRRTL-flavored memory</td></tr><tr><td style=text-align:center><code>address</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>writeData</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>mode</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>readData</code></td><td>signless integer</td></tr></tbody></table><h3 id=seqfirmemwrite_port-circtseqfirmemwriteop><code>seq.firmem.write_port</code> (::circt::seq::FirMemWriteOp)</h3><p><em>A memory write port</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.firmem.write_port` $memory `[` $address `]` `=` $data `,` `clock` $clk
              (`enable` $enable^)? (`mask` $mask^)?
              attr-dict `:` type($memory) (`,` type($mask)^)?
</code></pre><p>The <code>seq.firmem.write_port</code> op represents a write port on a <code>seq.firmem</code>
memory. It takes the memory as an operand, together with the address and
data to be written, the clock on which the write is synchronized, an
optional enable, and and optional write mask. Omitting the enable operand
has the same effect as passing a constant <code>true</code> to it. Omitting the write
mask operand has the same effect as passing an all-ones value to it. A write
mask operand can only be present if the <code>seq.firmem</code> specifies a mask width;
otherwise it must be omitted.</p><p>Traits: <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>Clocked</code>, <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td>A FIRRTL-flavored memory</td></tr><tr><td style=text-align:center><code>address</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>enable</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>data</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>signless integer</td></tr></tbody></table><h3 id=seqfirreg-circtseqfirregop><code>seq.firreg</code> (::circt::seq::FirRegOp)</h3><p><em>Register with preset and sync or async reset</em></p><p><code>firreg</code> represents registers originating from FIRRTL after the lowering
of the IR to HW. The register is used as an intermediary in the process
of lowering to SystemVerilog to facilitate optimisation at the HW level,
compactly representing a register with a single operation instead of
composing it from register definitions, always blocks and if statements.</p><p>The <code>data</code> output of the register accesses the value it stores. On the
rising edge of the <code>clk</code> input, the register takes a new value provided
by the <code>next</code> signal. Optionally, the register can also be provided with
a synchronous or an asynchronous <code>reset</code> signal and <code>resetValue</code>, as shown
in the example below.</p><pre tabindex=0><code>%name = seq.firreg %next clock %clk [ sym @sym ]
    [ reset (sync|async) %reset, %value ]
    [ preset value ] : type
</code></pre><p>Implicitly, all registers are pre-set to a randomized value.</p><p>A register implementing a counter starting at 0 from reset can be defined
as follows:</p><pre tabindex=0><code>%zero = hw.constant 0 : i32
%reg = seq.firreg %next clock %clk reset sync %reset, %zero : i32
%one = hw.constant 1 : i32
%next = comb.add %reg, %one : i32
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameVariadicOperandSize</code></p><p>Interfaces: <code>Clocked</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>InnerSymbolOpInterface</code>, <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code>, <code>Resettable</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource, MemoryEffects::Read on ::mlir::SideEffects::DefaultResource, MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</code>, <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-7>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr><tr><td><code>preset</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr><tr><td><code>isAsync</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>next</code></td><td>any type</td></tr><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>reset</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>resetValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-11>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr></tbody></table><h3 id=seqfrom_clock-circtseqfromclockop><code>seq.from_clock</code> (::circt::seq::FromClockOp)</h3><p><em>Cast from a clock type to a wire type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.from_clock` $input attr-dict
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>A type for clock-carrying wires</td></tr></tbody></table><h4 id=results-12>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=seqhlmem-circtseqhlmemop><code>seq.hlmem</code> (::circt::seq::HLMemOp)</h3><p><em>Instantiate a high-level memory.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.hlmem` $name $clk `,` $rst attr-dict `:` type($handle)
</code></pre><p>See the Seq dialect rationale for a longer description
Interfaces: <code>Clocked</code>, <code>OpAsmOpInterface</code></p><h4 id=attributes-8>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>rst</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-13>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>handle</code></td><td>Multi-dimensional memory type</td></tr></tbody></table><h3 id=seqread-circtseqreadportop><code>seq.read</code> (::circt::seq::ReadPortOp)</h3><p><em>Structural read access to a seq.hlmem, with an optional read enable signal.</em></p><p>Traits: <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=attributes-9>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>latency</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td>Multi-dimensional memory type</td></tr><tr><td style=text-align:center><code>addresses</code></td><td>variadic of a signless integer bitvector</td></tr><tr><td style=text-align:center><code>rdEn</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-14>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>readData</code></td><td>any type</td></tr></tbody></table><h3 id=seqshiftreg-circtseqshiftregop><code>seq.shiftreg</code> (::circt::seq::ShiftRegOp)</h3><p><em>Shift register</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.shiftreg` `[` $numElements `]`
              (`sym` $inner_sym^)? custom&lt;ImplicitSSAName&gt;($name) $input `,` $clk `,` $clockEnable
              (`reset` $reset^ `,` $resetValue)?
              (`powerOn` $powerOnValue^)? attr-dict `:` type($data)
              custom&lt;OptionalTypeMatch&gt;(ref(type($data)), ref($resetValue), type($resetValue))
              custom&lt;OptionalTypeMatch&gt;(ref(type($data)), ref($powerOnValue), type($powerOnValue))
</code></pre><p>The <code>seq.shiftreg</code> op represents a shift register. It takes the input
value and shifts it every cycle when <code>clockEnable</code> is asserted.
The <code>reset</code> and <code>resetValue</code> operands are optional and if present, every
entry in the shift register will be initialized to <code>resetValue</code> upon
assertion of the reset signal. Exact reset behavior (sync/async) is
implementation defined.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>Clocked</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>InnerSymbolOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code>, <code>Resettable</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-10>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>numElements</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose minimum value is 1</td></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>inner_sym</code></td><td>::circt::hw::InnerSymAttr</td><td>Inner symbol definition</td></tr></table><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>any type</td></tr><tr><td style=text-align:center><code>clk</code></td><td>A type for clock-carrying wires</td></tr><tr><td style=text-align:center><code>clockEnable</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>reset</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>resetValue</code></td><td>any type</td></tr><tr><td style=text-align:center><code>powerOnValue</code></td><td>any type</td></tr></tbody></table><h4 id=results-15>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>any type</td></tr></tbody></table><h3 id=seqto_clock-circtseqtoclockop><code>seq.to_clock</code> (::circt::seq::ToClockOp)</h3><p><em>Cast from a wire type to a clock type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `seq.to_clock` $input attr-dict
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-16>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>A type for clock-carrying wires</td></tr></tbody></table><h3 id=seqwrite-circtseqwriteportop><code>seq.write</code> (::circt::seq::WritePortOp)</h3><p><em>Structural write access to a seq.hlmem</em></p><h4 id=attributes-11>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>latency</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-16>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memory</code></td><td>Multi-dimensional memory type</td></tr><tr><td style=text-align:center><code>addresses</code></td><td>variadic of a signless integer bitvector</td></tr><tr><td style=text-align:center><code>inData</code></td><td>any type</td></tr><tr><td style=text-align:center><code>wrEn</code></td><td>1-bit signless integer</td></tr></tbody></table><h2 id=attributes-12>Attributes</h2><h3 id=clockconstattr>ClockConstAttr</h3><p>clock constant</p><p>Syntax:</p><pre tabindex=0><code>#seq.clock constant&lt;
  circt::seq::ClockConst   # value
&gt;
</code></pre><p>Enum cases:</p><ul><li>low (<code>Low</code>)</li><li>high (<code>High</code>)</li></ul><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>circt::seq::ClockConst</code></td><td>an enum of type ClockConst</td></tr></tbody></table><h3 id=firmeminitattr>FirMemInitAttr</h3><p>Memory initialization information</p><p>Syntax:</p><pre tabindex=0><code>#seq.firmem.init&lt;
  mlir::StringAttr,   # filename
  bool,   # isBinary
  bool   # isInline
&gt;
</code></pre><p>This attribute captures what the initial contents of a memory should be.
At the moment this is modeled primarily with simulation in mind, where the
memory contents are pre-loaded from a file at simulation startup.</p><p>The <code>filename</code> specifies a file on disk that contains the initial contents
for this memory. If <code>isBinary</code> is set, the file is interpreted as a binary
file, otherwise it is treated as hexadecimal. This is modeled after the
<code>$readmemh</code> and <code>$readmemb</code> SystemVerilog functions. If <code>isInline</code> is set,
the initialization is emitted directly in the memory model; otherwise it is
split out into a separate module that can be bound in.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>filename</td><td style=text-align:center><code>mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>isBinary</td><td style=text-align:center><code>bool</code></td><td></td></tr><tr><td style=text-align:center>isInline</td><td style=text-align:center><code>bool</code></td><td></td></tr></tbody></table><h2 id=types>Types</h2><h3 id=clocktype>ClockType</h3><p>A type for clock-carrying wires</p><p>Syntax: <code>!seq.clock</code></p><p>The <code>!seq.clock</code> type represents signals which can be used to drive the
clock input of sequential operations.</p><h3 id=firmemtype>FirMemType</h3><p>A FIRRTL-flavored memory</p><p>Syntax:</p><pre tabindex=0><code>!seq.firmem&lt;
  uint64_t,   # depth
  uint32_t,   # width
  std::optional&lt;uint32_t&gt;   # maskWidth
&gt;
</code></pre><p>The <code>!seq.firmem</code> type represents a FIRRTL-flavored memory declared by a
<code>seq.firmem</code> operation. It captures the parameters of the memory that are
relevant to the read, write, and read-write ports, such as width and depth.</p><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>depth</td><td style=text-align:center><code>uint64_t</code></td><td></td></tr><tr><td style=text-align:center>width</td><td style=text-align:center><code>uint32_t</code></td><td></td></tr><tr><td style=text-align:center>maskWidth</td><td style=text-align:center><code>std::optional&lt;uint32_t></code></td><td></td></tr></tbody></table><h3 id=hlmemtype>HLMemType</h3><p>Multi-dimensional memory type</p><p>Syntax:</p><pre tabindex=0><code>hlmem-type ::== `hlmem` `&lt;` dim-list element-type `&gt;`
</code></pre><p>The HLMemType represents the type of an addressable memory structure. The
type is inherently multidimensional. Dimensions must be known integer values.</p><p>Note: unidimensional memories are represented as &lt;1x{element type}> -
&lt;{element type}> is illegal.</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>shape</td><td style=text-align:center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h2>'seq' Dialect Docs</h2><ul><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/ title="Pipeline Dialect Rationale"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Pipeline Dialect Rationale</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/ title="Seq(uential) Dialect Rationale">Next - Seq(uential) Dialect Rationale <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class="active has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>