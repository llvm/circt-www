<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'systemc' Dialect - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Dialects/SystemC/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>'systemc' Dialect</h1><p>Types and operations for the SystemC dialect
This dialect defines the <code>systemc</code> dialect, which represents various
constructs of the SystemC library (IEEE 1666-2011) useful for emission.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#systemcconvert-circtsystemcconvertop><code>systemc.convert</code> (::circt::systemc::ConvertOp)</a></li><li><a href=#systemccppassign-circtsystemcassignop><code>systemc.cpp.assign</code> (::circt::systemc::AssignOp)</a></li><li><a href=#systemccppcall-circtsystemccallop><code>systemc.cpp.call</code> (::circt::systemc::CallOp)</a></li><li><a href=#systemccppcall_indirect-circtsystemccallindirectop><code>systemc.cpp.call_indirect</code> (::circt::systemc::CallIndirectOp)</a></li><li><a href=#systemccppdelete-circtsystemcdeleteop><code>systemc.cpp.delete</code> (::circt::systemc::DeleteOp)</a></li><li><a href=#systemccppdestructor-circtsystemcdestructorop><code>systemc.cpp.destructor</code> (::circt::systemc::DestructorOp)</a></li><li><a href=#systemccppfunc-circtsystemcfuncop><code>systemc.cpp.func</code> (::circt::systemc::FuncOp)</a></li><li><a href=#systemccppmember_access-circtsystemcmemberaccessop><code>systemc.cpp.member_access</code> (::circt::systemc::MemberAccessOp)</a></li><li><a href=#systemccppnew-circtsystemcnewop><code>systemc.cpp.new</code> (::circt::systemc::NewOp)</a></li><li><a href=#systemccppreturn-circtsystemcreturnop><code>systemc.cpp.return</code> (::circt::systemc::ReturnOp)</a></li><li><a href=#systemccppvariable-circtsystemcvariableop><code>systemc.cpp.variable</code> (::circt::systemc::VariableOp)</a></li><li><a href=#systemcctor-circtsystemcctorop><code>systemc.ctor</code> (::circt::systemc::CtorOp)</a></li><li><a href=#systemcfunc-circtsystemcscfuncop><code>systemc.func</code> (::circt::systemc::SCFuncOp)</a></li><li><a href=#systemcinstancebind_port-circtsystemcbindportop><code>systemc.instance.bind_port</code> (::circt::systemc::BindPortOp)</a></li><li><a href=#systemcinstancedecl-circtsystemcinstancedeclop><code>systemc.instance.decl</code> (::circt::systemc::InstanceDeclOp)</a></li><li><a href=#systemcinteropverilated-circtsystemcinteropverilatedop><code>systemc.interop.verilated</code> (::circt::systemc::InteropVerilatedOp)</a></li><li><a href=#systemcmethod-circtsystemcmethodop><code>systemc.method</code> (::circt::systemc::MethodOp)</a></li><li><a href=#systemcmodule-circtsystemcscmoduleop><code>systemc.module</code> (::circt::systemc::SCModuleOp)</a></li><li><a href=#systemcsensitive-circtsystemcsensitiveop><code>systemc.sensitive</code> (::circt::systemc::SensitiveOp)</a></li><li><a href=#systemcsignal-circtsystemcsignalop><code>systemc.signal</code> (::circt::systemc::SignalOp)</a></li><li><a href=#systemcsignalread-circtsystemcsignalreadop><code>systemc.signal.read</code> (::circt::systemc::SignalReadOp)</a></li><li><a href=#systemcsignalwrite-circtsystemcsignalwriteop><code>systemc.signal.write</code> (::circt::systemc::SignalWriteOp)</a></li><li><a href=#systemcthread-circtsystemcthreadop><code>systemc.thread</code> (::circt::systemc::ThreadOp)</a></li></ul></li><li><a href=#type-constraints>Type constraints</a><ul><li><a href=#a-systemc-sc_bigintw-type>a SystemC sc_bigint<w> type</a></li><li><a href=#a-systemc-sc_biguintw-type>a SystemC sc_biguint<w> type</a></li><li><a href=#a-systemc-sc_bv_base-type>a SystemC sc_bv_base type</a></li><li><a href=#a-systemc-sc_bvw-type>a SystemC sc_bv<w> type</a></li><li><a href=#a-systemc-sc_int_base-type>a SystemC sc_int_base type</a></li><li><a href=#a-systemc-sc_intw-type>a SystemC sc_int<w> type</a></li><li><a href=#a-systemc-sc_lv_base-type>a SystemC sc_lv_base type</a></li><li><a href=#a-systemc-sc_lvw-type>a SystemC sc_lv<w> type</a></li><li><a href=#functiontype-with-no-inputs-and-results>FunctionType with no inputs and results</a></li><li><a href=#a-systemc-sc_signed-type>a SystemC sc_signed type</a></li><li><a href=#a-systemc-sc_uint_base-type>a SystemC sc_uint_base type</a></li><li><a href=#a-systemc-sc_uintw-type>a SystemC sc_uint<w> type</a></li><li><a href=#a-systemc-sc_unsigned-type>a SystemC sc_unsigned type</a></li><li><a href=#a-systemc-sc_value_base-type>a SystemC sc_value_base type</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#inouttype>InOutType</a></li><li><a href=#inputtype>InputType</a></li><li><a href=#logictype>LogicType</a></li><li><a href=#moduletype>ModuleType</a></li><li><a href=#outputtype>OutputType</a></li><li><a href=#signaltype>SignalType</a></li></ul></li></ul></nav><h2 id=operations>Operations</h2><h3 id=systemcconvert-circtsystemcconvertop><code>systemc.convert</code> (::circt::systemc::ConvertOp)</h3><p><em>Converts between various integer and bit vector types.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.convert` $input attr-dict `:` functional-type($input, $result)
</code></pre><p>Allows conversions between the various integer and bit vector types in
SystemC, including MLIRs signless integers that are used to represent the
primitive C integer types, according to the explicit and implicit
constructors, implicit access operators and explicit conversion member
functions defined in the respective data type class in the SystemC spec
(refer to the description of the supported types and the spec chapters
listed there for more information).</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>integer or a SystemC sc_value_base type or signless integer or a SystemC sc_bv_base type or a SystemC sc_bv<w> type or a SystemC sc_lv_base type or a SystemC sc_lv<w> type or a SystemC sc_logic type</td></tr></tbody></table><h4 id=results>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>integer or a SystemC sc_value_base type or signless integer or a SystemC sc_bv_base type or a SystemC sc_bv<w> type or a SystemC sc_lv_base type or a SystemC sc_lv<w> type or a SystemC sc_logic type</td></tr></tbody></table><h3 id=systemccppassign-circtsystemcassignop><code>systemc.cpp.assign</code> (::circt::systemc::AssignOp)</h3><p><em>A C++ assignment.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.cpp.assign` $dest `=` $source attr-dict `:` type($dest)
</code></pre><p>Assigns one SSA value to another. Note that there is no notion of lvalues
and rvalues. This means that one can assign to a value that is the result
of, e.g., an addition, which is not allowed in C++. It is the responsibility
of the user and the implementor of a lowering pass that creates this
operation to make sure that the operands are valid according to C++
semantics. Rationale for that: implementing these constraints would add
quite some complexity, but still does not guarantee that the assignment
is valid because we also make use of non-verifyable verbatim types, etc.</p><p>Traits: <code>SameTypeOperands</code></p><h4 id=operands-1>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>any type</td></tr><tr><td style=text-align:center><code>source</code></td><td>any type</td></tr></tbody></table><h3 id=systemccppcall-circtsystemccallop><code>systemc.cpp.call</code> (::circt::systemc::CallOp)</h3><p><em>Call operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.cpp.call` $callee `(` $callee_operands `)` attr-dict `:`
              functional-type($callee_operands, $results)
</code></pre><p>The <code>systemc.cpp.call</code> operation represents a direct call to a function that
is within the same symbol scope as the call. The operands and result types
of the call must match the specified function type. The callee is encoded as
a symbol reference attribute named &ldquo;callee&rdquo;.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> systemc<span class=p>.</span>cpp<span class=p>.</span>call <span class=nf>@my_add</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Interfaces: <code>CallOpInterface</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>callee</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=operands-2>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>callee_operands</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-1>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=systemccppcall_indirect-circtsystemccallindirectop><code>systemc.cpp.call_indirect</code> (::circt::systemc::CallIndirectOp)</h3><p><em>Indirect call operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.cpp.call_indirect` $callee `(` $callee_operands `)` attr-dict `:` type($callee)
</code></pre><p>The <code>systemc.cpp.call_indirect</code> operation represents an indirect call to a
value of function type. The operands and result types of the call must match
the specified function type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%func</span> <span class=p>=</span> systemc<span class=p>.</span>cpp<span class=p>.</span>member_access <span class=nv>%object</span> dot <span class=s>&#34;func&#34;</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> systemc<span class=p>.</span>cpp<span class=p>.</span>call_indirect <span class=nv>%func</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Interfaces: <code>CallOpInterface</code></p><h4 id=operands-3>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>callee</code></td><td>function type</td></tr><tr><td style=text-align:center><code>callee_operands</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-2>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=systemccppdelete-circtsystemcdeleteop><code>systemc.cpp.delete</code> (::circt::systemc::DeleteOp)</h3><p><em>A C++ delete expression.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.cpp.delete` $pointer attr-dict `:` qualified(type($pointer))
</code></pre><p>Destroys objects previously allocated by the new expression and releases
the allocated memory.</p><h4 id=operands-4>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>EmitC pointer type</td></tr></tbody></table><h3 id=systemccppdestructor-circtsystemcdestructorop><code>systemc.cpp.destructor</code> (::circt::systemc::DestructorOp)</h3><p><em>A C++ destructor definition.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.cpp.destructor` attr-dict-with-keyword $body
</code></pre><p>This operation models a C++ destructor of a class or struct. It is not an
operation modelling some abstract SystemC construct, but still required to
support more complex functionality such as having a pointer to an external
object inside a SystemC module, e.g., for interoperability purposes.</p><p>Traits: <code>HasParent&lt;SCModuleOp></code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><h3 id=systemccppfunc-circtsystemcfuncop><code>systemc.cpp.func</code> (::circt::systemc::FuncOp)</h3><p><em>An operation with a name containing a single <code>SSACFG</code> region</em></p><p>Operations within the function cannot implicitly capture values defined
outside of the function, i.e. Functions are <code>IsolatedFromAbove</code>. All
external references must use function arguments or attributes that establish
a symbolic connection (e.g. symbols referenced by name via a string
attribute like SymbolRefAttr). An external function declaration (used when
referring to a function declared in some other module) has no body. While
the MLIR textual form provides a nice inline syntax for function arguments,
they are internally represented as “block arguments” to the first block in
the region.</p><p>Argument names are stored in a &lsquo;argNames&rsquo; attribute, but used directly as
the SSA value&rsquo;s names. They are verified to be unique and can be used to
print them, e.g., as C function argument names.</p><p>Only dialect attribute names may be specified in the attribute dictionaries
for function arguments, results, or the function itself.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// External function definitions.
</span></span></span><span class=line><span class=cl><span class=c></span>systemc<span class=p>.</span>cpp<span class=p>.</span><span class=kt>func</span> <span class=nf>@abort</span><span class=p>()</span>
</span></span><span class=line><span class=cl>systemc<span class=p>.</span>cpp<span class=p>.</span><span class=kt>func</span> externC <span class=nf>@scribble</span><span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A function that returns its argument twice:
</span></span></span><span class=line><span class=cl><span class=c></span>systemc<span class=p>.</span>cpp<span class=p>.</span><span class=kt>func</span> <span class=nf>@count</span><span class=p>(</span><span class=nv>%argumentName</span><span class=p>:</span> <span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i64</span><span class=p>,</span> <span class=k>i64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>return</span> <span class=nv>%argumentName</span><span class=p>,</span> <span class=nv>%argumentName</span><span class=p>:</span> <span class=k>i64</span><span class=p>,</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A function with an attribute
</span></span></span><span class=line><span class=cl><span class=c></span>systemc<span class=p>.</span>cpp<span class=p>.</span><span class=kt>func</span> <span class=nf>@exampleFnAttr</span><span class=p>()</span> attributes <span class=p>{</span><span class=nl>dialectName.attrName =</span> false<span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AutomaticAllocationScope</code>, <code>IsolatedFromAbove</code></p><p>Interfaces: <code>CallableOpInterface</code>, <code>FunctionOpInterface</code>, <code>OpAsmOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-1>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>argNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>externC</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>sym_visibility</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=systemccppmember_access-circtsystemcmemberaccessop><code>systemc.cpp.member_access</code> (::circt::systemc::MemberAccessOp)</h3><p><em>A C++ member access expression.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.cpp.member_access` $object $accessKind $memberName attr-dict `:`
              functional-type($object, $result)
</code></pre><p>Represents the C++ member access operators <code>.</code> and <code>-></code>.
The member name is passed as a plain string and is not checked for validity.
Additional qualifications (<code>A::E1</code>) or template disambiguation
(<code>template E1</code>) can be manually added to this plain member name string for
emission.
The type of the object and result cannot be verified as it is allowed to use
varbatim types such as <code>emitc.opaque</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memberName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>accessKind</code></td><td>::MemberAccessKindAttr</td><td>C++ member access kind</td></tr></table><h4 id=operands-5>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>object</code></td><td>any type</td></tr></tbody></table><h4 id=results-3>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=systemccppnew-circtsystemcnewop><code>systemc.cpp.new</code> (::circt::systemc::NewOp)</h3><p><em>A C++ &rsquo;new&rsquo; expression.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.cpp.new` `(` $args `)` attr-dict `:` functional-type($args, $result)
</code></pre><p>Creates and initializes C++ objects using dynamic storage.
Note that the types of the constructor arguments are not verified in any way
w.r.t. the result&rsquo;s type because it is allowed to use an opaque type for the
pointee.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-4>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>EmitC pointer type</td></tr></tbody></table><h3 id=systemccppreturn-circtsystemcreturnop><code>systemc.cpp.return</code> (::circt::systemc::ReturnOp)</h3><p><em>Function return operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.cpp.return` attr-dict ($returnValues^ `:` type($returnValues))?
</code></pre><p>The <code>systemc.cpp.return</code> operation represents a return operation within a
function. The operand number and types must match the signature of the
function that contains the operation.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>systemc<span class=p>.</span>cpp<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>()</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  systemc<span class=p>.</span>cpp<span class=p>.</span><span class=kt>return</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;systemc::FuncOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>returnValues</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=systemccppvariable-circtsystemcvariableop><code>systemc.cpp.variable</code> (::circt::systemc::VariableOp)</h3><p><em>Declare a C++ variable with optional initialization value.</em></p><p>Declares a variable according to C++ semantics. If an initialization value
is present, the variable will be assigned that value at the declaration,
e.g, <code>int varname = 0;</code>.</p><p>Interfaces: <code>HasCustomSSAName</code>, <code>SystemCNameDeclOpInterface</code></p><h4 id=attributes-3>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-8>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>init</code></td><td>any type</td></tr></tbody></table><h4 id=results-5>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>variable</code></td><td>any type</td></tr></tbody></table><h3 id=systemcctor-circtsystemcctorop><code>systemc.ctor</code> (::circt::systemc::CtorOp)</h3><p><em>A constructor definition.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.ctor` attr-dict-with-keyword $body
</code></pre><p>Represents the SC_CTOR macro as described in IEEE 1666-2011 §5.2.7.
The name of the module being constructed does not have to be passed
to this operation, but is automatically added during emission.</p><p>Traits: <code>HasParent&lt;SCModuleOp></code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><h3 id=systemcfunc-circtsystemcscfuncop><code>systemc.func</code> (::circt::systemc::SCFuncOp)</h3><p><em>A (void)->void member function of a SC_MODULE.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.func` `` custom&lt;ImplicitSSAName&gt;($name) attr-dict-with-keyword $body
</code></pre><p>This operation does not represent a specific SystemC construct, but a
regular C++ member function with no arguments and a void return type.
These are used to implement module-internal logic and are registered to the
module using the SC_METHOD, SC_THREAD, and SC_CTHREAD macros.</p><p>Traits: <code>HasParent&lt;SCModuleOp></code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>HasCustomSSAName</code>, <code>InferTypeOpInterface</code>, <code>SystemCNameDeclOpInterface</code></p><h4 id=attributes-4>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-6>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>handle</code></td><td>FunctionType with no inputs and results</td></tr></tbody></table><h3 id=systemcinstancebind_port-circtsystemcbindportop><code>systemc.instance.bind_port</code> (::circt::systemc::BindPortOp)</h3><p><em>Binds a port of a module instance to a channel.</em></p><p>The ports of a submodule have to be bound to channels in a module further
up in the instance hierarchy (as opposed to <code>sc_export</code> where the channel
has to reside in the same module or a submodule). Therefore, a port can be
bound to either a signal declared by the <code>systemc.signal</code> operation or to
a port with matching direction (and thus bound to a channel further up in
the hierarchy).
More information on ports can be found in IEEE 1666-2011 §5.12.,
in particular IEEE 1666-2011 §5.12.7. is about port binding.
More information on predefined channels can be found in IEEE 1666-2011 §6.</p><p>Traits: <code>HasParent&lt;CtorOp></code></p><h4 id=attributes-5>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>portId</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=operands-9>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>instance</code></td><td>a SystemC module type</td></tr><tr><td style=text-align:center><code>channel</code></td><td>a SystemC sc_in<t> type or a SystemC sc_inout<t> type or a SystemC sc_out<t> type or a SystemC sc_signal<t> type</td></tr></tbody></table><h3 id=systemcinstancedecl-circtsystemcinstancedeclop><code>systemc.instance.decl</code> (::circt::systemc::InstanceDeclOp)</h3><p><em>Declares a SystemC module instance.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.instance.decl` custom&lt;ImplicitSSAName&gt;($name) $moduleName attr-dict
              `:` qualified(type($instanceHandle))
</code></pre><p>Declares an instantiation of a SystemC module inside another SystemC module
by value. The instance handle returned by this operation can then be used
to initialize it in the constructor and to access its fields.
More information can be found in IEEE 1666-2011 §4.1.1.</p><p>Traits: <code>HasParent&lt;SCModuleOp></code></p><p>Interfaces: <code>HasCustomSSAName</code>, <code>InstanceOpInterface</code>, <code>SymbolUserOpInterface</code>, <code>SystemCNameDeclOpInterface</code></p><h4 id=attributes-6>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>moduleName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=results-7>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>instanceHandle</code></td><td>a SystemC module type</td></tr></tbody></table><h3 id=systemcinteropverilated-circtsystemcinteropverilatedop><code>systemc.interop.verilated</code> (::circt::systemc::InteropVerilatedOp)</h3><p><em>Instantiates a verilated module.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.interop.verilated` $instanceName $moduleName
              custom&lt;InputPortList&gt;($inputs, type($inputs), $inputNames) `-&gt;`
              custom&lt;OutputPortList&gt;(type($results), $resultNames) attr-dict
</code></pre><p>Instantiates a verilated module represented by a hw.module operation
(usually the extern variant).</p><p>This operation also encodes the interoparability layer to connect its
context (i.e. the surrounding operation, input values, result values, and
types) to the C++ code of the verilated module.
When residing in a context that understands C++ (e.g., inside a SystemC
module), this refers to the instantiation of the class, assignment of the
input ports, the call to the eval() function and reading the output ports.</p><p>Additionally, properties of the verilated module can be specified in
a config attribute which influences the interop layer code generation
(not yet implemented).</p><p>Interfaces: <code>OpAsmOpInterface</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-7>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>instanceName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>moduleName</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>inputNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>resultNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h4 id=operands-10>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-8>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=systemcmethod-circtsystemcmethodop><code>systemc.method</code> (::circt::systemc::MethodOp)</h3><p><em>Represents the SystemC SC_METHOD macro.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.method` $funcHandle attr-dict
</code></pre><p>Represents the SC_METHOD macro as described in IEEE 1666-2011 §5.2.9.</p><h4 id=operands-11>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>funcHandle</code></td><td>FunctionType with no inputs and results</td></tr></tbody></table><h3 id=systemcmodule-circtsystemcscmoduleop><code>systemc.module</code> (::circt::systemc::SCModuleOp)</h3><p><em>Define a SystemC SC_MODULE.</em></p><p>Represents the SC_MODULE macro as described in IEEE 1666-2011 §5.2.5.
Models input, output and inout ports as module arguments (as opposed to
<code>sc_signal</code>s which are modeled by a separate <code>systemc.signal</code> operation),
but are nonetheless emitted as regular struct fields.</p><p>Traits: <code>HasParent&lt;mlir::ModuleOp></code>, <code>IsolatedFromAbove</code>, <code>NoTerminator</code>, <code>SingleBlock</code></p><p>Interfaces: <code>CallableOpInterface</code>, <code>FunctionOpInterface</code>, <code>ModuleOpInterface</code>, <code>OpAsmOpInterface</code>, <code>RegionKindInterface</code>, <code>Symbol</code></p><h4 id=attributes-8>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>portNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h3 id=systemcsensitive-circtsystemcsensitiveop><code>systemc.sensitive</code> (::circt::systemc::SensitiveOp)</h3><p><em>Describes the static sensitivity of an unspawned process.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.sensitive` $sensitivities attr-dict ( `:` qualified(type($sensitivities))^ )?
</code></pre><p>This operation allows to specify the static sensitivity of unspawned
processes. An unspawned process is one created by the <code>SC_METHOD</code>,
<code>SC_THREAD</code>, or <code>SC_CTHREAD</code> macro. The operands to this operation are
registered as sensitivities to the process last created (in control-flow
order).
Each <code>SC_MODULE</code> contains an instance of the <code>sc_sensitive</code> class to do the
registration. For a description of the <code>sc_sensitive</code> class refer to
IEEE 1666-2011 §5.4. For a description of the <code>sensitive</code> data member of
<code>SC_MODULE</code> refer to IEEE 1666-2011 §5.2.14.</p><p>Traits: <code>HasParent&lt;CtorOp></code></p><h4 id=operands-12>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sensitivities</code></td><td>variadic of a SystemC sc_in<t> type or a SystemC sc_inout<t> type or a SystemC sc_out<t> type or a SystemC sc_signal<t> type</td></tr></tbody></table><h3 id=systemcsignal-circtsystemcsignalop><code>systemc.signal</code> (::circt::systemc::SignalOp)</h3><p><em>Declares a SystemC <code>sc_signal&lt;T></code>.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.signal` custom&lt;ImplicitSSAName&gt;($name) ( `named` $named^ )? attr-dict
              `:` qualified(type($signal))
</code></pre><p>Represents the <code>sc_signal</code> template as described in IEEE 1666-2011 §6.4.
Adding the &rsquo;named&rsquo; attribute will lead to the signal being emitted with the
<code>SC_NAMED</code> convenience macro. Note that this macro is not part of
IEEE 1666-2011, but was added in version 2.3.3.</p><p>Traits: <code>HasParent&lt;SCModuleOp></code></p><p>Interfaces: <code>HasCustomSSAName</code>, <code>SystemCNameDeclOpInterface</code></p><h4 id=attributes-9>Attributes:</h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>named</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=results-9>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>signal</code></td><td>a SystemC sc_signal<t> type</td></tr></tbody></table><h3 id=systemcsignalread-circtsystemcsignalreadop><code>systemc.signal.read</code> (::circt::systemc::SignalReadOp)</h3><p><em>Returns the current value of a signal or port.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.signal.read` $input attr-dict `:` qualified(type($input))
</code></pre><p>Represents the member function <code>const T& read() const;</code> and operator
<code>operator const T& () const;</code> of class <code>sc_signal</code> as described in
IEEE 1666-2011 §6.4.7., of class <code>sc_in</code> as described in §6.8.3., and
of class <code>sc_inout</code> as decribed in §6.10.3. It shall return the current
value of the signal/port.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>a SystemC sc_in<t> type or a SystemC sc_inout<t> type or a SystemC sc_signal<t> type</td></tr></tbody></table><h4 id=results-10>Results:</h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=systemcsignalwrite-circtsystemcsignalwriteop><code>systemc.signal.write</code> (::circt::systemc::SignalWriteOp)</h3><p><em>Writes a value to a signal or port.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.signal.write` $dest `,` $src attr-dict `:` qualified(type($dest))
</code></pre><p>Represents the member function <code>void write(const T&);</code> and several variants
of the operator <code>operator=</code> of class <code>sc_signal</code> as described in
IEEE 1666-2011 §6.4.8., of class <code>sc_inout</code> as described in §6.10.3., and of
class <code>sc_out</code> as decribed in §6.12.3. It shall modify the value of the
signal/port such that it appears to have the new value (as observed using
the <code>sytemc.signal.read</code> operation) in the next delta cycle but not before
then.</p><h4 id=operands-14>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>a SystemC sc_out<t> type or a SystemC sc_inout<t> type or a SystemC sc_signal<t> type</td></tr><tr><td style=text-align:center><code>src</code></td><td>any type</td></tr></tbody></table><h3 id=systemcthread-circtsystemcthreadop><code>systemc.thread</code> (::circt::systemc::ThreadOp)</h3><p><em>Represents the SystemC SC_THREAD macro.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `systemc.thread` $funcHandle attr-dict
</code></pre><p>Represents the SC_THREAD macro as described in IEEE 1666-2011 §5.2.9.</p><h4 id=operands-15>Operands:</h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>funcHandle</code></td><td>FunctionType with no inputs and results</td></tr></tbody></table><h2 id=type-constraints>Type constraints</h2><h3 id=a-systemc-sc_bigintw-type>a SystemC sc_bigint<w> type</h3><h3 id=a-systemc-sc_biguintw-type>a SystemC sc_biguint<w> type</h3><h3 id=a-systemc-sc_bv_base-type>a SystemC sc_bv_base type</h3><h3 id=a-systemc-sc_bvw-type>a SystemC sc_bv<w> type</h3><h3 id=a-systemc-sc_int_base-type>a SystemC sc_int_base type</h3><h3 id=a-systemc-sc_intw-type>a SystemC sc_int<w> type</h3><h3 id=a-systemc-sc_lv_base-type>a SystemC sc_lv_base type</h3><h3 id=a-systemc-sc_lvw-type>a SystemC sc_lv<w> type</h3><h3 id=functiontype-with-no-inputs-and-results>FunctionType with no inputs and results</h3><h3 id=a-systemc-sc_signed-type>a SystemC sc_signed type</h3><h3 id=a-systemc-sc_uint_base-type>a SystemC sc_uint_base type</h3><h3 id=a-systemc-sc_uintw-type>a SystemC sc_uint<w> type</h3><h3 id=a-systemc-sc_unsigned-type>a SystemC sc_unsigned type</h3><h3 id=a-systemc-sc_value_base-type>a SystemC sc_value_base type</h3><h2 id=types>Types</h2><h3 id=inouttype>InOutType</h3><p>a SystemC sc_inout<t> type</p><p>Syntax:</p><pre tabindex=0><code>!systemc.inout&lt;
  ::mlir::Type   # baseType
&gt;
</code></pre><p>Represents the specialized SystemC port class sc_inout<t> as described in
IEEE 1666-2011 §6.10.</p><h4 id=parameters>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>baseType</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=inputtype>InputType</h3><p>a SystemC sc_in<t> type</p><p>Syntax:</p><pre tabindex=0><code>!systemc.in&lt;
  ::mlir::Type   # baseType
&gt;
</code></pre><p>Represents the specialized SystemC port class sc_in<t> as described in
IEEE 1666-2011 §6.8.</p><h4 id=parameters-1>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>baseType</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=logictype>LogicType</h3><p>a SystemC sc_logic type</p><p>Syntax: <code>!systemc.logic</code></p><p>Represents a single bit with with a value corresponding to one of the four
logic states &lsquo;0&rsquo;, &lsquo;1&rsquo;, &lsquo;Z&rsquo;, and &lsquo;X&rsquo; in SystemC as described in
IEEE 1666-2011 §7.9.2.
A value of this type can be created using the &rsquo;emitc.constant&rsquo; operation
with a string attribute containing &ldquo;0&rdquo;, &ldquo;1&rdquo;, &ldquo;X&rdquo;, &ldquo;Z&rdquo;, &ldquo;x&rdquo;, or &ldquo;z&rdquo; or an
i1 attribute representing &ldquo;true&rdquo; or &ldquo;false&rdquo;. Any other value will be
interpreted as &lsquo;X&rsquo; (unknown state).</p><h3 id=moduletype>ModuleType</h3><p>a SystemC module type</p><p>Represents a SystemC module instantiation. Example:
<code>!systemc.module&lt;moduleName(portName1: type1, portName2: type2)></code></p><h4 id=parameters-2>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>moduleName</td><td style=text-align:center><code>mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>ports</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::circt::systemc::ModuleType::PortInfo></code></td><td>module ports</td></tr></tbody></table><h3 id=outputtype>OutputType</h3><p>a SystemC sc_out<t> type</p><p>Syntax:</p><pre tabindex=0><code>!systemc.out&lt;
  ::mlir::Type   # baseType
&gt;
</code></pre><p>Represents the specialized SystemC port class sc_out<t> as described in
IEEE 1666-2011 §6.12.</p><h4 id=parameters-3>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>baseType</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=signaltype>SignalType</h3><p>a SystemC sc_signal<t> type</p><p>Syntax:</p><pre tabindex=0><code>!systemc.signal&lt;
  ::mlir::Type   # baseType
&gt;
</code></pre><p>Represents the predefined primitive channel sc_signal<t> as described in
IEEE 1666-2011 §6.4.</p><h4 id=parameters-4>Parameters:</h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>baseType</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h2>'systemc' Dialect Docs</h2><ul><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/ title="SV Dialect Rationale"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - SV Dialect Rationale</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/ title="SystemC Dialect Rationale">Next - SystemC Dialect Rationale <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class="active has-sub-menu"><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>