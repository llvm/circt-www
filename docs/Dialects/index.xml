<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dialects on CIRCT</title><link>https://circt.llvm.org/docs/Dialects/</link><description>Recent content in Dialects on CIRCT</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Jan 1970 00:00:00 +0000</lastBuildDate><atom:link href="https://circt.llvm.org/docs/Dialects/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://circt.llvm.org/docs/Dialects/ESIAppID/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESIAppID/</guid><description>InnerSymAttr Inner symbol definition
Defines the properties of an inner_sym attribute. It specifies the symbol name and symbol visibility for each field ID. For any ground types, there are no subfields and the field ID is 0. For aggregate types, a unique field ID is assigned to each field by visiting them in a depth-first pre-order. The custom assembly format ensures that for ground types, only @&amp;lt;sym_name&amp;gt; is printed.</description></item><item><title>'arc' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Arc/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Arc/</guid><description>Canonical representation of state transfer in a circuit This is the arc dialect, useful for representing state transfer functions in a circuit.
Operations arc.alloc_memory (circt::arc::AllocMemoryOp) arc.alloc_state (circt::arc::AllocStateOp) arc.alloc_storage (circt::arc::AllocStorageOp) arc.call (circt::arc::CallOp) arc.clock_domain (circt::arc::ClockDomainOp) arc.clock_tree (circt::arc::ClockTreeOp) arc.define (circt::arc::DefineOp) arc.lut (circt::arc::LutOp) arc.memory (circt::arc::MemoryOp) arc.memory_read (circt::arc::MemoryReadOp) arc.memory_read_port (circt::arc::MemoryReadPortOp) arc.memory_write (circt::arc::MemoryWriteOp) arc.memory_write_port (circt::arc::MemoryWritePortOp) arc.model (circt::arc::ModelOp) arc.output (circt::arc::OutputOp) arc.passthrough (circt::arc::PassThroughOp) arc.root_input (circt::arc::RootInputOp) arc.root_output (circt::arc::RootOutputOp) arc.sim.emit (circt::arc::SimEmitValueOp) arc.sim.get_port (circt::arc::SimGetPortOp) arc.sim.instantiate (circt::arc::SimInstantiateOp) arc.sim.set_input (circt::arc::SimSetInputOp) arc.sim.step (circt::arc::SimStepOp) arc.</description></item><item><title>'calyx' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Calyx/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Calyx/</guid><description>Types and operations for the Calyx dialect Calyx is an intermediate language and infrastructure for building compilers that generate custom hardware accelerators. For more information, visit the documentation.
Operations calyx.assign (::circt::calyx::AssignOp) calyx.comb_component (::circt::calyx::CombComponentOp) calyx.comb_group (::circt::calyx::CombGroupOp) calyx.component (::circt::calyx::ComponentOp) calyx.control (::circt::calyx::ControlOp) calyx.cycle (::circt::calyx::CycleOp) calyx.enable (::circt::calyx::EnableOp) calyx.group (::circt::calyx::GroupOp) calyx.group_done (::circt::calyx::GroupDoneOp) calyx.group_go (::circt::calyx::GroupGoOp) calyx.if (::circt::calyx::IfOp) calyx.instance (::circt::calyx::InstanceOp) calyx.invoke (::circt::calyx::InvokeOp) calyx.memory (::circt::calyx::MemoryOp) calyx.par (::circt::calyx::ParOp) calyx.primitive (::circt::calyx::PrimitiveOp) calyx.register (::circt::calyx::RegisterOp) calyx.repeat (::circt::calyx::RepeatOp) calyx.seq (::circt::calyx::SeqOp) calyx.seq_mem (::circt::calyx::SeqMemoryOp) calyx.</description></item><item><title>'chirrtl' Dialect</title><link>https://circt.llvm.org/docs/Dialects/CHIRRTL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/CHIRRTL/</guid><description>Types and operations for the chirrtl dialect This dialect defines the chirrtl dialect, which contains high-level memory defintions which can be lowered to FIRRTL.
Operations chirrtl.combmem (::circt::chirrtl::CombMemOp) chirrtl.debugport (::circt::chirrtl::MemoryDebugPortOp) chirrtl.memoryport (::circt::chirrtl::MemoryPortOp) chirrtl.memoryport.access (::circt::chirrtl::MemoryPortAccessOp) chirrtl.seqmem (::circt::chirrtl::SeqMemOp) Types CMemoryPortType CMemoryType Operations chirrtl.combmem (::circt::chirrtl::CombMemOp) Define a new combinational memory
Syntax:
operation ::= `chirrtl.combmem` (`sym` $inner_sym^)? `` custom&amp;lt;NameKind&amp;gt;($nameKind) `` custom&amp;lt;CombMemOp&amp;gt;(attr-dict) `:` qualified(type($result)) Define a new behavioral combinational memory. Combinational memories have a write latency of 1 and a read latency of 0.</description></item><item><title>'llhd' Dialect</title><link>https://circt.llvm.org/docs/Dialects/LLHD/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/LLHD/</guid><description>A low-level hardware description dialect in MLIR.
Operations llhd.con (::circt::llhd::ConnectOp) llhd.constant_time (::circt::llhd::ConstantTimeOp) llhd.drv (::circt::llhd::DrvOp) llhd.entity (::circt::llhd::EntityOp) llhd.halt (::circt::llhd::HaltOp) llhd.inst (::circt::llhd::InstOp) llhd.load (::circt::llhd::LoadOp) llhd.output (::circt::llhd::OutputOp) llhd.prb (::circt::llhd::PrbOp) llhd.proc (::circt::llhd::ProcOp) llhd.ptr.array_get (::circt::llhd::PtrArrayGetOp) llhd.ptr.array_slice (::circt::llhd::PtrArraySliceOp) llhd.ptr.extract (::circt::llhd::PtrExtractOp) llhd.ptr.struct_extract (::circt::llhd::PtrStructExtractOp) llhd.reg (::circt::llhd::RegOp) llhd.sig (::circt::llhd::SigOp) llhd.sig.array_get (::circt::llhd::SigArrayGetOp) llhd.sig.array_slice (::circt::llhd::SigArraySliceOp) llhd.sig.extract (::circt::llhd::SigExtractOp) llhd.sig.struct_extract (::circt::llhd::SigStructExtractOp) llhd.store (::circt::llhd::StoreOp) llhd.var (::circt::llhd::VarOp) llhd.wait (::circt::llhd::WaitOp) Attributes TimeAttr Type constraints LLHD time type Types PtrType SigType TimeType Operations llhd.con (::circt::llhd::ConnectOp) Connect two signals.</description></item><item><title>'ltl' Dialect</title><link>https://circt.llvm.org/docs/Dialects/LTL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/LTL/</guid><description>This dialect provides operations and types to model Linear Temporal Logic, sequences, and properties, which are useful for hardware verification.
Rationale Sequences and Properties Representing SVAs Sequence Concatenation and Cycle Delay Implication Clocking Disable Iff Representing the LTL Formalism Next / Delay Concatenation Types Overview PropertyType SequenceType Operations ltl.and (circt::ltl::AndOp) ltl.clock (circt::ltl::ClockOp) ltl.concat (circt::ltl::ConcatOp) ltl.delay (circt::ltl::DelayOp) ltl.disable (circt::ltl::DisableOp) ltl.eventually (circt::ltl::EventuallyOp) ltl.implication (circt::ltl::ImplicationOp) ltl.not (circt::ltl::NotOp) ltl.or (circt::ltl::OrOp) Rationale The main goal of the ltl dialect is to capture the core formalism underpinning SystemVerilog Assertions (SVAs), the de facto standard for describing temporal logic sequences and properties in hardware verification.</description></item><item><title>'moore' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Moore/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Moore/</guid><description>This dialect provides operations and types to capture a SystemVerilog design after parsing, type checking, and elaboration.
Rationale Types Operations moore.ashr (::circt::moore::AShrOp) moore.add (::circt::moore::AddOp) moore.and (::circt::moore::AndOp) moore.blocking_assign (::circt::moore::BlockingAssignOp) moore.bool_cast (::circt::moore::BoolCastOp) moore.case_eq (::circt::moore::CaseEqOp) moore.case_ne (::circt::moore::CaseNeOp) moore.concat (::circt::moore::ConcatOp) moore.constant (::circt::moore::ConstantOp) moore.assign (::circt::moore::ContinuousAssignOp) moore.conversion (::circt::moore::ConversionOp) moore.div (::circt::moore::DivOp) moore.eq (::circt::moore::EqOp) moore.ge (::circt::moore::GeOp) moore.gt (::circt::moore::GtOp) moore.instance (::circt::moore::InstanceOp) moore.le (::circt::moore::LeOp) moore.lt (::circt::moore::LtOp) moore.mod (::circt::moore::ModOp) moore.mul (::circt::moore::MulOp) moore.ne (::circt::moore::NeOp) moore.neg (::circt::moore::NegOp) moore.nonblocking_assign (::circt::moore::NonBlockingAssignOp) moore.not (::circt::moore::NotOp) moore.or (::circt::moore::OrOp) moore.</description></item><item><title>'msft' Dialect</title><link>https://circt.llvm.org/docs/Dialects/MSFT/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/MSFT/</guid><description>Microsoft internal support dialect Umbrella dialect for everything needed to support Microsoft development but not thoroughly discussed. Most (if not everything) in this dialect is a candidate for generalization and re-homing.
Operations msft.hlc.linear (::circt::msft::LinearOp) msft.instance.dynamic (::circt::msft::DynamicInstanceOp) msft.instance.hierarchy (::circt::msft::InstanceHierarchyOp) msft.instance.verb_attr (::circt::msft::DynamicInstanceVerbatimAttrOp) msft.output (::circt::msft::OutputOp) msft.pd.location (::circt::msft::PDPhysLocationOp) msft.pd.multicycle (::circt::msft::PDMulticycleOp) msft.pd.physregion (::circt::msft::PDPhysRegionOp) msft.pd.reg_location (::circt::msft::PDRegPhysLocationOp) msft.pe.output (::circt::msft::PEOutputOp) msft.physical_region (::circt::msft::DeclPhysicalRegionOp) msft.systolic.array (::circt::msft::SystolicArrayOp) Attributes LocationVectorAttr PhysLocationAttr PhysicalBoundsAttr Operations msft.hlc.linear (::circt::msft::LinearOp) Model of a linear datapath which can be arbitrarily pipelined</description></item><item><title>'sim' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Sim/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Sim/</guid><description>Types and operations for the sim dialect The sim dialect is intented to model simulator-specific operations.
Operations sim.fatal (::circt::sim::FatalOp) sim.finish (::circt::sim::FinishOp) sim.plusargs.test (::circt::sim::PlusArgsTestOp) sim.plusargs.value (::circt::sim::PlusArgsValueOp) Operations sim.fatal (::circt::sim::FatalOp) Simulation failure condition
Syntax:
operation ::= `sim.fatal` $clk `,` $cond attr-dict Operands: Operand Description clk A type for clock-carrying wires cond 1-bit signless integer sim.finish (::circt::sim::FinishOp) Simulation finish condition
Syntax:
operation ::= `sim.finish` $clk `,` $cond attr-dict Operands: Operand Description clk A type for clock-carrying wires cond 1-bit signless integer sim.</description></item><item><title>'verif' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Verif/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Verif/</guid><description>This dialect provides a collection of operations to express various verification concerns, such as assertions and interacting with a piece of hardware for the sake of verifying its proper functioning.
Operations verif.assert (circt::verif::AssertOp) verif.assume (circt::verif::AssumeOp) verif.cover (circt::verif::CoverOp) verif.format_verilog_string (circt::verif::FormatVerilogStringOp) verif.has_been_reset (circt::verif::HasBeenResetOp) verif.lec (circt::verif::LogicEquivalenceCheckingOp) verif.print (circt::verif::PrintOp) verif.yield (circt::verif::YieldOp) Operations verif.assert (circt::verif::AssertOp) Assert that a property holds.
Syntax:
operation ::= `verif.assert` $property (`label` $label^)? attr-dict `:` type($property) Attributes: AttributeMLIR TypeDescription label::mlir::StringAttrstring attribute Operands: Operand Description property 1-bit signless integer or LTL sequence type or LTL property type verif.</description></item><item><title>Debug Dialect</title><link>https://circt.llvm.org/docs/Dialects/Debug/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Debug/</guid><description>This dialect provides operations and types to interleave debug information (DI) with other parts of the IR.
Rationale Representations Representing Source Language Constructs Tracking Inlined Modules Types Overview ArrayType ScopeType StructType Operations dbg.array (circt::debug::ArrayOp) dbg.scope (circt::debug::ScopeOp) dbg.struct (circt::debug::StructOp) dbg.variable (circt::debug::VariableOp) Rationale The main goal of the debug dialect is to provide a mechanism to track the correspondence between values, types, and hierarchy of a source language and the IR being compiled and transformed.</description></item><item><title>SMT Dialect</title><link>https://circt.llvm.org/docs/Dialects/SMT/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/SMT/</guid><description>This dialect provides types and operations modeling the SMT (Satisfiability Modulo Theories) operations and datatypes commonly found in SMT-LIB and SMT solvers.
Rationale Dialect Structure Optimizations Backends LLVM IR SMT-LIB C/C++ Handling counter-examples Non-Goals Operations smt.and (circt::smt::AndOp) smt.apply_func (circt::smt::ApplyFuncOp) smt.array.broadcast (circt::smt::ArrayBroadcastOp) smt.array.select (circt::smt::ArraySelectOp) smt.array.store (circt::smt::ArrayStoreOp) smt.assert (circt::smt::AssertOp) smt.bv.ashr (circt::smt::BVAShrOp) smt.bv.add (circt::smt::BVAddOp) smt.bv.and (circt::smt::BVAndOp) smt.bv.cmp (circt::smt::BVCmpOp) smt.bv.constant (circt::smt::BVConstantOp) smt.bv.lshr (circt::smt::BVLShrOp) smt.bv.mul (circt::smt::BVMulOp) smt.bv.neg (circt::smt::BVNegOp) smt.bv.not (circt::smt::BVNotOp) smt.bv.or (circt::smt::BVOrOp) smt.bv.sdiv (circt::smt::BVSDivOp) smt.bv.smod (circt::smt::BVSModOp) smt.</description></item></channel></rss>