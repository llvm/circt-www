<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Formal Verification Tooling - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/FormalVerification/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>Formal Verification Tooling</h1><p>Formally verifying hardware designs is a crucial step during the development
process. Various techniques exist, such as logical equivalence checking, model
checking, symbolic execution, etc. The preferred technique depends on the level
of abstraction, the kind of properties to be verified, runtime limitations, etc.
As a hardware compiler collection, CIRCT provides infrastructure to implement
formal verification tooling and already comes with a few tools for common
use-cases. This document provides an introduction to those tools and gives and
overview over the underlying infrastructure for compiler engineers who want to
use CIRCT to implement their custom verification tool.</p><p><nav id=TableOfContents><ul><li><a href=#logical-equivalence-checking>Logical Equivalence Checking</a></li><li><a href=#bounded-model-checking>Bounded Model Checking</a></li><li><a href=#infrastructure-overview>Infrastructure Overview</a><ul><li><a href=#building-a-custom-lec-tool>Building a custom LEC tool</a></li><li><a href=#draft-building-a-bmc-tool>(Draft) Building a BMC tool</a></li></ul></li></ul></nav><h2 id=logical-equivalence-checking>Logical Equivalence Checking&nbsp;<a class=headline-hash href=#logical-equivalence-checking>¶</a></h2><p>The <code>circt-lec</code> tool takes one or two MLIR input files with operations of the
HW, Comb, and Seq dialects and the names of two modules to check for
equivalence. To get to know the exact CLI command type <code>circt-lec --help</code>.</p><p>For example, the below IR contains two modules <code>@mulByTwo</code> and <code>@add</code>. Calling
<code>circt-lec input.mlir -c1=mulByTwo -c2=add</code> will output <code>c1 == c2</code> since they
are semantically equivalent.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// input.mlir
</span></span></span><span class=line><span class=cl><span class=c></span>hw<span class=p>.</span>module <span class=nf>@mulByTwo</span><span class=p>(</span>in <span class=nv>%in</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> out out<span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  dbg<span class=p>.</span>variable <span class=s>&#34;in&#34;</span><span class=p>,</span> <span class=nv>%in</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%two</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  dbg<span class=p>.</span>variable <span class=s>&#34;two&#34;</span><span class=p>,</span> <span class=nv>%two</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%res</span> <span class=p>=</span> comb<span class=p>.</span>mul <span class=nv>%in</span><span class=p>,</span> <span class=nv>%two</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  hw<span class=p>.</span>output <span class=nv>%res</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>hw<span class=p>.</span>module <span class=nf>@add</span><span class=p>(</span>in <span class=nv>%in</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> out out<span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  dbg<span class=p>.</span>variable <span class=s>&#34;in&#34;</span><span class=p>,</span> <span class=nv>%in</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%res</span> <span class=p>=</span> comb<span class=p>.</span>add <span class=nv>%in</span><span class=p>,</span> <span class=nv>%in</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  hw<span class=p>.</span>output <span class=nv>%res</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In the above example, the MLIR file is compiled to LLVM IR which is then passed
to the LLVM JIT compiler to directly output the LEC result. Alternatively, there
are command line flags to print the LEC problem in SMT-LIB, LLVM IR, or an
object file that can be linked against the Z3 SMT solver to produce a standalone
binary.</p><h2 id=bounded-model-checking>Bounded Model Checking&nbsp;<a class=headline-hash href=#bounded-model-checking>¶</a></h2><p>TODO</p><h2 id=infrastructure-overview>Infrastructure Overview&nbsp;<a class=headline-hash href=#infrastructure-overview>¶</a></h2><p>This section provides and overview over the relevant dialects and passes for
building formal verification tools based on CIRCT. The
<a href=/includes/img/smt_based_formal_verification_infra.svg>below diagram</a> provides
a visual overview.</p><p align=center><img src=/includes/img/smt_based_formal_verification_infra.svg></p><p>The overall flow will insert an explicit operation to specify the verification
problem (e.g., <code>verif.lec</code>, <code>verif.bmc</code>). This operation could then be lowered
to an encoding in SMT, an interactive theorem prover, a BDD, or potentially
being exported to existing tools (currently only SMT is supported). Each of
those might have their own different backend paths as well. E.g., an encoding in
SMT can be exported to SMT-LIB or lowered to LLVM IR that calls the Z3 solver.</p><p>In the following sections we are going to explain this lowering hierarchy in
more detail by looking at an example of SMT based LEC.</p><h3 id=building-a-custom-lec-tool>Building a custom LEC tool&nbsp;<a class=headline-hash href=#building-a-custom-lec-tool>¶</a></h3><p>Let&rsquo;s suppose we want to implement our own custom LEC tool for our novel HDL
which lowers to a CIRCT/MLIR based IR. There are two ways to implement this:</p><ol><li>Lower this IR to the CIRCT core representation (HW, Comb, Seq) and just use
the same pipeline as <code>circt-lec</code>. This has the advantage that we don&rsquo;t need to
think about SMT encodings and we might already compile to those dialects anyway
for Verilog emission.</li><li>Implement a pass that sets up the LEC problem (lowering to the <code>verif.lec</code>
operation), and another pass that encodes the IRs operations and types in SMT
(i.e., a lowering pass to the SMT dialect). This has the advantage that
higher-level information from the IR could be taken advantage of to provide a
more efficient SMT encoding.</li></ol><p>Consider the code example from the
<a href=#Logical-Equivalence-Checking>Logical Equivalence Checking section</a> above. In
the first phase, the input IR is transformed to explicitly represent the LEC
statement using the <code>verif.lec</code> operation leading to the following IR.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// return values indicate:
</span></span></span><span class=line><span class=cl><span class=c>// * equivalent?
</span></span></span><span class=line><span class=cl><span class=c>// * counter-example available?
</span></span></span><span class=line><span class=cl><span class=c>// * counter-example value for input (undefined if not availbable)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span><span class=p>:</span><span class=nl>3 =</span> verif<span class=p>.</span>lec first <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%in</span><span class=p>:</span> <span class=k>i32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  dbg<span class=p>.</span>variable <span class=s>&#34;in&#34;</span><span class=p>,</span> <span class=nv>%in</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c2_i32</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  dbg<span class=p>.</span>variable <span class=s>&#34;two&#34;</span><span class=p>,</span> <span class=nv>%c2_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> comb<span class=p>.</span>mul <span class=nv>%in</span><span class=p>,</span> <span class=nv>%c2_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  verif<span class=p>.</span>yield <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span> second <span class=p>{</span> 
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%in</span><span class=p>:</span> <span class=k>i32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  dbg<span class=p>.</span>variable <span class=s>&#34;in&#34;</span><span class=p>,</span> <span class=nv>%in</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> comb<span class=p>.</span>add <span class=nv>%in</span><span class=p>,</span> <span class=nv>%in</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  verif<span class=p>.</span>yield <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>-&gt;</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i32</span>
</span></span></code></pre></div><p>The number of inputs and outputs and their types must match between the first
and second circuit. All regions are isolated from above.</p><p>For more information about the <code>verif.lec</code> operation, refer to the Verif Dialect
documentation.</p><p>In the second phase, we decide to use the SMT backend for solving the LEC
statement and thus call the lowering pass to SMT and provide it the conversion
patterns necessary to encode all the operations present in the IR in terms of
SMT formulae. In our case, that consists of the already provided lowerings for
<code>comb</code>, <code>hw</code>, and <code>verif</code>. The result of this lowering is the following SMT
encoding.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// return values indicate:
</span></span></span><span class=line><span class=cl><span class=c>// * equivalent?
</span></span></span><span class=line><span class=cl><span class=c>// * counter-example for &#34;in&#34; available?
</span></span></span><span class=line><span class=cl><span class=c>// * counter-example value for &#34;in&#34; (undefined if not availbable)
</span></span></span><span class=line><span class=cl><span class=c>// * counter-example for &#34;two&#34; available?
</span></span></span><span class=line><span class=cl><span class=c>// * counter-example value for &#34;two&#34; (undefined if not availbable)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span><span class=p>:</span><span class=nl>5 =</span> smt<span class=p>.</span>solver <span class=p>(&lt;</span>non<span class=err>-</span>smt<span class=err>-</span>value<span class=err>-</span>passthrough<span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>                   <span class=p>&lt;</span>solver<span class=err>-</span>options<span class=err>-</span>attr<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// region is isolated from above
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%true</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> true
</span></span><span class=line><span class=cl>  <span class=nv>%false</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> false
</span></span><span class=line><span class=cl>  <span class=nv>%c0_i32</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> smt<span class=p>.</span>declare_fun <span class=s>&#34;in&#34;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span><span class=kt>constant</span> <span class=nv>#smt.bv</span><span class=p>&lt;</span><span class=m>2</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%2</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span>mul <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%3</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span>add <span class=nv>%0</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%4</span> <span class=p>=</span> smt<span class=p>.</span>distinct <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  smt<span class=p>.</span>assert <span class=nv>%4</span> <span class=c>// operand type is !smt.bool
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%5</span><span class=p>:</span><span class=nl>3 =</span> smt<span class=p>.</span>check <span class=p>(&lt;</span>optional<span class=err>-</span>assumptions<span class=p>&gt;)</span> sat <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%6</span><span class=p>:</span><span class=nl>2 =</span> smt<span class=p>.</span>eval <span class=nv>%0</span> <span class=p>:</span> <span class=p>(!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i1</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nv>%7</span><span class=p>:</span><span class=nl>2 =</span> smt<span class=p>.</span>eval <span class=nv>%1</span> <span class=p>:</span> <span class=p>(!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i1</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    smt<span class=p>.</span>yield <span class=nv>%false</span><span class=p>,</span> <span class=nv>%6#0</span><span class=p>,</span> <span class=nv>%6#1</span><span class=p>,</span> <span class=nv>%7#0</span><span class=p>,</span> <span class=nv>%7#1</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> unknown <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c>// could request a message on why it is unknown from the solver
</span></span></span><span class=line><span class=cl><span class=c></span>    smt<span class=p>.</span>yield <span class=nv>%false</span><span class=p>,</span> <span class=nv>%false</span><span class=p>,</span> <span class=nv>%c0_i32</span><span class=p>,</span> <span class=nv>%false</span><span class=p>,</span> <span class=nv>%c0_i32</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> unsat <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c>// could request a proof from the solver here
</span></span></span><span class=line><span class=cl><span class=c></span>    smt<span class=p>.</span>yield <span class=nv>%true</span><span class=p>,</span> <span class=nv>%false</span><span class=p>,</span> <span class=nv>%c0_i32</span><span class=p>,</span> <span class=nv>%false</span><span class=p>,</span> <span class=nv>%c0_i32</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=p>-&gt;</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  smt<span class=p>.</span>yield <span class=nv>%5#0</span><span class=p>,</span> <span class=nv>%5#1</span><span class=p>,</span> <span class=nv>%5#2</span><span class=p>,</span> <span class=nv>%5#3</span><span class=p>,</span> <span class=nv>%5#4</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=c>// no smt values may escape here
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span><span class=line><span class=cl>dbg<span class=p>.</span>variable <span class=s>&#34;in&#34;</span><span class=p>,</span> <span class=nv>%0#2</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>dbg<span class=p>.</span>variable <span class=s>&#34;two&#34;</span><span class=p>,</span> <span class=nv>%0#4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=c>// TODO: how to encode that the debug variables are only
</span></span></span><span class=line><span class=cl><span class=c>// conditionally available?
</span></span></span><span class=line><span class=cl><span class=c>// Logic to report the result and potential counter-example
</span></span></span><span class=line><span class=cl><span class=c>// to the user goes here (potentially using the debug
</span></span></span><span class=line><span class=cl><span class=c>// dialect operations)
</span></span></span></code></pre></div><p>This SMT IR can then be lowered through one of the available backends (e.g.,
SMT-LIB, LLVM IR). Note that the SMT-LIB exporter as some considerable
restrictions on the kind of SMT IR it accepts. The ones relevant for the above
example are:</p><ul><li>When exporting to SMT-LIB the <code>smt.check</code> must not return any values and all
regions must be empty. Usually, the solver prints <code>sat</code>, <code>unknown</code>, or <code>unsat</code>
to indicate the result.</li><li>The <code>smt.solver</code> operation must not have any return values and no passthrough
arguments</li><li>Optional assumptions in <code>smt.check</code> must be empty</li></ul><p>For more information, refer to the SMT Dialect documentation.</p><h3 id=draft-building-a-bmc-tool>(Draft) Building a BMC tool&nbsp;<a class=headline-hash href=#draft-building-a-bmc-tool>¶</a></h3><p>For completeness, this section describes how a BMC (bounded model checking)
compilation flow could look like using this intrastructure.
<strong>Note:</strong> this is just a preliminary draft for now</p><p>The flow for model checking is very similar to the LEC flow above, just using
<code>verif.bmc</code> instead of <code>verif.lec</code>. Obviously, the <code>seq</code> dialect is treated
vastly different, but <code>comb</code> and <code>hw</code> are handled the same way. Custom SMT
encodings can take advantage of this to implement both a LEC and BMC tool with
only one SMT encoding or provide separate lowering passes if necessary (or
preferred).</p><p>Let&rsquo;s consider the following hardware module that implements an accumulator
which only takes even numbers as input, the output of the module is the inverted
state of the accumulator register, therefore it should always be odd.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>hw<span class=p>.</span>module <span class=nf>@mod</span><span class=p>(</span>in <span class=nv>%clk</span><span class=p>:</span> <span class=p>!</span>seq<span class=p>.</span>clock<span class=p>,</span> in <span class=nv>%arg0</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> in <span class=nv>%rst</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               in <span class=nv>%rst_val</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> out out<span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c</span><span class=m>-1</span><span class=nl>_i32 =</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>-1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c0_i32</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c2_i32</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> comb<span class=p>.</span>modu <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%c2_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> comb<span class=p>.</span>icmp eq<span class=p>,</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%c0_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  verif<span class=p>.</span>assume <span class=nv>%1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  <span class=nv>%2</span> <span class=p>=</span> comb<span class=p>.</span>modu <span class=nv>%rst_val</span><span class=p>,</span> <span class=nv>%c2_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%3</span> <span class=p>=</span> comb<span class=p>.</span>icmp eq<span class=p>,</span> <span class=nv>%2</span><span class=p>,</span> <span class=nv>%c0_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  verif<span class=p>.</span>assume <span class=nv>%3</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  <span class=nv>%4</span> <span class=p>=</span> comb<span class=p>.</span>xor <span class=nv>%rst</span><span class=p>,</span> <span class=nv>%true</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  <span class=nv>%5</span> <span class=p>=</span> ltl<span class=p>.</span>delay <span class=nv>%4</span><span class=p>,</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  <span class=nv>%6</span> <span class=p>=</span> ltl<span class=p>.</span>concat <span class=nv>%rst</span><span class=p>,</span> <span class=nv>%5</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=p>!</span>ltl<span class=p>.</span>sequence
</span></span><span class=line><span class=cl>  <span class=nv>%7</span> <span class=p>=</span> ltl<span class=p>.</span>clock <span class=nv>%6</span><span class=p>,</span> posedge <span class=nv>%clk</span> <span class=p>:</span> <span class=p>!</span>ltl<span class=p>.</span>sequence
</span></span><span class=line><span class=cl>  verif<span class=p>.</span>assume <span class=nv>%7</span> <span class=p>:</span> <span class=p>!</span>ltl<span class=p>.</span>sequence
</span></span><span class=line><span class=cl>  <span class=nv>%state0</span> <span class=p>=</span> seq<span class=p>.</span>compreg <span class=nv>%8</span><span class=p>,</span> <span class=nv>%clk</span> reset <span class=nv>%rst</span><span class=p>,</span> <span class=nv>%rst_val</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%8</span> <span class=p>=</span> comb<span class=p>.</span>add <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%state0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%9</span> <span class=p>=</span> comb<span class=p>.</span>xor <span class=nv>%state0</span><span class=p>,</span> <span class=nv>%c</span><span class=m>-1</span>_i32 <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%10</span> <span class=p>=</span> comb<span class=p>.</span>modu <span class=nv>%9</span><span class=p>,</span> <span class=nv>%c2_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%11</span> <span class=p>=</span> comb<span class=p>.</span>icmp eq<span class=p>,</span> <span class=nv>%10</span><span class=p>,</span> <span class=nv>%c0_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  verif<span class=p>.</span>assert <span class=nv>%11</span>
</span></span><span class=line><span class=cl>  hw<span class=p>.</span>output <span class=nv>%9</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This could be lowered to a dedicated BMC operation like the following. Note that
the register was removed and instead the register state is added as an
additional input and output representing the old and the new state respectively.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>verif<span class=p>.</span>bmc bound <span class=m>10</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%clk</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=nv>%arg0</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%rst</span><span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=nv>%rst_val</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%state0</span><span class=p>:</span> <span class=k>i32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nv>%true</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> true
</span></span><span class=line><span class=cl>  <span class=nv>%c0_i32</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c1_i32</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c2_i32</span> <span class=p>=</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c</span><span class=m>-1</span><span class=nl>_i32 =</span> hw<span class=p>.</span><span class=kt>constant</span> <span class=m>-1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> comb<span class=p>.</span>modu <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%c2_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> comb<span class=p>.</span>icmp eq<span class=p>,</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%c0_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  verif<span class=p>.</span>assume <span class=nv>%1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  <span class=nv>%2</span> <span class=p>=</span> comb<span class=p>.</span>modu <span class=nv>%rst_val</span><span class=p>,</span> <span class=nv>%c2_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%3</span> <span class=p>=</span> comb<span class=p>.</span>icmp eq<span class=p>,</span> <span class=nv>%2</span><span class=p>,</span> <span class=nv>%c0_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  verif<span class=p>.</span>assume <span class=nv>%3</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  <span class=nv>%4</span> <span class=p>=</span> comb<span class=p>.</span>xor <span class=nv>%rst</span><span class=p>,</span> <span class=nv>%true</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  <span class=nv>%5</span> <span class=p>=</span> ltl<span class=p>.</span>delay <span class=nv>%4</span><span class=p>,</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  <span class=nv>%6</span> <span class=p>=</span> ltl<span class=p>.</span>concat <span class=nv>%rst</span><span class=p>,</span> <span class=nv>%5</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=p>!</span>ltl<span class=p>.</span>sequence
</span></span><span class=line><span class=cl>  <span class=nv>%7</span> <span class=p>=</span> ltl<span class=p>.</span>clock <span class=nv>%6</span><span class=p>,</span> posedge <span class=nv>%clk</span> <span class=p>:</span> <span class=p>!</span>ltl<span class=p>.</span>sequence
</span></span><span class=line><span class=cl>  verif<span class=p>.</span>assume <span class=nv>%7</span> <span class=p>:</span> <span class=p>!</span>ltl<span class=p>.</span>sequence
</span></span><span class=line><span class=cl>  <span class=nv>%8</span> <span class=p>=</span> comb<span class=p>.</span>add <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%state0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%9</span> <span class=p>=</span> comb<span class=p>.</span>xor <span class=nv>%state0</span><span class=p>,</span> <span class=nv>%c</span><span class=m>-1</span>_i32 <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%10</span> <span class=p>=</span> comb<span class=p>.</span>modu <span class=nv>%9</span><span class=p>,</span> <span class=nv>%c2_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%11</span> <span class=p>=</span> comb<span class=p>.</span>icmp eq<span class=p>,</span> <span class=nv>%10</span><span class=p>,</span> <span class=nv>%c1_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  verif<span class=p>.</span>assert <span class=nv>%11</span>
</span></span><span class=line><span class=cl>  <span class=nv>%12</span> <span class=p>=</span> comb<span class=p>.</span>mux <span class=nv>%rst</span><span class=p>,</span> <span class=nv>%rst_val</span><span class=p>,</span> <span class=nv>%8</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  verif<span class=p>.</span>yield <span class=nv>%9</span><span class=p>,</span> <span class=nv>%12</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This CIRCT Core level representation of a BMC task can then be lowered to the
SMT dialect like the following.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@helper</span><span class=p>(</span><span class=nv>%cycle</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%prev_clk</span><span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=nv>%clk</span><span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>                  <span class=nv>%state0</span><span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%zero</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span><span class=kt>constant</span> <span class=nv>#smt.bv</span><span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%one</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span><span class=kt>constant</span> <span class=nv>#smt.bv</span><span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c</span><span class=m>-1</span><span class=nl>_i32 =</span> smt<span class=p>.</span>bv<span class=p>.</span><span class=kt>constant</span> <span class=nv>#smt.bv</span><span class=p>&lt;</span><span class=m>-1</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%two</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span><span class=kt>constant</span> <span class=nv>#smt.bv</span><span class=p>&lt;</span><span class=m>2</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%arg0</span> <span class=p>=</span> smt<span class=p>.</span>declare_fun <span class=s>&#34;arg0&#34;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%rst</span> <span class=p>=</span> smt<span class=p>.</span>declare_fun <span class=s>&#34;rst&#34;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%rst_val</span> <span class=p>=</span> smt<span class=p>.</span>declare_fun <span class=s>&#34;rst_val&#34;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%smt_cycle</span> <span class=p>=</span> smt<span class=p>.</span>from_concrete <span class=nv>%cycle</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%true</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span><span class=kt>constant</span> <span class=nv>#smt.bv</span><span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%false</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span><span class=kt>constant</span> <span class=nv>#smt.bv</span><span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=c>// assumptions for this cycle 
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%2</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span>urem <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%two</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%3</span> <span class=p>=</span> smt<span class=p>.</span>eq <span class=nv>%2</span><span class=p>,</span> <span class=nv>%zero</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%4</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span>urem <span class=nv>%rst_val</span><span class=p>,</span> <span class=nv>%two</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%5</span> <span class=p>=</span> smt<span class=p>.</span>eq <span class=nv>%4</span><span class=p>,</span> <span class=nv>%zero</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%6</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span>cmp ult<span class=p>,</span> <span class=nv>%smt_cycle</span><span class=p>,</span> <span class=nv>%two</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%7</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span>cmp uge<span class=p>,</span> <span class=nv>%smt_cycle</span><span class=p>,</span> <span class=nv>%two</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%8</span> <span class=p>=</span> smt<span class=p>.</span>eq <span class=nv>%rst</span><span class=p>,</span> <span class=nv>%true</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%9</span> <span class=p>=</span> smt<span class=p>.</span>and <span class=nv>%6</span><span class=p>,</span> <span class=nv>%8</span>
</span></span><span class=line><span class=cl>  <span class=nv>%10</span> <span class=p>=</span> smt<span class=p>.</span>eq <span class=nv>%rst</span><span class=p>,</span> <span class=nv>%false</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%11</span> <span class=p>=</span> smt<span class=p>.</span>and <span class=nv>%7</span><span class=p>,</span> <span class=nv>%10</span>
</span></span><span class=line><span class=cl>  <span class=nv>%12</span> <span class=p>=</span> smt<span class=p>.</span>or <span class=nv>%9</span><span class=p>,</span> <span class=nv>%11</span>
</span></span><span class=line><span class=cl>  <span class=nv>%assumption</span> <span class=p>=</span> smt<span class=p>.</span>and <span class=nv>%3</span><span class=p>,</span> <span class=nv>%5</span><span class=p>,</span> <span class=nv>%12</span>
</span></span><span class=line><span class=cl>  <span class=c>// circuit lowered to smt
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%13</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span>add <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%state0</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%14</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span>xor <span class=nv>%state0</span><span class=p>,</span> <span class=nv>%c</span><span class=m>-1</span>_i32 <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%15</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span>urem <span class=nv>%14</span><span class=p>,</span> <span class=nv>%two</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%16</span> <span class=p>=</span> smt<span class=p>.</span>eq <span class=nv>%15</span><span class=p>,</span> <span class=nv>%one</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%17</span> <span class=p>=</span> smt<span class=p>.</span>implies <span class=nv>%assumption</span><span class=p>,</span> <span class=nv>%16</span>
</span></span><span class=line><span class=cl>  smt<span class=p>.</span>assert <span class=nv>%17</span>
</span></span><span class=line><span class=cl>  <span class=nv>%18</span> <span class=p>=</span> smt<span class=p>.</span>ite <span class=nv>%rst</span><span class=p>,</span> <span class=nv>%rst_val</span><span class=p>,</span> <span class=nv>%13</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%19</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span>not <span class=nv>%prev_clk</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%posedge</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span>and <span class=nv>%clk</span><span class=p>,</span> <span class=nv>%19</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%20</span> <span class=p>=</span> smt<span class=p>.</span>ite <span class=nv>%posedge</span><span class=p>,</span> <span class=nv>%18</span><span class=p>,</span> <span class=nv>%state0</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=kt>return</span> <span class=nv>%20</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>smt<span class=p>.</span>solver <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%state0_init</span> <span class=p>=</span> smt<span class=p>.</span>declare_fun <span class=s>&#34;state0&#34;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  scf<span class=p>.</span>for <span class=nv>%i</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>10</span> step <span class=m>1</span> iter_args<span class=p>(</span><span class=nv>%state0</span> <span class=p>=</span> <span class=nv>%state0_init</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%clk</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span><span class=kt>constant</span> <span class=nv>#smt.bv</span><span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%clk_nxt</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span><span class=kt>constant</span> <span class=nv>#smt.bv</span><span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%new_state0</span> <span class=p>=</span> <span class=kt>func</span><span class=p>.</span>call <span class=nf>@helper</span><span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%clk_nxt</span><span class=p>,</span> <span class=nv>%clk</span><span class=p>,</span> <span class=nv>%state0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    smt<span class=p>.</span>check sat <span class=p>{}</span> unknown <span class=p>{}</span> unsat <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nv>%next_cycle_state0</span> <span class=p>=</span> <span class=kt>func</span><span class=p>.</span>call <span class=nf>@helper</span><span class=p>(</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%clk</span><span class=p>,</span> <span class=nv>%clk_nxt</span><span class=p>,</span> <span class=nv>%new_state0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    smt<span class=p>.</span>check sat <span class=p>{}</span> unknown <span class=p>{}</span> unsat <span class=p>{}</span>
</span></span><span class=line><span class=cl>    scf<span class=p>.</span>yield <span class=nv>%next_cycle_state0</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  smt<span class=p>.</span>yield
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c>// Note: the logic to report counter-examples is omitted here.
</span></span></span><span class=line><span class=cl><span class=c>// There are several ways to implement it, e.g.,
</span></span></span><span class=line><span class=cl><span class=c>// * don&#39;t let the solver generate fresh symbol names, but unique them in a
</span></span></span><span class=line><span class=cl><span class=c>//   principled way ourselves such that those identifiers can be used to
</span></span></span><span class=line><span class=cl><span class=c>//   reconstruct the SMT expression to evaluate against the model
</span></span></span><span class=line><span class=cl><span class=c>// * store the values representing the symbolic values (results of
</span></span></span><span class=line><span class=cl><span class=c>//   declare_fun) in some array and iterate over it in the sat region
</span></span></span><span class=line><span class=cl><span class=c>// TODO: exit the loop early
</span></span></span></code></pre></div><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/ToolsWorkarounds/ title="EDA Tool Workarounds"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - EDA Tool Workarounds</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/GettingStarted/ title="Getting Started with the CIRCT Project">Next - Getting Started with the CIRCT Project <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li class=active><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>