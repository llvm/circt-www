<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Passes - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Passes/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>Passes</h1><p>This document describes the available CIRCT passes and their contracts.</p><p><nav id=TableOfContents><ul><li><a href=#conversion-passes>Conversion Passes</a><ul><li><a href=#-calyx-native><code>-calyx-native</code></a></li><li><a href=#-calyx-remove-groups-fsm><code>-calyx-remove-groups-fsm</code></a></li><li><a href=#-convert-affine-to-loopschedule><code>-convert-affine-to-loopschedule</code></a></li><li><a href=#-convert-comb-to-arith><code>-convert-comb-to-arith</code></a></li><li><a href=#-convert-comb-to-smt><code>-convert-comb-to-smt</code></a></li><li><a href=#-convert-fsm-to-sv><code>-convert-fsm-to-sv</code></a></li><li><a href=#-convert-hw-to-btor2><code>-convert-hw-to-btor2</code></a></li><li><a href=#-convert-hw-to-llhd><code>-convert-hw-to-llhd</code></a></li><li><a href=#-convert-hw-to-llvm><code>-convert-hw-to-llvm</code></a></li><li><a href=#-convert-hw-to-smt><code>-convert-hw-to-smt</code></a></li><li><a href=#-convert-hw-to-systemc><code>-convert-hw-to-systemc</code></a></li><li><a href=#-convert-llhd-to-llvm><code>-convert-llhd-to-llvm</code></a></li><li><a href=#-convert-moore-to-core><code>-convert-moore-to-core</code></a></li><li><a href=#-convert-to-arcs><code>-convert-to-arcs</code></a></li><li><a href=#-convert-verif-to-smt><code>-convert-verif-to-smt</code></a></li><li><a href=#-export-chisel-interface><code>-export-chisel-interface</code></a></li><li><a href=#-export-split-chisel-interface><code>-export-split-chisel-interface</code></a></li><li><a href=#-export-split-verilog><code>-export-split-verilog</code></a></li><li><a href=#-export-verilog><code>-export-verilog</code></a></li><li><a href=#-handshake-remove-block-structure><code>-handshake-remove-block-structure</code></a></li><li><a href=#-hw-lower-instance-choices><code>-hw-lower-instance-choices</code></a></li><li><a href=#-legalize-anon-enums><code>-legalize-anon-enums</code></a></li><li><a href=#-lower-arc-to-llvm><code>-lower-arc-to-llvm</code></a></li><li><a href=#-lower-calyx-to-fsm><code>-lower-calyx-to-fsm</code></a></li><li><a href=#-lower-calyx-to-hw><code>-lower-calyx-to-hw</code></a></li><li><a href=#-lower-cf-to-handshake><code>-lower-cf-to-handshake</code></a></li><li><a href=#-lower-dc-to-hw><code>-lower-dc-to-hw</code></a></li><li><a href=#-lower-firrtl-to-hw><code>-lower-firrtl-to-hw</code></a></li><li><a href=#-lower-handshake-to-dc><code>-lower-handshake-to-dc</code></a></li><li><a href=#-lower-handshake-to-hw><code>-lower-handshake-to-hw</code></a></li><li><a href=#-lower-hw-to-sv><code>-lower-hw-to-sv</code></a></li><li><a href=#-lower-hwarith-to-hw><code>-lower-hwarith-to-hw</code></a></li><li><a href=#-lower-loopschedule-to-calyx><code>-lower-loopschedule-to-calyx</code></a></li><li><a href=#-lower-pipeline-to-hw><code>-lower-pipeline-to-hw</code></a></li><li><a href=#-lower-scf-to-calyx><code>-lower-scf-to-calyx</code></a></li><li><a href=#-lower-seq-firmem><code>-lower-seq-firmem</code></a></li><li><a href=#-lower-seq-to-sv><code>-lower-seq-to-sv</code></a></li><li><a href=#-lower-sim-to-sv><code>-lower-sim-to-sv</code></a></li><li><a href=#-lower-verif-to-sv><code>-lower-verif-to-sv</code></a></li><li><a href=#-materialize-calyx-to-fsm><code>-materialize-calyx-to-fsm</code></a></li><li><a href=#-prepare-for-emission><code>-prepare-for-emission</code></a></li><li><a href=#-test-apply-lowering-options><code>-test-apply-lowering-options</code></a></li></ul></li><li><a href=#arc-dialect-passes>Arc Dialect Passes</a><ul><li><a href=#-arc-add-taps><code>-arc-add-taps</code></a></li><li><a href=#-arc-allocate-state><code>-arc-allocate-state</code></a></li><li><a href=#-arc-canonicalizer><code>-arc-canonicalizer</code></a></li><li><a href=#-arc-dedup><code>-arc-dedup</code></a></li><li><a href=#-arc-group-resets-and-enables><code>-arc-group-resets-and-enables</code></a></li><li><a href=#-arc-infer-memories><code>-arc-infer-memories</code></a></li><li><a href=#-arc-infer-state-properties><code>-arc-infer-state-properties</code></a></li><li><a href=#-arc-inline><code>-arc-inline</code></a></li><li><a href=#-arc-inline-modules><code>-arc-inline-modules</code></a></li><li><a href=#-arc-isolate-clocks><code>-arc-isolate-clocks</code></a></li><li><a href=#-arc-latency-retiming><code>-arc-latency-retiming</code></a></li><li><a href=#-arc-legalize-state-update><code>-arc-legalize-state-update</code></a></li><li><a href=#-arc-lower-arcs-to-funcs><code>-arc-lower-arcs-to-funcs</code></a></li><li><a href=#-arc-lower-clocks-to-funcs><code>-arc-lower-clocks-to-funcs</code></a></li><li><a href=#-arc-lower-lut><code>-arc-lower-lut</code></a></li><li><a href=#-arc-lower-state><code>-arc-lower-state</code></a></li><li><a href=#-arc-lower-vectorizations><code>-arc-lower-vectorizations</code></a></li><li><a href=#-arc-make-tables><code>-arc-make-tables</code></a></li><li><a href=#-arc-mux-to-control-flow><code>-arc-mux-to-control-flow</code></a></li><li><a href=#-arc-simplify-variadic-ops><code>-arc-simplify-variadic-ops</code></a></li><li><a href=#-arc-split-loops><code>-arc-split-loops</code></a></li><li><a href=#-arc-strip-sv><code>-arc-strip-sv</code></a></li></ul></li><li><a href=#calyx-dialect-passes>Calyx Dialect Passes</a><ul><li><a href=#-calyx-clk-insertion><code>-calyx-clk-insertion</code></a></li><li><a href=#-calyx-compile-control><code>-calyx-compile-control</code></a></li><li><a href=#-calyx-gicm><code>-calyx-gicm</code></a></li><li><a href=#-calyx-go-insertion><code>-calyx-go-insertion</code></a></li><li><a href=#-calyx-remove-comb-groups><code>-calyx-remove-comb-groups</code></a></li></ul></li><li><a href=#example>Example</a><ul><li><a href=#-calyx-remove-groups><code>-calyx-remove-groups</code></a></li><li><a href=#-calyx-reset-insertion><code>-calyx-reset-insertion</code></a></li></ul></li><li><a href=#comb-dialect-passes>Comb Dialect Passes</a><ul><li><a href=#-lower-comb><code>-lower-comb</code></a></li></ul></li><li><a href=#dc-dialect-passes>DC Dialect Passes</a><ul><li><a href=#-dc-dematerialize-forks-sinks><code>-dc-dematerialize-forks-sinks</code></a></li><li><a href=#-dc-materialize-forks-sinks><code>-dc-materialize-forks-sinks</code></a></li></ul></li><li><a href=#esi-dialect-passes>ESI Dialect Passes</a><ul><li><a href=#-esi-appid-hier><code>-esi-appid-hier</code></a></li><li><a href=#-esi-build-manifest><code>-esi-build-manifest</code></a></li><li><a href=#-esi-clean-metadata><code>-esi-clean-metadata</code></a></li><li><a href=#-esi-connect-services><code>-esi-connect-services</code></a></li><li><a href=#-lower-esi-bundles><code>-lower-esi-bundles</code></a></li><li><a href=#-lower-esi-ports><code>-lower-esi-ports</code></a></li><li><a href=#-lower-esi-to-hw><code>-lower-esi-to-hw</code></a></li><li><a href=#-lower-esi-to-physical><code>-lower-esi-to-physical</code></a></li><li><a href=#-lower-esi-types><code>-lower-esi-types</code></a></li></ul></li><li><a href=#firrtl-dialect-passes>FIRRTL Dialect Passes</a><ul><li><a href=#-firrtl-add-seqmem-ports><code>-firrtl-add-seqmem-ports</code></a></li><li><a href=#-firrtl-blackbox-reader><code>-firrtl-blackbox-reader</code></a></li><li><a href=#-firrtl-check-comb-loops><code>-firrtl-check-comb-loops</code></a></li><li><a href=#-firrtl-dedup><code>-firrtl-dedup</code></a></li><li><a href=#-firrtl-drop-const><code>-firrtl-drop-const</code></a></li><li><a href=#-firrtl-drop-names><code>-firrtl-drop-names</code></a></li><li><a href=#-firrtl-emit-metadata><code>-firrtl-emit-metadata</code></a></li><li><a href=#-firrtl-emit-omir><code>-firrtl-emit-omir</code></a></li><li><a href=#-firrtl-expand-whens><code>-firrtl-expand-whens</code></a></li><li><a href=#-firrtl-extract-instances><code>-firrtl-extract-instances</code></a></li><li><a href=#-firrtl-finalize-ir><code>-firrtl-finalize-ir</code></a></li><li><a href=#-firrtl-flatten-memory><code>-firrtl-flatten-memory</code></a></li><li><a href=#-firrtl-grand-central><code>-firrtl-grand-central</code></a></li><li><a href=#-firrtl-hoist-passthrough><code>-firrtl-hoist-passthrough</code></a></li><li><a href=#-firrtl-imconstprop><code>-firrtl-imconstprop</code></a></li><li><a href=#-firrtl-imdeadcodeelim><code>-firrtl-imdeadcodeelim</code></a></li><li><a href=#-firrtl-infer-resets><code>-firrtl-infer-resets</code></a></li><li><a href=#-firrtl-infer-rw><code>-firrtl-infer-rw</code></a></li><li><a href=#-firrtl-infer-widths><code>-firrtl-infer-widths</code></a></li><li><a href=#-firrtl-inject-dut-hier><code>-firrtl-inject-dut-hier</code></a></li><li><a href=#-firrtl-inliner><code>-firrtl-inliner</code></a></li><li><a href=#-firrtl-inner-symbol-dce><code>-firrtl-inner-symbol-dce</code></a></li><li><a href=#-firrtl-layer-merge><code>-firrtl-layer-merge</code></a></li><li><a href=#-firrtl-layer-sink><code>-firrtl-layer-sink</code></a></li><li><a href=#-firrtl-lint><code>-firrtl-lint</code></a></li><li><a href=#-firrtl-lower-annotations><code>-firrtl-lower-annotations</code></a></li><li><a href=#-firrtl-lower-chirrtl><code>-firrtl-lower-chirrtl</code></a></li><li><a href=#-firrtl-lower-classes><code>-firrtl-lower-classes</code></a></li><li><a href=#-firrtl-lower-intmodules><code>-firrtl-lower-intmodules</code></a></li><li><a href=#-firrtl-lower-intrinsics><code>-firrtl-lower-intrinsics</code></a></li><li><a href=#-firrtl-lower-layers><code>-firrtl-lower-layers</code></a></li><li><a href=#-firrtl-lower-matches><code>-firrtl-lower-matches</code></a></li><li><a href=#-firrtl-lower-memory><code>-firrtl-lower-memory</code></a></li><li><a href=#-firrtl-lower-open-aggs><code>-firrtl-lower-open-aggs</code></a></li><li><a href=#-firrtl-lower-signatures><code>-firrtl-lower-signatures</code></a></li><li><a href=#-firrtl-lower-types><code>-firrtl-lower-types</code></a></li><li><a href=#-firrtl-lower-xmr><code>-firrtl-lower-xmr</code></a></li><li><a href=#-firrtl-materialize-debug-info><code>-firrtl-materialize-debug-info</code></a></li><li><a href=#-firrtl-mem-to-reg-of-vec><code>-firrtl-mem-to-reg-of-vec</code></a></li><li><a href=#-firrtl-passive-wires><code>-firrtl-passive-wires</code></a></li><li><a href=#-firrtl-prefix-modules><code>-firrtl-prefix-modules</code></a></li><li><a href=#-firrtl-print-field-source><code>-firrtl-print-field-source</code></a></li><li><a href=#-firrtl-print-instance-graph><code>-firrtl-print-instance-graph</code></a></li><li><a href=#-firrtl-print-nla-table><code>-firrtl-print-nla-table</code></a></li><li><a href=#-firrtl-probe-dce><code>-firrtl-probe-dce</code></a></li><li><a href=#-firrtl-randomize-register-init><code>-firrtl-randomize-register-init</code></a></li><li><a href=#-firrtl-register-optimizer><code>-firrtl-register-optimizer</code></a></li><li><a href=#-firrtl-remove-unused-ports><code>-firrtl-remove-unused-ports</code></a></li><li><a href=#-firrtl-resolve-paths><code>-firrtl-resolve-paths</code></a></li><li><a href=#-firrtl-resolve-traces><code>-firrtl-resolve-traces</code></a></li><li><a href=#-firrtl-sfc-compat><code>-firrtl-sfc-compat</code></a></li><li><a href=#-firrtl-specialize-option><code>-firrtl-specialize-option</code></a></li><li><a href=#-firrtl-vb-to-bv><code>-firrtl-vb-to-bv</code></a></li><li><a href=#-merge-connections><code>-merge-connections</code></a></li><li><a href=#-vectorization><code>-vectorization</code></a></li></ul></li><li><a href=#fsm-dialect-passes>FSM Dialect Passes</a><ul><li><a href=#-fsm-print-graph><code>-fsm-print-graph</code></a></li></ul></li><li><a href=#handshake-dialect-passes>Handshake Dialect Passes</a><ul><li><a href=#-handshake-add-ids><code>-handshake-add-ids</code></a></li><li><a href=#-handshake-dematerialize-forks-sinks><code>-handshake-dematerialize-forks-sinks</code></a></li><li><a href=#-handshake-insert-buffers><code>-handshake-insert-buffers</code></a></li><li><a href=#-handshake-legalize-memrefs><code>-handshake-legalize-memrefs</code></a></li><li><a href=#-handshake-lock-functions><code>-handshake-lock-functions</code></a></li><li><a href=#-handshake-lower-extmem-to-hw><code>-handshake-lower-extmem-to-hw</code></a></li><li><a href=#-handshake-materialize-forks-sinks><code>-handshake-materialize-forks-sinks</code></a></li><li><a href=#-handshake-op-count><code>-handshake-op-count</code></a></li><li><a href=#-handshake-print-dot><code>-handshake-print-dot</code></a></li><li><a href=#-handshake-remove-buffers><code>-handshake-remove-buffers</code></a></li></ul></li><li><a href=#hw-dialect-passes>HW Dialect Passes</a><ul><li><a href=#-hw-flatten-io><code>-hw-flatten-io</code></a></li><li><a href=#-hw-print-instance-graph><code>-hw-print-instance-graph</code></a></li><li><a href=#-hw-print-module-graph><code>-hw-print-module-graph</code></a></li><li><a href=#-hw-specialize><code>-hw-specialize</code></a></li><li><a href=#-hw-verify-irn><code>-hw-verify-irn</code></a></li></ul></li><li><a href=#ibis-dialect-passes>Ibis Dialect Passes</a><ul><li><a href=#-ibis-add-operator-library><code>-ibis-add-operator-library</code></a></li><li><a href=#-ibis-argify-blocks><code>-ibis-argify-blocks</code></a></li><li><a href=#-ibis-call-prep><code>-ibis-call-prep</code></a></li><li><a href=#-ibis-clean-selfdrivers><code>-ibis-clean-selfdrivers</code></a></li><li><a href=#-ibis-containerize><code>-ibis-containerize</code></a></li><li><a href=#-ibis-convert-cf-to-handshake><code>-ibis-convert-cf-to-handshake</code></a></li><li><a href=#-ibis-convert-containers-to-hw><code>-ibis-convert-containers-to-hw</code></a></li><li><a href=#-ibis-convert-handshake-to-dc><code>-ibis-convert-handshake-to-dc</code></a></li><li><a href=#-ibis-convert-methods-to-containers><code>-ibis-convert-methods-to-containers</code></a></li><li><a href=#-ibis-inline-sblocks><code>-ibis-inline-sblocks</code></a></li><li><a href=#-ibis-lower-portrefs><code>-ibis-lower-portrefs</code></a></li><li><a href=#-ibis-prepare-scheduling><code>-ibis-prepare-scheduling</code></a></li><li><a href=#-ibis-reblock><code>-ibis-reblock</code></a></li><li><a href=#-ibis-tunneling><code>-ibis-tunneling</code></a></li></ul></li><li><a href=#llhd-dialect-passes>LLHD Dialect Passes</a><ul><li><a href=#-llhd-early-code-motion><code>-llhd-early-code-motion</code></a></li><li><a href=#-llhd-function-elimination><code>-llhd-function-elimination</code></a></li><li><a href=#-llhd-memory-to-block-argument><code>-llhd-memory-to-block-argument</code></a></li><li><a href=#-llhd-process-lowering><code>-llhd-process-lowering</code></a></li></ul></li><li><a href=#msft-dialect-passes>MSFT Dialect Passes</a><ul><li><a href=#-msft-export-tcl><code>-msft-export-tcl</code></a></li><li><a href=#-msft-lower-constructs><code>-msft-lower-constructs</code></a></li><li><a href=#-msft-lower-instances><code>-msft-lower-instances</code></a></li></ul></li><li><a href=#om-dialect-passes>OM Dialect Passes</a><ul><li><a href=#-om-freeze-paths><code>-om-freeze-paths</code></a></li><li><a href=#-om-link-modules><code>-om-link-modules</code></a></li></ul></li><li><a href=#pipeline-dialect-passes>Pipeline Dialect Passes</a><ul><li><a href=#-pipeline-explicit-regs><code>-pipeline-explicit-regs</code></a></li><li><a href=#-pipeline-schedule-linear><code>-pipeline-schedule-linear</code></a></li></ul></li><li><a href=#seq-dialect-passes>Seq Dialect Passes</a><ul><li><a href=#-externalize-clock-gate><code>-externalize-clock-gate</code></a></li><li><a href=#-hw-memory-sim><code>-hw-memory-sim</code></a></li><li><a href=#-lower-seq-fifo><code>-lower-seq-fifo</code></a></li><li><a href=#-lower-seq-hlmem><code>-lower-seq-hlmem</code></a></li><li><a href=#-lower-seq-shiftreg><code>-lower-seq-shiftreg</code></a></li></ul></li><li><a href=#ssp-dialect-passes>SSP Dialect Passes</a><ul><li><a href=#-ssp-print><code>-ssp-print</code></a></li><li><a href=#-ssp-roundtrip><code>-ssp-roundtrip</code></a></li><li><a href=#-ssp-schedule><code>-ssp-schedule</code></a></li></ul></li><li><a href=#sv-dialect-passes>SV Dialect Passes</a><ul><li><a href=#-hw-cleanup><code>-hw-cleanup</code></a></li><li><a href=#-hw-eliminate-inout-ports><code>-hw-eliminate-inout-ports</code></a></li><li><a href=#-hw-export-module-hierarchy><code>-hw-export-module-hierarchy</code></a></li><li><a href=#-hw-generator-callout><code>-hw-generator-callout</code></a></li><li><a href=#-hw-legalize-modules><code>-hw-legalize-modules</code></a></li><li><a href=#-hw-stub-external-modules><code>-hw-stub-external-modules</code></a></li><li><a href=#-prettify-verilog><code>-prettify-verilog</code></a></li><li><a href=#-sv-extract-test-code><code>-sv-extract-test-code</code></a></li><li><a href=#-sv-trace-iverilog><code>-sv-trace-iverilog</code></a></li></ul></li><li><a href=#systemc-dialect-passes>SystemC Dialect Passes</a><ul><li><a href=#-systemc-lower-instance-interop><code>-systemc-lower-instance-interop</code></a></li></ul></li></ul></nav><h2 id=conversion-passes>Conversion Passes&nbsp;<a class=headline-hash href=#conversion-passes>¶</a></h2><h3 id=-calyx-native><code>-calyx-native</code>&nbsp;<a class=headline-hash href=#-calyx-native>¶</a></h3><p><em>Callout to the Calyx native compiler and run a pass pipeline</em></p><p>This pass calls out to the native, Rust-based Calyx compiler to run passes
with it and generate a new, valid, calyx dialect program.</p><h4 id=options>Options&nbsp;<a class=headline-hash href=#options>¶</a></h4><pre tabindex=0><code>-pass-pipeline : Passes to run with the native compiler
</code></pre><h3 id=-calyx-remove-groups-fsm><code>-calyx-remove-groups-fsm</code>&nbsp;<a class=headline-hash href=#-calyx-remove-groups-fsm>¶</a></h3><p><em>Perform FSM outlining and group removal</em></p><p>This pass will outline the FSM into module scope and replace any SSA value references
from within the FSM body with additional inputs. Given this, the FSM
is instantiated as a <code>fsm.hw_module</code> operation within the Calyx component.
Using the FSM I/O (which is the group go/done signals), the <code>calyx.group</code>
operations are removed from the component, with the group go and done signals
being wired up to the FSM instance.
Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>calyx<span class=p>.</span>component <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%reg</span><span class=p>,</span> <span class=nl>... =</span> calyx<span class=p>.</span>register <span class=p>...</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>    calyx<span class=p>.</span>wires <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c>// Groups have explicit done signals, and assignments are not guarded
</span></span></span><span class=line><span class=cl><span class=c></span>        <span class=c>// by a group go signal.
</span></span></span><span class=line><span class=cl><span class=c></span>        calyx<span class=p>.</span>group <span class=nf>@A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>...</span>
</span></span><span class=line><span class=cl>            calyx<span class=p>.</span>assign <span class=nv>%reg</span> <span class=p>=</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>            <span class=p>...</span>
</span></span><span class=line><span class=cl>            calyx<span class=p>.</span>group_done <span class=nv>%foo</span> <span class=err>?</span> <span class=nv>%bar</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    calyx<span class=p>.</span>control <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c>// Machine is defined inside the `calyx.control` operation and references
</span></span></span><span class=line><span class=cl><span class=c></span>        <span class=c>// SSA values defined outside the machine.
</span></span></span><span class=line><span class=cl><span class=c></span>        fsm<span class=p>.</span>machine <span class=nf>@control</span><span class=p>(</span><span class=nv>%A_done</span> <span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=nv>%A_go</span> <span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>...</span>
</span></span><span class=line><span class=cl>            <span class=nv>%0</span> <span class=p>=</span> comb<span class=p>.</span>not <span class=nv>%reg</span> <span class=c>// reference some SSA value defined outside the machine
</span></span></span><span class=line><span class=cl><span class=c></span>            <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>into</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// The machine has been outlined into module scope, and no longer references
</span></span></span><span class=line><span class=cl><span class=c>// any SSA values defined outside the machine. It is now fully independent
</span></span></span><span class=line><span class=cl><span class=c>// from any notion of Calyx.
</span></span></span><span class=line><span class=cl><span class=c></span>fsm<span class=p>.</span>machine <span class=nf>@control</span><span class=p>(</span><span class=nv>%A_done</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=nv>%reg</span> <span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=nv>%A_go</span> <span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> comb<span class=p>.</span>not <span class=nv>%reg</span> <span class=c>// reference some SSA value defined outside the machine
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>calyx<span class=p>.</span>component <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%reg</span><span class=p>,</span> <span class=nl>... =</span> calyx<span class=p>.</span>register <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=c>// Done signals are now wires
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%A_done_in</span><span class=p>,</span> <span class=nv>%A_done_out</span> <span class=p>=</span> calyx<span class=p>.</span>wire <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>    <span class=c>// The FSM is now instantiated as an `fsm.hwinstance` module
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%A_go</span> <span class=p>=</span> fsm<span class=p>.</span>hwinstance <span class=nf>@control</span><span class=p>(</span><span class=nv>%A_done_out</span><span class=p>,</span> <span class=nv>%reg</span><span class=p>)</span> <span class=p>:</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    calyx<span class=p>.</span>wires <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c>// Groups have been inlined, the group go signal is now a guard for
</span></span></span><span class=line><span class=cl><span class=c></span>        <span class=c>// all assignments, and `calyx.group_done` operations have been
</span></span></span><span class=line><span class=cl><span class=c></span>        <span class=c>// replaced by wire assignments.
</span></span></span><span class=line><span class=cl><span class=c></span>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        calyx<span class=p>.</span>assign <span class=nv>%reg</span> <span class=p>=</span> <span class=nv>%A_go</span> <span class=err>?</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        calyx<span class=p>.</span>assign <span class=nv>%A_done_in</span> <span class=p>=</span> <span class=nv>%foo</span> <span class=err>?</span> <span class=nv>%bar</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    calyx<span class=p>.</span>control <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=-convert-affine-to-loopschedule><code>-convert-affine-to-loopschedule</code>&nbsp;<a class=headline-hash href=#-convert-affine-to-loopschedule>¶</a></h3><p><em>Convert Affine dialect to LoopSchedule scheduled loops</em></p><p>This pass analyzes Affine loops and control flow, creates a Scheduling
problem using the Calyx operator library, solves the problem, and lowers
the loops to a LoopSchedule.</p><h3 id=-convert-comb-to-arith><code>-convert-comb-to-arith</code>&nbsp;<a class=headline-hash href=#-convert-comb-to-arith>¶</a></h3><p><em>Convert combinational ops and constants into arith ops</em></p><h3 id=-convert-comb-to-smt><code>-convert-comb-to-smt</code>&nbsp;<a class=headline-hash href=#-convert-comb-to-smt>¶</a></h3><p><em>Convert combinational ops and constants to SMT ops</em></p><h3 id=-convert-fsm-to-sv><code>-convert-fsm-to-sv</code>&nbsp;<a class=headline-hash href=#-convert-fsm-to-sv>¶</a></h3><p><em>Convert FSM to SV and HW</em></p><h3 id=-convert-hw-to-btor2><code>-convert-hw-to-btor2</code>&nbsp;<a class=headline-hash href=#-convert-hw-to-btor2>¶</a></h3><p><em>Convert HW to BTOR2</em></p><p>This pass converts a HW module into a state transition system that is then
directly used to emit btor2. The output of this pass is thus a btor2 string.</p><h3 id=-convert-hw-to-llhd><code>-convert-hw-to-llhd</code>&nbsp;<a class=headline-hash href=#-convert-hw-to-llhd>¶</a></h3><p><em>Convert HW to LLHD</em></p><p>This pass translates a HW design into an equivalent structural LLHD
description.</p><h3 id=-convert-hw-to-llvm><code>-convert-hw-to-llvm</code>&nbsp;<a class=headline-hash href=#-convert-hw-to-llvm>¶</a></h3><p><em>Convert HW to LLVM</em></p><p>This pass translates HW to LLVM.</p><h3 id=-convert-hw-to-smt><code>-convert-hw-to-smt</code>&nbsp;<a class=headline-hash href=#-convert-hw-to-smt>¶</a></h3><p><em>Convert HW ops and constants to SMT ops</em></p><h3 id=-convert-hw-to-systemc><code>-convert-hw-to-systemc</code>&nbsp;<a class=headline-hash href=#-convert-hw-to-systemc>¶</a></h3><p><em>Convert HW to SystemC</em></p><p>This pass translates a HW design into an equivalent SystemC design.</p><h3 id=-convert-llhd-to-llvm><code>-convert-llhd-to-llvm</code>&nbsp;<a class=headline-hash href=#-convert-llhd-to-llvm>¶</a></h3><p><em>Convert LLHD to LLVM</em></p><p>This pass translates LLHD to LLVM.</p><h3 id=-convert-moore-to-core><code>-convert-moore-to-core</code>&nbsp;<a class=headline-hash href=#-convert-moore-to-core>¶</a></h3><p><em>Convert Moore to Core</em></p><p>This pass translates Moore to the core dialects (Comb/HW/LLHD).</p><h3 id=-convert-to-arcs><code>-convert-to-arcs</code>&nbsp;<a class=headline-hash href=#-convert-to-arcs>¶</a></h3><p><em>Outline logic between registers into state transfer arcs</em></p><p>This pass outlines combinational logic between registers into state transfer
arc definitions. The the original combinational logic and register is
replaced with an arc invocation, where the register is now represented as a
latency.</p><h4 id=options-1>Options&nbsp;<a class=headline-hash href=#options-1>¶</a></h4><pre tabindex=0><code>-tap-registers : Make registers observable
</code></pre><h3 id=-convert-verif-to-smt><code>-convert-verif-to-smt</code>&nbsp;<a class=headline-hash href=#-convert-verif-to-smt>¶</a></h3><p><em>Convert Verif ops to SMT ops</em></p><h3 id=-export-chisel-interface><code>-export-chisel-interface</code>&nbsp;<a class=headline-hash href=#-export-chisel-interface>¶</a></h3><p><em>Emit a Chisel interface to a FIRRTL circuit</em></p><p>This pass generates a Scala Chisel interface for the top level module of
a FIRRTL circuit.</p><h3 id=-export-split-chisel-interface><code>-export-split-chisel-interface</code>&nbsp;<a class=headline-hash href=#-export-split-chisel-interface>¶</a></h3><p><em>Emit a Chisel interface to a FIRRTL circuit to a directory of files</em></p><p>This pass generates a Scala Chisel interface for the top level module of
a FIRRTL circuit.</p><h4 id=options-2>Options&nbsp;<a class=headline-hash href=#options-2>¶</a></h4><pre tabindex=0><code>-dir-name : Directory to emit into
</code></pre><h3 id=-export-split-verilog><code>-export-split-verilog</code>&nbsp;<a class=headline-hash href=#-export-split-verilog>¶</a></h3><p><em>Emit the IR to a (System)Verilog directory of files</em></p><p>This pass generates (System)Verilog for the current design, mutating it
where necessary to be valid Verilog.</p><h4 id=options-3>Options&nbsp;<a class=headline-hash href=#options-3>¶</a></h4><pre tabindex=0><code>-dir-name : Directory to emit into
</code></pre><h3 id=-export-verilog><code>-export-verilog</code>&nbsp;<a class=headline-hash href=#-export-verilog>¶</a></h3><p><em>Emit the IR to a (System)Verilog file</em></p><p>This pass creates empty module bodies for external modules. This is
useful for linting to eliminate missing file errors.</p><h3 id=-handshake-remove-block-structure><code>-handshake-remove-block-structure</code>&nbsp;<a class=headline-hash href=#-handshake-remove-block-structure>¶</a></h3><p><em>Remove block structure in Handshake IR</em></p><h3 id=-hw-lower-instance-choices><code>-hw-lower-instance-choices</code>&nbsp;<a class=headline-hash href=#-hw-lower-instance-choices>¶</a></h3><p><em>Prepare the collateral for instance choice emission</em></p><p>This pass runs as part of verilog emission.
It introduces the macros & file lists to which instance choices lower to.</p><h3 id=-legalize-anon-enums><code>-legalize-anon-enums</code>&nbsp;<a class=headline-hash href=#-legalize-anon-enums>¶</a></h3><p><em>Prepare anonymous enumeration types for ExportVerilog</em></p><p>This pass transforms all anonymous enumeration types into typedecls to work
around difference in how anonymous enumerations work in SystemVerilog.</p><h3 id=-lower-arc-to-llvm><code>-lower-arc-to-llvm</code>&nbsp;<a class=headline-hash href=#-lower-arc-to-llvm>¶</a></h3><p><em>Lower state transfer arc representation to LLVM</em></p><h3 id=-lower-calyx-to-fsm><code>-lower-calyx-to-fsm</code>&nbsp;<a class=headline-hash href=#-lower-calyx-to-fsm>¶</a></h3><p><em>Lower Calyx to FSM</em></p><p>This pass lowers a Calyx control schedule to an FSM representation.
An <code>fsm.machine</code> operation is nested within the <code>control</code> region of the Calyx
component. This machine is itself in an intermediate format wherein it has
no I/O ports and solely contains output statements with <code>calyx.enable</code>s
referencing <code>calyx.group</code> and transition logic guarded by the SSA values
specified in the source control schedule.
This intermediate state facilitates transformation of the FSM, given that
top-level I/O has yet to be materialized (one input and output per activated
group) as well as guard transition logic (every transition must be guarded
on all groups active within the state having finished). As such, <code>calyx.enable</code>
operations can easily be moved between states without worrying about updating
transition guards while doing so.</p><p>Eventually, the FSM must be materialized (materialize I/O ports, remove
<code>calyx.enable</code> operations in favor of asserting output ports, guarding
transitions by input <code>done</code> ports) and outlined to a separate module.</p><h3 id=-lower-calyx-to-hw><code>-lower-calyx-to-hw</code>&nbsp;<a class=headline-hash href=#-lower-calyx-to-hw>¶</a></h3><p><em>Lower Calyx to HW</em></p><p>This pass lowers Calyx to HW.</p><h3 id=-lower-cf-to-handshake><code>-lower-cf-to-handshake</code>&nbsp;<a class=headline-hash href=#-lower-cf-to-handshake>¶</a></h3><p><em>Lower func and CF into Handshake IR</em></p><h4 id=options-4>Options&nbsp;<a class=headline-hash href=#options-4>¶</a></h4><pre tabindex=0><code>-source-constants        : If true, will connect constants to source operations instead of to the control network. May reduce the size of the final circuit.
-disable-task-pipelining : If true, will disable support for task pipelining. This relaxes the restrictions put on the structure of the input CDFG. Disabling task pipelining may severely reduce kernel II.
</code></pre><h3 id=-lower-dc-to-hw><code>-lower-dc-to-hw</code>&nbsp;<a class=headline-hash href=#-lower-dc-to-hw>¶</a></h3><p><em>Lower DC to HW</em></p><p>Lower DC to ESI/hw/comb/seq operations.
In case the IR contains DC operations that need to be clocked (fork, buffer),
there must exist a clock and reset signal in the parent <code>FunctionLike</code>
operation. These arguments are to be marked with a <code>dc.clock</code> and <code>dc.reset</code>
attribute, respectively.</p><h3 id=-lower-firrtl-to-hw><code>-lower-firrtl-to-hw</code>&nbsp;<a class=headline-hash href=#-lower-firrtl-to-hw>¶</a></h3><p><em>Lower FIRRTL to HW</em></p><p>Lower a module of FIRRTL dialect to the HW dialect family.</p><h4 id=options-5>Options&nbsp;<a class=headline-hash href=#options-5>¶</a></h4><pre tabindex=0><code>-warn-on-unprocessed-annotations : Emit warnings on unprocessed annotations during lower-to-hw pass
-emit-chisel-asserts-as-sva      : Convert all Chisel asserts to SVA
</code></pre><h3 id=-lower-handshake-to-dc><code>-lower-handshake-to-dc</code>&nbsp;<a class=headline-hash href=#-lower-handshake-to-dc>¶</a></h3><p><em>Lower Handshake to DC</em></p><p>Lower Handshake to DC operations.
Currently, a <code>handshake.func</code> will be converted into a <code>hw.module</code>. This
is principally an incorrect jump of abstraction - DC does not imply any
RTL/hardware semantics. However, DC does not define a container operation,
and there does not exist an e.g. <code>func.graph_func</code> which would be a generic
function with graph region behaviour. Thus, for now, we just use <code>hw.module</code>
as a container operation.</p><h3 id=-lower-handshake-to-hw><code>-lower-handshake-to-hw</code>&nbsp;<a class=headline-hash href=#-lower-handshake-to-hw>¶</a></h3><p><em>Lower Handshake to ESI/HW/Comb/Seq</em></p><p>Lower Handshake to ESI/HW/Comb/Seq.</p><h3 id=-lower-hw-to-sv><code>-lower-hw-to-sv</code>&nbsp;<a class=headline-hash href=#-lower-hw-to-sv>¶</a></h3><p><em>Convert HW to SV</em></p><p>This pass converts various HW contructs to SV.</p><h3 id=-lower-hwarith-to-hw><code>-lower-hwarith-to-hw</code>&nbsp;<a class=headline-hash href=#-lower-hwarith-to-hw>¶</a></h3><p><em>Lower HWArith to HW/Comb</em></p><p>This pass lowers HWArith to HW/Comb.</p><h3 id=-lower-loopschedule-to-calyx><code>-lower-loopschedule-to-calyx</code>&nbsp;<a class=headline-hash href=#-lower-loopschedule-to-calyx>¶</a></h3><p><em>Lower LoopSchedule to Calyx</em></p><p>This pass lowers LoopSchedule to Calyx.</p><h4 id=options-6>Options&nbsp;<a class=headline-hash href=#options-6>¶</a></h4><pre tabindex=0><code>-top-level-function             : Identifier of top-level function to be the entry-point component of the Calyx program.
-cider-source-location-metadata : Whether to track source location for the Cider debugger.
</code></pre><h3 id=-lower-pipeline-to-hw><code>-lower-pipeline-to-hw</code>&nbsp;<a class=headline-hash href=#-lower-pipeline-to-hw>¶</a></h3><p><em>Lower Pipeline to HW</em></p><p>This pass lowers <code>pipeline.rtp</code> operations to HW.</p><h4 id=options-7>Options&nbsp;<a class=headline-hash href=#options-7>¶</a></h4><pre tabindex=0><code>-clock-gate-regs       : Clock gate each register instead of (default) input muxing  (ASIC optimization).
-enable-poweron-values : Add power-on values to the pipeline control registers
</code></pre><h3 id=-lower-scf-to-calyx><code>-lower-scf-to-calyx</code>&nbsp;<a class=headline-hash href=#-lower-scf-to-calyx>¶</a></h3><p><em>Lower SCF/Standard to Calyx</em></p><p>This pass lowers SCF / standard to Calyx.</p><h4 id=options-8>Options&nbsp;<a class=headline-hash href=#options-8>¶</a></h4><pre tabindex=0><code>-top-level-function             : Identifier of top-level function to be the entry-point component of the Calyx program.
-cider-source-location-metadata : Whether to track source location for the Cider debugger.
</code></pre><h3 id=-lower-seq-firmem><code>-lower-seq-firmem</code>&nbsp;<a class=headline-hash href=#-lower-seq-firmem>¶</a></h3><p><em>Lower seq.firmem ops to instances of hw.module.generated ops</em></p><h3 id=-lower-seq-to-sv><code>-lower-seq-to-sv</code>&nbsp;<a class=headline-hash href=#-lower-seq-to-sv>¶</a></h3><p><em>Lower sequential firrtl ops to SV.</em></p><h4 id=options-9>Options&nbsp;<a class=headline-hash href=#options-9>¶</a></h4><pre tabindex=0><code>-disable-reg-randomization   : Disable emission of register randomization code
-disable-mem-randomization   : Disable emission of memory randomization code
-emit-separate-always-blocks : Emit assigments to registers in separate always blocks
-lower-to-always-ff          : Place assignments to registers into `always_ff` blocks
</code></pre><h4 id=statistics>Statistics&nbsp;<a class=headline-hash href=#statistics>¶</a></h4><pre tabindex=0><code>num-subaccess-restored : Number of lhs subaccess operations restored 
</code></pre><h3 id=-lower-sim-to-sv><code>-lower-sim-to-sv</code>&nbsp;<a class=headline-hash href=#-lower-sim-to-sv>¶</a></h3><p><em>Lower simulator-specific <code>sim</code> ops to SV.</em></p><h3 id=-lower-verif-to-sv><code>-lower-verif-to-sv</code>&nbsp;<a class=headline-hash href=#-lower-verif-to-sv>¶</a></h3><p><em>Convert Verif to SV</em></p><p>This pass converts various Verif contructs to SV.</p><h3 id=-materialize-calyx-to-fsm><code>-materialize-calyx-to-fsm</code>&nbsp;<a class=headline-hash href=#-materialize-calyx-to-fsm>¶</a></h3><p><em>Materializes an FSM embedded inside the control of this Calyx component.</em></p><p>Materializes the FSM in the control of the component. This materializes the
top-level I/O of the FSM to receive <code>group_done</code> signals as input and
<code>group_go</code> signals as output, based on the <code>calyx.enable</code> operations
used within the states of the FSM.
Each transition of the FSM is predicated on the enabled groups within a
state being done, or, for static groups, a separate sub-FSM is instantiated
to await the group finishing.</p><p>Given an FSM that enables N unique groups, the top-level FSM will have N+1
in- and output ports, wherein:</p><ul><li>Input # 0 to N-1 are <code>group_done</code> signals</li><li>Input N is the top-level <code>go</code> port</li><li>Output 0 to N-1 are <code>group_go</code> signals</li><li>Output N is the top-level <code>done</code> port</li></ul><h3 id=-prepare-for-emission><code>-prepare-for-emission</code>&nbsp;<a class=headline-hash href=#-prepare-for-emission>¶</a></h3><p><em>Prepare IR for ExportVerilog</em></p><p>This pass runs only PrepareForEmission.
It is not necessary for users to run this pass explicitly since
ExportVerilog internally runs PrepareForEmission.</p><h3 id=-test-apply-lowering-options><code>-test-apply-lowering-options</code>&nbsp;<a class=headline-hash href=#-test-apply-lowering-options>¶</a></h3><p><em>Apply lowering options</em></p><p>This pass allows overriding lowering options. It is intended for test
construction.</p><h4 id=options-10>Options&nbsp;<a class=headline-hash href=#options-10>¶</a></h4><pre tabindex=0><code>-options : Lowering Options
</code></pre><h2 id=arc-dialect-passes>Arc Dialect Passes&nbsp;<a class=headline-hash href=#arc-dialect-passes>¶</a></h2><h3 id=-arc-add-taps><code>-arc-add-taps</code>&nbsp;<a class=headline-hash href=#-arc-add-taps>¶</a></h3><p><em>Add taps to ports and wires such that they remain observable</em></p><h4 id=options-11>Options&nbsp;<a class=headline-hash href=#options-11>¶</a></h4><pre tabindex=0><code>-ports        : Make module ports observable
-wires        : Make wires observable
-named-values : Make values with `sv.namehint` observable
</code></pre><h3 id=-arc-allocate-state><code>-arc-allocate-state</code>&nbsp;<a class=headline-hash href=#-arc-allocate-state>¶</a></h3><p><em>Allocate and layout the global simulation state</em></p><h3 id=-arc-canonicalizer><code>-arc-canonicalizer</code>&nbsp;<a class=headline-hash href=#-arc-canonicalizer>¶</a></h3><p><em>Simulation centric canonicalizations</em></p><h4 id=statistics-1>Statistics&nbsp;<a class=headline-hash href=#statistics-1>¶</a></h4><pre tabindex=0><code>num-arc-args-removed : Number of arguments removed from DefineOps
</code></pre><h3 id=-arc-dedup><code>-arc-dedup</code>&nbsp;<a class=headline-hash href=#-arc-dedup>¶</a></h3><p><em>Deduplicate identical arc definitions</em></p><p>This pass deduplicates identical arc definitions. If two arcs differ only by
constants, the constants are outlined such that the arc can be deduplicated.</p><h4 id=statistics-2>Statistics&nbsp;<a class=headline-hash href=#statistics-2>¶</a></h4><pre tabindex=0><code>dedupPassNumArcsDeduped : Number of arcs deduped
dedupPassTotalOps       : Total number of ops deduped
</code></pre><h3 id=-arc-group-resets-and-enables><code>-arc-group-resets-and-enables</code>&nbsp;<a class=headline-hash href=#-arc-group-resets-and-enables>¶</a></h3><p><em>Group reset and enable conditions of lowered states</em></p><h3 id=-arc-infer-memories><code>-arc-infer-memories</code>&nbsp;<a class=headline-hash href=#-arc-infer-memories>¶</a></h3><p><em>Convert <code>FIRRTL_Memory</code> instances to dedicated memory ops</em></p><h4 id=options-12>Options&nbsp;<a class=headline-hash href=#options-12>¶</a></h4><pre tabindex=0><code>-tap-ports    : Make memory ports observable
-tap-memories : Make memory contents observable
</code></pre><h3 id=-arc-infer-state-properties><code>-arc-infer-state-properties</code>&nbsp;<a class=headline-hash href=#-arc-infer-state-properties>¶</a></h3><p><em>Add resets and enables explicitly to the state operations</em></p><h4 id=options-13>Options&nbsp;<a class=headline-hash href=#options-13>¶</a></h4><pre tabindex=0><code>-enables : Infer enable signals
-resets  : Infer reset signals
</code></pre><h4 id=statistics-3>Statistics&nbsp;<a class=headline-hash href=#statistics-3>¶</a></h4><pre tabindex=0><code>added-enables  : Enables added explicitly to a StateOp
added-resets   : Resets added explicitly to a StateOp
missed-enables : Detected enables that could not be added explicitly to a StateOp
missed-resets  : Detected resets that could not be added explicitly to a StateOp
</code></pre><h3 id=-arc-inline><code>-arc-inline</code>&nbsp;<a class=headline-hash href=#-arc-inline>¶</a></h3><p><em>Inline very small arcs</em></p><h4 id=options-14>Options&nbsp;<a class=headline-hash href=#options-14>¶</a></h4><pre tabindex=0><code>-into-arcs-only : Call operations to inline
-max-body-ops   : Max number of non-trivial ops in the region to be inlined
</code></pre><h4 id=statistics-4>Statistics&nbsp;<a class=headline-hash href=#statistics-4>¶</a></h4><pre tabindex=0><code>inlined-arcs    : Arcs inlined at a use site
removed-arcs    : Arcs removed after full inlining
trivial-arcs    : Arcs with very few ops
single-use-arcs : Arcs with a single use
</code></pre><h3 id=-arc-inline-modules><code>-arc-inline-modules</code>&nbsp;<a class=headline-hash href=#-arc-inline-modules>¶</a></h3><p><em>Eagerly inline private modules</em></p><p>This pass eagerly inlines private HW modules into their instantiation sites.
After outlining combinational logic and registers into arcs, module bodies
become fairly lightweight. Since arc definitions now fulfill the purpose of
code reuse by allowing a single definition to be called multiple times, the
module hierarchy degenerates into a purely cosmetic construct. At that point
it is beneficial to fully flatten the module hierarchy to simplify further
analysis and optimization of state transfer arcs.</p><h3 id=-arc-isolate-clocks><code>-arc-isolate-clocks</code>&nbsp;<a class=headline-hash href=#-arc-isolate-clocks>¶</a></h3><p><em>Group clocked operations into clock domains</em></p><h3 id=-arc-latency-retiming><code>-arc-latency-retiming</code>&nbsp;<a class=headline-hash href=#-arc-latency-retiming>¶</a></h3><p><em>Push latencies through the design</em></p><h4 id=statistics-5>Statistics&nbsp;<a class=headline-hash href=#statistics-5>¶</a></h4><pre tabindex=0><code>num-ops-removed     : Number of zero-latency passthrough states removed
latency-units-saved : Number of latency units saved by merging them in a successor state
</code></pre><h3 id=-arc-legalize-state-update><code>-arc-legalize-state-update</code>&nbsp;<a class=headline-hash href=#-arc-legalize-state-update>¶</a></h3><p><em>Insert temporaries such that state reads don&rsquo;t see writes</em></p><h3 id=-arc-lower-arcs-to-funcs><code>-arc-lower-arcs-to-funcs</code>&nbsp;<a class=headline-hash href=#-arc-lower-arcs-to-funcs>¶</a></h3><p><em>Lower arc definitions into functions</em></p><h3 id=-arc-lower-clocks-to-funcs><code>-arc-lower-clocks-to-funcs</code>&nbsp;<a class=headline-hash href=#-arc-lower-clocks-to-funcs>¶</a></h3><p><em>Lower clock trees into functions</em></p><h3 id=-arc-lower-lut><code>-arc-lower-lut</code>&nbsp;<a class=headline-hash href=#-arc-lower-lut>¶</a></h3><p><em>Lowers arc.lut into a comb and hw only representation.</em></p><h3 id=-arc-lower-state><code>-arc-lower-state</code>&nbsp;<a class=headline-hash href=#-arc-lower-state>¶</a></h3><p><em>Split state into read and write ops grouped by clock tree</em></p><h3 id=-arc-lower-vectorizations><code>-arc-lower-vectorizations</code>&nbsp;<a class=headline-hash href=#-arc-lower-vectorizations>¶</a></h3><p><em>Lower <code>arc.vectorize</code> operations</em></p><p>This pass lowers <code>arc.vectorize</code> operations. By default, the operation will
be fully lowered (i.e., the op disappears in the IR). Alternatively, it can
be partially lowered.</p><p>The &ldquo;mode&rdquo; pass option allows to only lower the boundary, only the body, or
only inline the body given that both the boundary and the body are already
lowered.</p><p>The pass supports vectorization within scalar registers and SIMD
vectorization and prioritizes vectorization by packing the vector elements
into a scalar value if it can fit into 64 bits.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>hw<span class=p>.</span>module <span class=nf>@example</span><span class=p>(</span><span class=nv>%in0</span><span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=nv>%in1</span><span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=nv>%in2</span><span class=p>:</span> <span class=k>i8</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>out0<span class=p>:</span> <span class=k>i8</span><span class=p>,</span> out1<span class=p>:</span> <span class=k>i8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span><span class=p>:</span><span class=nl>2 =</span> arc<span class=p>.</span><span class=kt>vector</span>ize <span class=p>(</span><span class=nv>%in0</span><span class=p>,</span> <span class=nv>%in1</span><span class=p>),</span> <span class=p>(</span><span class=nv>%in2</span><span class=p>,</span> <span class=nv>%in2</span><span class=p>)</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i8</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nl>^bb0</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>:</span> <span class=k>i8</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> comb<span class=p>.</span>and <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl>    arc<span class=p>.</span><span class=kt>vector</span>ize<span class=p>.</span><span class=kt>return</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  hw<span class=p>.</span>output <span class=nv>%0#0</span><span class=p>,</span> <span class=nv>%0#1</span> <span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This piece of IR is lowered to the following fully vectorized IR:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>hw<span class=p>.</span>module <span class=nf>@example</span><span class=p>(</span><span class=nv>%in0</span><span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=nv>%in1</span><span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=nv>%in2</span><span class=p>:</span> <span class=k>i8</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>out0<span class=p>:</span> <span class=k>i8</span><span class=p>,</span> out1<span class=p>:</span> <span class=k>i8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> comb<span class=p>.</span>concat <span class=nv>%in0</span><span class=p>,</span> <span class=nv>%in1</span> <span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> comb<span class=p>.</span>concat <span class=nv>%in2</span><span class=p>,</span> <span class=nv>%in2</span> <span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl>  <span class=nv>%2</span> <span class=p>=</span> comb<span class=p>.</span>and <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i16</span>
</span></span><span class=line><span class=cl>  <span class=nv>%3</span> <span class=p>=</span> comb<span class=p>.</span>extract <span class=nv>%2</span> from <span class=m>0</span> <span class=p>:</span> <span class=p>(</span><span class=k>i16</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl>  <span class=nv>%4</span> <span class=p>=</span> comb<span class=p>.</span>extract <span class=nv>%2</span> from <span class=m>8</span> <span class=p>:</span> <span class=p>(</span><span class=k>i16</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl>  hw<span class=p>.</span>output <span class=nv>%3</span><span class=p>,</span> <span class=nv>%4</span> <span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=options-15>Options&nbsp;<a class=headline-hash href=#options-15>¶</a></h4><pre tabindex=0><code>-mode : Select what should be lowered.
</code></pre><h3 id=-arc-make-tables><code>-arc-make-tables</code>&nbsp;<a class=headline-hash href=#-arc-make-tables>¶</a></h3><p><em>Transform appropriate arc logic into lookup tables</em></p><h3 id=-arc-mux-to-control-flow><code>-arc-mux-to-control-flow</code>&nbsp;<a class=headline-hash href=#-arc-mux-to-control-flow>¶</a></h3><p><em>Convert muxes with large independent fan-ins to if-statements</em></p><h3 id=-arc-simplify-variadic-ops><code>-arc-simplify-variadic-ops</code>&nbsp;<a class=headline-hash href=#-arc-simplify-variadic-ops>¶</a></h3><p><em>Convert variadic ops into distributed binary ops</em></p><h4 id=statistics-6>Statistics&nbsp;<a class=headline-hash href=#statistics-6>¶</a></h4><pre tabindex=0><code>skipped-multiple-blocks : Ops skipped due to operands in different blocks
simplified              : Ops simplified into binary ops
created                 : Ops created as part of simplification
reordered               : Ops where simplification reordered operands
</code></pre><h3 id=-arc-split-loops><code>-arc-split-loops</code>&nbsp;<a class=headline-hash href=#-arc-split-loops>¶</a></h3><p><em>Split arcs to break zero latency loops</em></p><h3 id=-arc-strip-sv><code>-arc-strip-sv</code>&nbsp;<a class=headline-hash href=#-arc-strip-sv>¶</a></h3><p><em>Remove SV wire, reg, and assigns</em></p><h2 id=calyx-dialect-passes>Calyx Dialect Passes&nbsp;<a class=headline-hash href=#calyx-dialect-passes>¶</a></h2><h3 id=-calyx-clk-insertion><code>-calyx-clk-insertion</code>&nbsp;<a class=headline-hash href=#-calyx-clk-insertion>¶</a></h3><p><em>Inserts assignments from component clock to sub-component clock.</em></p><h3 id=-calyx-compile-control><code>-calyx-compile-control</code>&nbsp;<a class=headline-hash href=#-calyx-compile-control>¶</a></h3><p><em>Generates latency-insensitive finite state machines to realize control.</em></p><p>This pass performs a bottom-up traversal of the control program and does the following:</p><ol><li>For each control statement such as &ldquo;calyx.seq&rdquo;, create a new GroupOp to contain all
the structure to realize the schedule.</li><li>Implement the schedule by setting the constituent groups&rsquo; GoOp and DoneOp.</li><li>Replace the control statement in the control program with the corresponding
compilation group.</li></ol><h3 id=-calyx-gicm><code>-calyx-gicm</code>&nbsp;<a class=headline-hash href=#-calyx-gicm>¶</a></h3><p><em>Lift group-invariant operations to wire-scope.</em></p><p>This pass performs GICM (group-invariant code motion) of operations which are
deemed to be invariant of the group in which they are placed. In practice,
this amounts to anything which is not a <code>calyx.group_done/assign/group_go</code>
operation. GICM&rsquo;d operations are lifted to wire-scope.</p><p>After GICM, a Calyx component has the following properties:</p><ul><li>No values are being defined within groups (excluding <code>calyx.group_go</code>).
As such, groups will only contain group-level assignments
(calyx.assign/group_done).</li><li>Any value referenced by operations within the group may safely be
referenced by other groups, or operations in wire scope.</li><li>A group does not define anything structural; it exclusively describes
wiring between existing structures.</li></ul><h3 id=-calyx-go-insertion><code>-calyx-go-insertion</code>&nbsp;<a class=headline-hash href=#-calyx-go-insertion>¶</a></h3><p><em>Insert go signals into the guards of a group&rsquo;s non-hole assignments</em></p><p>This pass inserts the operation &ldquo;calyx.group_go&rdquo; into the guards of all
assignments housed in the group, with the exception of the &ldquo;calyx.group_done&rdquo;
terminator. For example,</p><p>Before:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>calyx<span class=p>.</span>group <span class=nf>@Group1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  calyx<span class=p>.</span>assign <span class=nv>%in</span> <span class=p>=</span> <span class=nv>%out1</span><span class=p>,</span> <span class=nv>%guard</span> <span class=err>?</span> <span class=p>:</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl>  <span class=nv>%done</span> <span class=p>=</span> calyx<span class=p>.</span>group_done <span class=nv>%out2</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>After:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// The `go` assignment takes on an undefined
</span></span></span><span class=line><span class=cl><span class=c>// value until the Compile Control pass.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%undef</span> <span class=p>=</span> calyx<span class=p>.</span>undef <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>calyx<span class=p>.</span>group <span class=nf>@Group1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%go</span> <span class=p>=</span> calyx<span class=p>.</span>group_go <span class=nv>%undef</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nv>%and</span> <span class=p>=</span> comb<span class=p>.</span>and <span class=nv>%guard</span><span class=p>,</span> <span class=nv>%go</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>  calyx<span class=p>.</span>assign <span class=nv>%in</span> <span class=p>=</span> <span class=nv>%out1</span><span class=p>,</span> <span class=nv>%and</span> <span class=err>?</span> <span class=p>:</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nv>%done</span> <span class=p>=</span> calyx<span class=p>.</span>group_done <span class=nv>%out2</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=-calyx-remove-comb-groups><code>-calyx-remove-comb-groups</code>&nbsp;<a class=headline-hash href=#-calyx-remove-comb-groups>¶</a></h3><p><em>Removes combinational groups from a Calyx component.</em></p><p>Transforms combinational groups, which have a constant done condition,
into proper groups by registering the values read from the ports of cells
used within the combinational group.</p><p>It also transforms (invoke,if,while)-with into semantically equivalent
control programs that first enable a group that calculates and registers the
ports defined by the combinational group execute the respective cond group
and then execute the control operator.</p><h2 id=example>Example&nbsp;<a class=headline-hash href=#example>¶</a></h2><pre tabindex=0><code>group comb_cond&lt;&#34;static&#34;=0&gt; {
    lt.right = 32&#39;d10;
    lt.left = 32&#39;d1;
    eq.right = r.out;
    eq.left = x.out;
    comb_cond[done] = 1&#39;d1;
}
control {
    invoke comp(left = lt.out, ..)(..) with comb_cond;
    if lt.out with comb_cond {
        ...
    }
    while eq.out with comb_cond {
        ...
    }
}
</code></pre><p>into:</p><pre tabindex=0><code>group comb_cond&lt;&#34;static&#34;=1&gt; {
    lt.right = 32&#39;d10;
    lt.left = 32&#39;d1;
    eq.right = r.out;
    eq.left = x.out;
    lt_reg.in = lt.out
    lt_reg.write_en = 1&#39;d1;
    eq_reg.in = eq.out;
    eq_reg.write_en = 1&#39;d1;
    comb_cond[done] = lt_reg.done &amp; eq_reg.done ? 1&#39;d1;
}
control {
    seq {
      comb_cond;
      invoke comp(left = lt_reg.out, ..)(..);
    }
    seq {
      comb_cond;
      if lt_reg.out {
          ...
      }
    }
    seq {
      comb_cond;
      while eq_reg.out {
          ...
          comb_cond;
      }
    }
}
</code></pre><h3 id=-calyx-remove-groups><code>-calyx-remove-groups</code>&nbsp;<a class=headline-hash href=#-calyx-remove-groups>¶</a></h3><p><em>Inlines the groups in a Calyx component.</em></p><p>This pass removes the Group interface from the Calyx program, and inlines all
assignments. This is done in the following manner:</p><ol><li>Assign values to the &lsquo;done&rsquo; signal of the component, corresponding with the
top-level control group&rsquo;s DoneOp. Add the &lsquo;go&rsquo; signal of the component to
all assignments.</li><li>TODO(Calyx): If there are multiple writes to a signal, replace the reads
with the disjunction.</li><li>Remove all groups.</li></ol><h3 id=-calyx-reset-insertion><code>-calyx-reset-insertion</code>&nbsp;<a class=headline-hash href=#-calyx-reset-insertion>¶</a></h3><p><em>Connect component reset to sub-component reset for applicable components.</em></p><h2 id=comb-dialect-passes>Comb Dialect Passes&nbsp;<a class=headline-hash href=#comb-dialect-passes>¶</a></h2><h3 id=-lower-comb><code>-lower-comb</code>&nbsp;<a class=headline-hash href=#-lower-comb>¶</a></h3><p><em>Lowers the some of the comb ops</em></p><p>Some operations in the comb dialect (e.g. <code>comb.truth_table</code>) are not
directly supported by ExportVerilog. They need to be lowered into ops which
are supported. There are many ways to lower these ops so we do this in a
separate pass. This also allows the lowered form to participate in
optimizations like the comb canonicalizers.</p><h2 id=dc-dialect-passes>DC Dialect Passes&nbsp;<a class=headline-hash href=#dc-dialect-passes>¶</a></h2><h3 id=-dc-dematerialize-forks-sinks><code>-dc-dematerialize-forks-sinks</code>&nbsp;<a class=headline-hash href=#-dc-dematerialize-forks-sinks>¶</a></h3><p><em>Dematerialize fork and sink operations.</em></p><p>This pass analyses a function-like operation and removes all fork and sink
operations.</p><h3 id=-dc-materialize-forks-sinks><code>-dc-materialize-forks-sinks</code>&nbsp;<a class=headline-hash href=#-dc-materialize-forks-sinks>¶</a></h3><p><em>Materialize fork and sink operations.</em></p><p>This pass analyses a function-like operation and inserts fork and sink
operations ensuring that all values have exactly one use.</p><h2 id=esi-dialect-passes>ESI Dialect Passes&nbsp;<a class=headline-hash href=#esi-dialect-passes>¶</a></h2><h3 id=-esi-appid-hier><code>-esi-appid-hier</code>&nbsp;<a class=headline-hash href=#-esi-appid-hier>¶</a></h3><p><em>Build an AppID based hierarchy rooted at top module &rsquo;top&rsquo;</em></p><h4 id=options-16>Options&nbsp;<a class=headline-hash href=#options-16>¶</a></h4><pre tabindex=0><code>-top : Root module of the instance hierarchy
</code></pre><h3 id=-esi-build-manifest><code>-esi-build-manifest</code>&nbsp;<a class=headline-hash href=#-esi-build-manifest>¶</a></h3><p><em>Build a manifest of an ESI system</em></p><h4 id=options-17>Options&nbsp;<a class=headline-hash href=#options-17>¶</a></h4><pre tabindex=0><code>-top : Root module of the instance hierarchy
</code></pre><h3 id=-esi-clean-metadata><code>-esi-clean-metadata</code>&nbsp;<a class=headline-hash href=#-esi-clean-metadata>¶</a></h3><p><em>Clean up ESI service metadata</em></p><h3 id=-esi-connect-services><code>-esi-connect-services</code>&nbsp;<a class=headline-hash href=#-esi-connect-services>¶</a></h3><p><em>Connect up ESI service requests to service providers</em></p><h3 id=-lower-esi-bundles><code>-lower-esi-bundles</code>&nbsp;<a class=headline-hash href=#-lower-esi-bundles>¶</a></h3><p><em>Lower ESI bundles to channels.</em></p><h3 id=-lower-esi-ports><code>-lower-esi-ports</code>&nbsp;<a class=headline-hash href=#-lower-esi-ports>¶</a></h3><p><em>Lower ESI input and/or output ports.</em></p><h3 id=-lower-esi-to-hw><code>-lower-esi-to-hw</code>&nbsp;<a class=headline-hash href=#-lower-esi-to-hw>¶</a></h3><p><em>Lower ESI to HW where possible and SV elsewhere.</em></p><h4 id=options-18>Options&nbsp;<a class=headline-hash href=#options-18>¶</a></h4><pre tabindex=0><code>-platform : Target this platform
</code></pre><h3 id=-lower-esi-to-physical><code>-lower-esi-to-physical</code>&nbsp;<a class=headline-hash href=#-lower-esi-to-physical>¶</a></h3><p><em>Lower ESI abstract Ops to ESI physical ops.</em></p><h3 id=-lower-esi-types><code>-lower-esi-types</code>&nbsp;<a class=headline-hash href=#-lower-esi-types>¶</a></h3><p><em>Lower ESI high level types.</em></p><h2 id=firrtl-dialect-passes>FIRRTL Dialect Passes&nbsp;<a class=headline-hash href=#firrtl-dialect-passes>¶</a></h2><h3 id=-firrtl-add-seqmem-ports><code>-firrtl-add-seqmem-ports</code>&nbsp;<a class=headline-hash href=#-firrtl-add-seqmem-ports>¶</a></h3><p><em>Add extra ports to memory modules</em></p><p>This pass looks for <code>AddSeqMemPortAnnotation</code> annotations and adds extra
ports to memories. It will emit metadata based if the
<code>AddSeqMemPortsFileAnnotation</code> annotation is specified.</p><p>This pass requires that FIRRTL MemOps have been lowered to modules to add
the extra ports.</p><h4 id=statistics-7>Statistics&nbsp;<a class=headline-hash href=#statistics-7>¶</a></h4><pre tabindex=0><code>num-added-ports : Number of extra ports added
</code></pre><h3 id=-firrtl-blackbox-reader><code>-firrtl-blackbox-reader</code>&nbsp;<a class=headline-hash href=#-firrtl-blackbox-reader>¶</a></h3><p><em>Load source files for black boxes into the IR</em></p><p>This pass reads the Verilog source files for black boxes and adds them as
<code>sv.verbatim.file</code> operations into the IR. Later passes can then write
these files back to disk to ensure that they can be accessed by other tools
down the line in a well-known location. Supports inline and path
annotations for black box source files.</p><p>The supported <code>firrtl.circuit</code> annotations are:</p><ul><li><code>{class = "firrtl.transforms.BlackBoxTargetDirAnno", targetDir = "..."}</code>
Overrides the target directory into which black box source files are
emitted.</li><li><code>{class = "firrtl.transforms.BlackBoxResourceFileNameAnno", resourceFileName = "xyz.f"}</code>
Specifies the output file name for the list of black box source files that
is generated as a collateral of the pass.</li></ul><p>The supported <code>firrtl.extmodule</code> annotations are:</p><ul><li><pre tabindex=0><code>{
  class = &#34;firrtl.transforms.BlackBoxInlineAnno&#34;,
  name = &#34;myfile.v&#34;,
  text = &#34;...&#34;
}
</code></pre>Specifies the black box source code (<code>text</code>) inline. Generates a file with
the given <code>name</code> in the target directory.</li><li><pre tabindex=0><code>{
  class = &#34;firrtl.transforms.BlackBoxPathAnno&#34;,
  path = &#34;myfile.v&#34;
}
</code></pre>Specifies the file <code>path</code> as source code for the module. Copies the file
to the target directory.</li></ul><h4 id=options-19>Options&nbsp;<a class=headline-hash href=#options-19>¶</a></h4><pre tabindex=0><code>-input-prefix : Prefix for input paths in black box annotations. This should be the directory where the input file was located, to allow for annotations relative to the input file.
</code></pre><h3 id=-firrtl-check-comb-loops><code>-firrtl-check-comb-loops</code>&nbsp;<a class=headline-hash href=#-firrtl-check-comb-loops>¶</a></h3><p><em>Check combinational cycles and emit errors</em></p><p>This pass checks combinational cycles in the IR and emit errors.</p><h3 id=-firrtl-dedup><code>-firrtl-dedup</code>&nbsp;<a class=headline-hash href=#-firrtl-dedup>¶</a></h3><p><em>Deduplicate modules which are structurally equivalent</em></p><p>This pass detects modules which are structurally equivalent and removes the
duplicate module by replacing all instances of one with the other.
Structural equivalence ignores the naming of operations and fields in
bundles, and any annotations. Deduplicating a module may cause the result
type of instances to change if the field names of a bundle type change. To
handle this, the pass will update any bulk-connections so that the correct
fields are legally connected. Deduplicated modules will have their
annotations merged, which tends to create many non-local annotations.</p><h4 id=statistics-8>Statistics&nbsp;<a class=headline-hash href=#statistics-8>¶</a></h4><pre tabindex=0><code>num-erased-modules : Number of modules which were erased by deduplication
</code></pre><h3 id=-firrtl-drop-const><code>-firrtl-drop-const</code>&nbsp;<a class=headline-hash href=#-firrtl-drop-const>¶</a></h3><p><em>Drop &lsquo;const&rsquo; modifier from types</em></p><p>This pass drops the &lsquo;const&rsquo; modifier from all types and removes all
const-cast ops.</p><p>This simplifies downstream passes and folds so that they do not need to
take &lsquo;const&rsquo; into account.</p><h3 id=-firrtl-drop-names><code>-firrtl-drop-names</code>&nbsp;<a class=headline-hash href=#-firrtl-drop-names>¶</a></h3><p><em>Drop interesting names</em></p><p>This pass changes names of namable ops to droppable so that we can disable
full name preservation. For example,
before:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%a</span> <span class=p>=</span> firrtl<span class=p>.</span>node interesting_name <span class=nv>%input</span>
</span></span></code></pre></div><p>after:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%a</span> <span class=p>=</span> firrtl<span class=p>.</span>node droppable_name <span class=nv>%input</span>
</span></span></code></pre></div><h4 id=options-20>Options&nbsp;<a class=headline-hash href=#options-20>¶</a></h4><pre tabindex=0><code>-preserve-values : specify the values which can be optimized away
</code></pre><h4 id=statistics-9>Statistics&nbsp;<a class=headline-hash href=#statistics-9>¶</a></h4><pre tabindex=0><code>num-names-dropped   : Number of names dropped
num-names-converted : Number of interesting names made droppable
</code></pre><h3 id=-firrtl-emit-metadata><code>-firrtl-emit-metadata</code>&nbsp;<a class=headline-hash href=#-firrtl-emit-metadata>¶</a></h3><p><em>Emit metadata of the FIRRTL modules</em></p><p>This pass handles the emission of several different kinds of metadata.</p><h4 id=options-21>Options&nbsp;<a class=headline-hash href=#options-21>¶</a></h4><pre tabindex=0><code>-repl-seq-mem      : Lower the seq mem for macro replacement and emit relevant metadata
-repl-seq-mem-file : File to which emit seq meme metadata
</code></pre><h3 id=-firrtl-emit-omir><code>-firrtl-emit-omir</code>&nbsp;<a class=headline-hash href=#-firrtl-emit-omir>¶</a></h3><p><em>Emit OMIR annotations</em></p><p>This pass gathers the <code>OMIRAnnotation</code>s in the design, updates the contained
targets with the trackers that were scattered throughout the design upon
reading the OMIR, and serializes the resulting data into a JSON file.</p><h4 id=options-22>Options&nbsp;<a class=headline-hash href=#options-22>¶</a></h4><pre tabindex=0><code>-file : Output file for the JSON-serialized OMIR data
</code></pre><h3 id=-firrtl-expand-whens><code>-firrtl-expand-whens</code>&nbsp;<a class=headline-hash href=#-firrtl-expand-whens>¶</a></h3><p><em>Remove all when conditional blocks.</em></p><p>This pass will:</p><ol><li>Resolve last connect semantics.</li><li>Remove all when operations.</li></ol><p>When a wire has multiple connections, only the final connection is used,
all previous connections are overwritten. When there is a conditional
connect, the previous connect is only overwritten when the condition
holds:</p><pre tabindex=0><code class=language-firrtl data-lang=firrtl>w &lt;= a
when c :
  w &lt;= b

; Equivalent to:
w &lt;= mux(c, b, a)
</code></pre><p>This pass requires that all connects are expanded.</p><h3 id=-firrtl-extract-instances><code>-firrtl-extract-instances</code>&nbsp;<a class=headline-hash href=#-firrtl-extract-instances>¶</a></h3><p><em>Move annotated instances upwards in the module hierarchy</em></p><p>This pass takes instances in the design annotated with one out of a
particular set of annotations and pulls them upwards to a location further
up in the module hierarchy.</p><p>The annotations that control the behaviour of this pass are:</p><ul><li><code>MarkDUTAnnotation</code></li><li><code>ExtractBlackBoxAnnotation</code></li><li><code>ExtractClockGatesFileAnnotation</code></li></ul><h3 id=-firrtl-finalize-ir><code>-firrtl-finalize-ir</code>&nbsp;<a class=headline-hash href=#-firrtl-finalize-ir>¶</a></h3><p><em>Perform final IR mutations after ExportVerilog</em></p><p>This pass finalizes the IR after it has been exported with ExportVerilog,
and before firtool emits the final IR. This includes mutations like dropping
verbatim ops that represent sideband files and are not required in the IR.</p><h3 id=-firrtl-flatten-memory><code>-firrtl-flatten-memory</code>&nbsp;<a class=headline-hash href=#-firrtl-flatten-memory>¶</a></h3><p><em>Flatten aggregate memory data to a UInt</em></p><p>This pass flattens the aggregate data of memory into a UInt, and inserts
appropriate bitcasts to access the data.</p><h4 id=statistics-10>Statistics&nbsp;<a class=headline-hash href=#statistics-10>¶</a></h4><pre tabindex=0><code>num-flatten-mems : Number of memories flattened
</code></pre><h3 id=-firrtl-grand-central><code>-firrtl-grand-central</code>&nbsp;<a class=headline-hash href=#-firrtl-grand-central>¶</a></h3><p><em>Remove Grand Central Annotations</em></p><p>Processes annotations associated with SiFive&rsquo;s Grand Central utility.</p><h4 id=options-23>Options&nbsp;<a class=headline-hash href=#options-23>¶</a></h4><pre tabindex=0><code>-companion-mode : specify the handling of companion modules
</code></pre><h4 id=statistics-11>Statistics&nbsp;<a class=headline-hash href=#statistics-11>¶</a></h4><pre tabindex=0><code>num-views-created       : Number of top-level SystemVerilog interfaces that were created
num-interfaces-created  : Number of SystemVerilog interfaces that were created
num-xmrs-created        : Number of SystemVerilog XMRs added
num-annotations-removed : Number of annotations removed
</code></pre><h3 id=-firrtl-hoist-passthrough><code>-firrtl-hoist-passthrough</code>&nbsp;<a class=headline-hash href=#-firrtl-hoist-passthrough>¶</a></h3><p><em>Hoist passthrough logic</em></p><p>This pass hoists simple passthrough connections up.</p><h4 id=options-24>Options&nbsp;<a class=headline-hash href=#options-24>¶</a></h4><pre tabindex=0><code>-hoist-hw : Hoist HW drivers.
</code></pre><h4 id=statistics-12>Statistics&nbsp;<a class=headline-hash href=#statistics-12>¶</a></h4><pre tabindex=0><code>num-u-turns     : Number of u-turns hoisted
num-ref-drivers : Number of ref-type drivers processed
num-hw-drivers  : Number of hw-type drivers processed
</code></pre><h3 id=-firrtl-imconstprop><code>-firrtl-imconstprop</code>&nbsp;<a class=headline-hash href=#-firrtl-imconstprop>¶</a></h3><p><em>Intermodule constant propagation and dead code elimination</em></p><p>Use optimistic constant propagation to delete ports and unreachable IR.</p><h4 id=statistics-13>Statistics&nbsp;<a class=headline-hash href=#statistics-13>¶</a></h4><pre tabindex=0><code>num-folded-op : Number of operations folded
num-erased-op : Number of operations erased
</code></pre><h3 id=-firrtl-imdeadcodeelim><code>-firrtl-imdeadcodeelim</code>&nbsp;<a class=headline-hash href=#-firrtl-imdeadcodeelim>¶</a></h3><p><em>Intermodule dead code elimination</em></p><p>This pass performs inter-module liveness analysis and deletes dead code
aggressively. A value is considered as alive if it is connected to a port
of public modules or a value with a symbol. We first populate alive values
into a set, and then propagate the liveness by looking at their dataflow.</p><h4 id=statistics-14>Statistics&nbsp;<a class=headline-hash href=#statistics-14>¶</a></h4><pre tabindex=0><code>num-erased-ops     : Number of operations erased
num-erased-modules : Number of modules erased
num-removed-ports  : Number of ports erased
</code></pre><h3 id=-firrtl-infer-resets><code>-firrtl-infer-resets</code>&nbsp;<a class=headline-hash href=#-firrtl-infer-resets>¶</a></h3><p><em>Infer reset synchronicity and add implicit resets</em></p><p>This pass infers whether resets are synchronous or asynchronous, and extends
reset-less registers with an asynchronous reset based on the following
annotations:</p><ul><li><code>sifive.enterprise.firrtl.FullAsyncResetAnnotation</code></li><li><code>sifive.enterprise.firrtl.IgnoreFullAsyncResetAnnotation</code></li></ul><h3 id=-firrtl-infer-rw><code>-firrtl-infer-rw</code>&nbsp;<a class=headline-hash href=#-firrtl-infer-rw>¶</a></h3><p><em>Infer the read-write memory port</em></p><p>This pass merges the read and write ports of a memory, using a simple
module-scoped heuristic. The heuristic checks if the read and write enable
conditions are mutually exclusive.
The heuristic tries to break up the read enable and write enable logic into an
<code>AND</code> expression tree. It then compares the read and write <code>AND</code> terms,
looking for a situation where the read/write is the complement of the write/read.</p><h4 id=statistics-15>Statistics&nbsp;<a class=headline-hash href=#statistics-15>¶</a></h4><pre tabindex=0><code>num-rw-port-mems-inferred : Number of memories inferred to use RW port
</code></pre><h3 id=-firrtl-infer-widths><code>-firrtl-infer-widths</code>&nbsp;<a class=headline-hash href=#-firrtl-infer-widths>¶</a></h3><p><em>Infer the width of types</em></p><p>This pass infers the widths of all types throughout a FIRRTL module, and
emits diagnostics for types that could not be inferred.</p><h3 id=-firrtl-inject-dut-hier><code>-firrtl-inject-dut-hier</code>&nbsp;<a class=headline-hash href=#-firrtl-inject-dut-hier>¶</a></h3><p><em>Add a level of hierarchy outside the DUT</em></p><p>This pass takes the DUT (as indicated by the presence of a
MarkDUTAnnotation) and moves all the contents of it into a new module
insided the DUT named by an InjectDUTHierarchyAnnotation. This pass is
intended to be used in conjunction with passes that pull things out of the
DUT, e.g., SRAM extraction, to give the extracted modules a new home that is
still inside the original DUT.</p><h3 id=-firrtl-inliner><code>-firrtl-inliner</code>&nbsp;<a class=headline-hash href=#-firrtl-inliner>¶</a></h3><p><em>Performs inlining, flattening, and dead module elimination</em></p><p>This inliner pass will inline any instance of module marked as inline, and
recursively inline all instances inside of a module marked with flatten.
This pass performs renaming of every entity with a name that is inlined by
prefixing it with the instance name. This pass also will remove any module
which is not reachable from the top level module.</p><p>The inline and flatten annotation attributes are attached to module
definitions, and they are:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=p>{</span><span class=nl>class =</span> <span class=s>&#34;firrtl.passes.InlineAnnotation&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span><span class=nl>class =</span> <span class=s>&#34;firrtl.transforms.FlattenAnnotation&#34;</span><span class=p>}</span>
</span></span></code></pre></div><h3 id=-firrtl-inner-symbol-dce><code>-firrtl-inner-symbol-dce</code>&nbsp;<a class=headline-hash href=#-firrtl-inner-symbol-dce>¶</a></h3><p><em>Eliminate dead inner symbols</em></p><p>This pass deletes all inner symbols which have no uses. This is necessary to
unblock optimizations and removal of the operations which have these unused
inner symbols.</p><h4 id=statistics-16>Statistics&nbsp;<a class=headline-hash href=#statistics-16>¶</a></h4><pre tabindex=0><code>num-inner-refs-found  : Number of inner-refs found
num-inner-sym-found   : Number of inner symbols found
num-inner-sym-removed : Number of inner symbols removed
</code></pre><h3 id=-firrtl-layer-merge><code>-firrtl-layer-merge</code>&nbsp;<a class=headline-hash href=#-firrtl-layer-merge>¶</a></h3><p><em>Merge layer blocks</em></p><p>Combine all layer blocks in a module which reference the same layer
definition.</p><h4 id=statistics-17>Statistics&nbsp;<a class=headline-hash href=#statistics-17>¶</a></h4><pre tabindex=0><code>num-merged : Number of layers merged
</code></pre><h3 id=-firrtl-layer-sink><code>-firrtl-layer-sink</code>&nbsp;<a class=headline-hash href=#-firrtl-layer-sink>¶</a></h3><p><em>Sink operations into layer blocks</em></p><h4 id=statistics-18>Statistics&nbsp;<a class=headline-hash href=#statistics-18>¶</a></h4><pre tabindex=0><code>num-sunk : Number of operations sunk
</code></pre><h3 id=-firrtl-lint><code>-firrtl-lint</code>&nbsp;<a class=headline-hash href=#-firrtl-lint>¶</a></h3><p><em>An analysis pass to detect static simulation failures.</em></p><p>This pass detects operations that will trivially fail any simulation.
Currently it detects assertions whose predicate condition can be statically
inferred to be false. The pass emits error on such failing ops.</p><h3 id=-firrtl-lower-annotations><code>-firrtl-lower-annotations</code>&nbsp;<a class=headline-hash href=#-firrtl-lower-annotations>¶</a></h3><p><em>Lower FIRRTL annotations to usable entities</em></p><p>Lower FIRRTL annotations to usable forms. FIRRTL annotations are a big bag
of semi-structured, irregular JSON. This pass normalizes all supported
annotations and annotation paths.</p><h4 id=options-25>Options&nbsp;<a class=headline-hash href=#options-25>¶</a></h4><pre tabindex=0><code>-disable-annotation-classless : Ignore classless annotations.
-disable-annotation-unknown   : Ignore unknown annotations.
-no-ref-type-ports            : Create normal ports, not ref type ports.
</code></pre><h4 id=statistics-19>Statistics&nbsp;<a class=headline-hash href=#statistics-19>¶</a></h4><pre tabindex=0><code>num-raw-annos       : Number of raw annotations on circuit
num-added-annos     : Number of additional annotations
num-annos           : Total number of annotations processed
num-unhandled-annos : Number of unhandled annotations
num-reused-hierpath : Number of reused HierPathOp&#39;s
</code></pre><h3 id=-firrtl-lower-chirrtl><code>-firrtl-lower-chirrtl</code>&nbsp;<a class=headline-hash href=#-firrtl-lower-chirrtl>¶</a></h3><p><em>Infer the memory ports of SeqMem and CombMem</em></p><p>This pass finds the CHIRRTL behavioral memories and their ports, and
transforms them into standard FIRRTL memory operations. For each
<code>seqmem</code> or <code>combmem</code>, a new memory is created. For every <code>memoryport</code>
operation using a CHIRRTL memory, a memory port is defined on the
new standard memory.</p><p>The direction or kind of the port is inferred from how each of the memory
ports is used in the IR. If a memory port is only written to, it becomes
a <code>Write</code> port. If a memory port is only read from, it become a <code>Read</code>
port. If it is used both ways, it becomes a <code>ReadWrite</code> port.</p><p><code>Write</code>, <code>ReadWrite</code> and combinational <code>Read</code> ports are disabled by
default, but then enabled when the CHIRRTL memory port is declared.
Sequential <code>Read</code> ports have more complicated enable inference:</p><ol><li>If a wire or register is used as the index of the memory port, then
the memory is enabled whenever a non-invalid value is driven to the
address.</li><li>If a node is used as the index of the memory port, then the memory is
enabled at the declaration of the node.</li><li>In all other cases, the memory is never enabled.</li></ol><p>In the first two cases, they can easily produce a situation where we try
to enable the memory before it is even declared. This produces a
compilation error.</p><h4 id=statistics-20>Statistics&nbsp;<a class=headline-hash href=#statistics-20>¶</a></h4><pre tabindex=0><code>num-created-mems  : Number of memories created
num-lowered-mems  : Number of memories lowered
num-portless-mems : Number of memories dropped as having no valid ports
</code></pre><h3 id=-firrtl-lower-classes><code>-firrtl-lower-classes</code>&nbsp;<a class=headline-hash href=#-firrtl-lower-classes>¶</a></h3><p><em>Lower FIRRTL classes and objects to OM classes and objects</em></p><p>This pass walks all FIRRTL classes and creates OM classes. It also lowers
FIRRTL objects to OM objects. OM classes are created with parameters
corresponding to FIRRTL input properties, and OM class fields corresponding
to FIRRTL output properties. FIRRTL operations are converted to OM
operations.</p><h3 id=-firrtl-lower-intmodules><code>-firrtl-lower-intmodules</code>&nbsp;<a class=headline-hash href=#-firrtl-lower-intmodules>¶</a></h3><p><em>Lower instances instances of intrinsic modules to ops.</em></p><p>This pass replaces instances of intrinsic modules (intmodule) with
<code>firrtl.int.generic</code> operations, and removes the intmodule&rsquo;s from
the circuit.</p><p>Use this before running LowerIntrinsics.</p><h4 id=options-26>Options&nbsp;<a class=headline-hash href=#options-26>¶</a></h4><pre tabindex=0><code>-fixup-eicg-wrapper : Lower `EICG_wrapper` modules into clock gate intrinsics
</code></pre><h3 id=-firrtl-lower-intrinsics><code>-firrtl-lower-intrinsics</code>&nbsp;<a class=headline-hash href=#-firrtl-lower-intrinsics>¶</a></h3><p><em>Lower intrinsics</em></p><p>This pass lowers intrinsics encoded as extmodule with annotation and
intmodule to their implementation or op.</p><h4 id=options-27>Options&nbsp;<a class=headline-hash href=#options-27>¶</a></h4><pre tabindex=0><code>-fixup-eicg-wrapper : Lower `EICG_wrapper` modules into clock gate intrinsics
</code></pre><h3 id=-firrtl-lower-layers><code>-firrtl-lower-layers</code>&nbsp;<a class=headline-hash href=#-firrtl-lower-layers>¶</a></h3><p><em>Lower layers and layer blocks to instances</em></p><p>This pass lowers FIRRTL layers as defined by their convention. After this
pass, all layer blocks and layers are removed.</p><h3 id=-firrtl-lower-matches><code>-firrtl-lower-matches</code>&nbsp;<a class=headline-hash href=#-firrtl-lower-matches>¶</a></h3><p><em>Remove all matchs conditional blocks</em></p><p>Lowers FIRRTL match statements in to when statements, which can later be
lowered with ExpandWhens.</p><h3 id=-firrtl-lower-memory><code>-firrtl-lower-memory</code>&nbsp;<a class=headline-hash href=#-firrtl-lower-memory>¶</a></h3><p><em>Lower memories to generated modules</em></p><p>This pass lowers FIRRTL memory operations to generated modules.</p><h4 id=statistics-21>Statistics&nbsp;<a class=headline-hash href=#statistics-21>¶</a></h4><pre tabindex=0><code>num-created-mem-modules : Number of modules created
num-lowered-mems        : Number of memories lowered
</code></pre><h3 id=-firrtl-lower-open-aggs><code>-firrtl-lower-open-aggs</code>&nbsp;<a class=headline-hash href=#-firrtl-lower-open-aggs>¶</a></h3><p><em>Lower &lsquo;Open&rsquo; aggregates by splitting out non-hardware elements</em></p><p>This pass lowers aggregates of the more open varieties into their equivalents
using only hardware types, by pulling out non-hardware to other locations.</p><h3 id=-firrtl-lower-signatures><code>-firrtl-lower-signatures</code>&nbsp;<a class=headline-hash href=#-firrtl-lower-signatures>¶</a></h3><p><em>Lower FIRRTL module signatures</em></p><p>Lower aggregate FIRRTL types in Modules as indicated by the calling
convention.</p><h3 id=-firrtl-lower-types><code>-firrtl-lower-types</code>&nbsp;<a class=headline-hash href=#-firrtl-lower-types>¶</a></h3><p><em>Lower FIRRTL types to ground types</em></p><p>Lower aggregate FIRRTL types to ground types. Memories, ports, wires, etc
are split apart by elements of aggregate types. The only aggregate types
which exist after this pass are memory ports, though memory data types are
split.</p><p>Connect and expansion and canonicalization happen in this pass.</p><h4 id=options-28>Options&nbsp;<a class=headline-hash href=#options-28>¶</a></h4><pre tabindex=0><code>-flatten-mem        : Concat all elements of the aggregate data into a single element.
-preserve-aggregate : Specify aggregate preservation mode
-preserve-memories  : Specify memory preservation mode
</code></pre><h3 id=-firrtl-lower-xmr><code>-firrtl-lower-xmr</code>&nbsp;<a class=headline-hash href=#-firrtl-lower-xmr>¶</a></h3><p><em>Lower ref ports to XMR</em></p><p>This pass lowers RefType ops and ports to verbatim encoded XMRs.</p><h3 id=-firrtl-materialize-debug-info><code>-firrtl-materialize-debug-info</code>&nbsp;<a class=headline-hash href=#-firrtl-materialize-debug-info>¶</a></h3><p><em>Generate debug ops to track FIRRTL values</em></p><p>This pass creates debug ops to track FIRRTL-level ports, nodes, wires,
registers, and instances throughout the pipeline. The <code>DebugInfo</code> analysis
can then be used at a later point in the pipeline to obtain a source
language view into the lowered IR.</p><h3 id=-firrtl-mem-to-reg-of-vec><code>-firrtl-mem-to-reg-of-vec</code>&nbsp;<a class=headline-hash href=#-firrtl-mem-to-reg-of-vec>¶</a></h3><p><em>Convert combinational memories to a vector of registers</em></p><p>This pass generates the logic to implement a memory using Registers.</p><h4 id=options-29>Options&nbsp;<a class=headline-hash href=#options-29>¶</a></h4><pre tabindex=0><code>-repl-seq-mem           : Prepare seq mems for macro replacement
-ignore-read-enable-mem : ignore the read enable signal, instead of assigning X on read disable
</code></pre><h4 id=statistics-22>Statistics&nbsp;<a class=headline-hash href=#statistics-22>¶</a></h4><pre tabindex=0><code>num-converted-mems : Number of memories converted to registers
</code></pre><h3 id=-firrtl-passive-wires><code>-firrtl-passive-wires</code>&nbsp;<a class=headline-hash href=#-firrtl-passive-wires>¶</a></h3><p><em>Make FIRRTL wires have passive type</em></p><p>Eliminate flips from aggregate types on wires.</p><h3 id=-firrtl-prefix-modules><code>-firrtl-prefix-modules</code>&nbsp;<a class=headline-hash href=#-firrtl-prefix-modules>¶</a></h3><p><em>Prefixes names of modules and mems in a hierarchy</em></p><p>This pass looks for modules annotated with the
<code>NestedPrefixModulesAnnotation</code> and prefixes the names of all modules
instantiated underneath it. If <code>inclusive</code> is true, it includes the target
module in the renaming. If <code>inclusive</code> is false, it will only rename
modules instantiated underneath the target module. If a module is required
to have two different prefixes, it will be cloned.</p><p>The supported annotation is:</p><pre tabindex=0><code>  {
    class = &#34;sifive.enterprise.firrtl.NestedPrefixModulesAnnotation&#34;,
    prefix = &#34;MyPrefix_&#34;,
    inclusive = true
  }
</code></pre><h3 id=-firrtl-print-field-source><code>-firrtl-print-field-source</code>&nbsp;<a class=headline-hash href=#-firrtl-print-field-source>¶</a></h3><p><em>Print field source information.</em></p><h3 id=-firrtl-print-instance-graph><code>-firrtl-print-instance-graph</code>&nbsp;<a class=headline-hash href=#-firrtl-print-instance-graph>¶</a></h3><p><em>Print a DOT graph of the module hierarchy.</em></p><h3 id=-firrtl-print-nla-table><code>-firrtl-print-nla-table</code>&nbsp;<a class=headline-hash href=#-firrtl-print-nla-table>¶</a></h3><p><em>Print the NLA Table.</em></p><h3 id=-firrtl-probe-dce><code>-firrtl-probe-dce</code>&nbsp;<a class=headline-hash href=#-firrtl-probe-dce>¶</a></h3><p><em>Delete dead probe ports and operations.</em></p><p>Simple pass to delete dead probe ports and operations.
Diagnoses illegal or unsupported input probe uses.
Post-condition: no input probe ports.</p><h4 id=statistics-23>Statistics&nbsp;<a class=headline-hash href=#statistics-23>¶</a></h4><pre tabindex=0><code>num-erased-ports : Number of ports erased
num-erased-ops   : Number of operations erased
</code></pre><h3 id=-firrtl-randomize-register-init><code>-firrtl-randomize-register-init</code>&nbsp;<a class=headline-hash href=#-firrtl-randomize-register-init>¶</a></h3><p><em>Randomize register initialization.</em></p><p>This pass eagerly creates large vectors of randomized bits for initializing
registers, and marks each register with attributes indicating which bits to
read. If the registers survive until LowerToHW, their initialization logic
will pick up the correct bits.</p><p>This ensures a stable initialization, so registers should always see the
same initial value for the same seed, regardless of optimization levels.</p><h3 id=-firrtl-register-optimizer><code>-firrtl-register-optimizer</code>&nbsp;<a class=headline-hash href=#-firrtl-register-optimizer>¶</a></h3><p><em>Optimizer Registers</em></p><p>This pass applies classic FIRRTL register optimizations. These
optimizations are isolated to this pass as they can change the visible
behavior of the register, especially before reset.</p><h3 id=-firrtl-remove-unused-ports><code>-firrtl-remove-unused-ports</code>&nbsp;<a class=headline-hash href=#-firrtl-remove-unused-ports>¶</a></h3><p><em>Remove unused ports</em></p><p>This pass removes unused ports without annotations or symbols. Implementation
wise, this pass iterates over the instance graph in a topological order from
leaves to the top so that we can remove unused ports optimally.</p><h4 id=statistics-24>Statistics&nbsp;<a class=headline-hash href=#statistics-24>¶</a></h4><pre tabindex=0><code>num-removed-ports : Number of ports erased
</code></pre><h3 id=-firrtl-resolve-paths><code>-firrtl-resolve-paths</code>&nbsp;<a class=headline-hash href=#-firrtl-resolve-paths>¶</a></h3><p><em>Lowers UnresolvedPathOps to PathOps</em></p><p>FIRRTL path operations are initially create as unresolved path operations,
which encode their target as a string. This pass parses and resolves those
target strings to actual path operations. Path operations refer to their
targets using annotations with a unique identifier.</p><h3 id=-firrtl-resolve-traces><code>-firrtl-resolve-traces</code>&nbsp;<a class=headline-hash href=#-firrtl-resolve-traces>¶</a></h3><p><em>Write out TraceAnnotations to an output annotation file</em></p><p>This pass implements Chisel&rsquo;s Trace API. It collects all TraceAnnotations
that exist in the circuit, updates them with information about the final
target in a design, and writes these to an output annotation file. This
exists for Chisel users to build tooling around them that needs to query the
final output name/path of some component in a Chisel circuit.</p><p>Note: this pass and API are expected to be eventually replaced via APIs and
language bindings that enable users to directly query the MLIR.</p><h4 id=options-30>Options&nbsp;<a class=headline-hash href=#options-30>¶</a></h4><pre tabindex=0><code>-file : Output file for the JSON-serialized Trace Annotations
</code></pre><h3 id=-firrtl-sfc-compat><code>-firrtl-sfc-compat</code>&nbsp;<a class=headline-hash href=#-firrtl-sfc-compat>¶</a></h3><p><em>Perform SFC Compatibility fixes</em></p><h3 id=-firrtl-specialize-option><code>-firrtl-specialize-option</code>&nbsp;<a class=headline-hash href=#-firrtl-specialize-option>¶</a></h3><p><em>Specialize a configurable design for a given option.</em></p><p>If the design has option groups, instead of preserving the information
up to the emitted SystemVerilog, this pass specializes it early on for a
given choice.</p><h4 id=options-31>Options&nbsp;<a class=headline-hash href=#options-31>¶</a></h4><pre tabindex=0><code>-select : Options to specialize, in option=case format
</code></pre><h4 id=statistics-25>Statistics&nbsp;<a class=headline-hash href=#statistics-25>¶</a></h4><pre tabindex=0><code>num-instances : Number of instances specialized
</code></pre><h3 id=-firrtl-vb-to-bv><code>-firrtl-vb-to-bv</code>&nbsp;<a class=headline-hash href=#-firrtl-vb-to-bv>¶</a></h3><p><em>Transform vector-of-bundles to bundle-of-vectors</em></p><p>This pass converts vectors containing bundles, into bundles containing
vectors.</p><h3 id=-merge-connections><code>-merge-connections</code>&nbsp;<a class=headline-hash href=#-merge-connections>¶</a></h3><p><em>Merge field-level connections into full bundle connections</em></p><h4 id=options-32>Options&nbsp;<a class=headline-hash href=#options-32>¶</a></h4><pre tabindex=0><code>-aggressive-merging : Merge connections even when source values won&#39;t be simplified.
</code></pre><h3 id=-vectorization><code>-vectorization</code>&nbsp;<a class=headline-hash href=#-vectorization>¶</a></h3><p><em>Transform firrtl primitive operations into vector operations</em></p><h2 id=fsm-dialect-passes>FSM Dialect Passes&nbsp;<a class=headline-hash href=#fsm-dialect-passes>¶</a></h2><h3 id=-fsm-print-graph><code>-fsm-print-graph</code>&nbsp;<a class=headline-hash href=#-fsm-print-graph>¶</a></h3><p><em>Print a DOT graph of the module hierarchy.</em></p><h2 id=handshake-dialect-passes>Handshake Dialect Passes&nbsp;<a class=headline-hash href=#handshake-dialect-passes>¶</a></h2><h3 id=-handshake-add-ids><code>-handshake-add-ids</code>&nbsp;<a class=headline-hash href=#-handshake-add-ids>¶</a></h3><p><em>Add an ID to each operation in a handshake function.</em></p><p>This pass adds an ID to each operation in a handshake function. This id can
be used in lowerings facilitate mapping lowered IR back to the handshake code
which it originated from. An ID is unique with respect to other operations
of the same type in the function. The tuple of the operation name and the
operation ID denotes a unique identifier for the operation within the
<code>handshake.func</code> operation.</p><h3 id=-handshake-dematerialize-forks-sinks><code>-handshake-dematerialize-forks-sinks</code>&nbsp;<a class=headline-hash href=#-handshake-dematerialize-forks-sinks>¶</a></h3><p><em>Dematerialize fork and sink operations.</em></p><p>This pass analyses a handshake.func operation and removes all fork and sink
operations.</p><h3 id=-handshake-insert-buffers><code>-handshake-insert-buffers</code>&nbsp;<a class=headline-hash href=#-handshake-insert-buffers>¶</a></h3><p><em>Insert buffers to break graph cycles</em></p><h4 id=options-33>Options&nbsp;<a class=headline-hash href=#options-33>¶</a></h4><pre tabindex=0><code>-strategy    : Strategy to apply. Possible values are: cycles, allFIFO, all (default)
-buffer-size : Number of slots in each buffer
</code></pre><h3 id=-handshake-legalize-memrefs><code>-handshake-legalize-memrefs</code>&nbsp;<a class=headline-hash href=#-handshake-legalize-memrefs>¶</a></h3><p><em>Memref legalization and lowering pass.</em></p><p>Lowers various memref operations to a state suitable for passing to the
CFToHandshake lowering.</p><h3 id=-handshake-lock-functions><code>-handshake-lock-functions</code>&nbsp;<a class=headline-hash href=#-handshake-lock-functions>¶</a></h3><p><em>Lock each function to only allow single invocations.</em></p><p>This pass adds a locking mechanism to each handshake function. This mechanism
ensures that only one control token can be active in a function at each point
in time.</p><h3 id=-handshake-lower-extmem-to-hw><code>-handshake-lower-extmem-to-hw</code>&nbsp;<a class=headline-hash href=#-handshake-lower-extmem-to-hw>¶</a></h3><p><em>Lowers handshake.extmem and memref inputs to ports.</em></p><p>Lowers handshake.extmem and memref inputs to a hardware-targeting
memory accessing scheme (explicit load- and store ports on the top
level interface).</p><h4 id=options-34>Options&nbsp;<a class=headline-hash href=#options-34>¶</a></h4><pre tabindex=0><code>-wrap-esi : Create an ESI wrapper for the module. Any extmem will be served by an esi.mem.ram service
</code></pre><h3 id=-handshake-materialize-forks-sinks><code>-handshake-materialize-forks-sinks</code>&nbsp;<a class=headline-hash href=#-handshake-materialize-forks-sinks>¶</a></h3><p><em>Materialize fork and sink operations.</em></p><p>This pass analyses a handshake.func operation and inserts fork and sink
operations ensuring that all values have exactly one use.</p><h3 id=-handshake-op-count><code>-handshake-op-count</code>&nbsp;<a class=headline-hash href=#-handshake-op-count>¶</a></h3><p><em>Count the number of operations (resources) in a handshake function.</em></p><p>This pass analyses a handshake.func operation and prints the number of
operations (resources) used the function.</p><h3 id=-handshake-print-dot><code>-handshake-print-dot</code>&nbsp;<a class=headline-hash href=#-handshake-print-dot>¶</a></h3><p><em>Print .dot graph of a handshake function.</em></p><p>This pass analyses a handshake.func operation and prints a .dot graph of the
structure. If multiple functions are present in the IR, the top level
function will be printed, and called functions will be subgraphs within
the main graph.</p><h3 id=-handshake-remove-buffers><code>-handshake-remove-buffers</code>&nbsp;<a class=headline-hash href=#-handshake-remove-buffers>¶</a></h3><p><em>Remove buffers from handshake functions.</em></p><p>This pass analyses a handshake.func operation and removes any buffers from
the function.</p><h2 id=hw-dialect-passes>HW Dialect Passes&nbsp;<a class=headline-hash href=#hw-dialect-passes>¶</a></h2><h3 id=-hw-flatten-io><code>-hw-flatten-io</code>&nbsp;<a class=headline-hash href=#-hw-flatten-io>¶</a></h3><p><em>Flattens hw::Structure typed in- and output ports.</em></p><h4 id=options-35>Options&nbsp;<a class=headline-hash href=#options-35>¶</a></h4><pre tabindex=0><code>-recursive      : Recursively flatten nested structs.
-flatten-extern : Flatten the extern modules also.
-join-char      : Use a custom character to construct the flattened names.
</code></pre><h3 id=-hw-print-instance-graph><code>-hw-print-instance-graph</code>&nbsp;<a class=headline-hash href=#-hw-print-instance-graph>¶</a></h3><p><em>Print a DOT graph of the module hierarchy.</em></p><h3 id=-hw-print-module-graph><code>-hw-print-module-graph</code>&nbsp;<a class=headline-hash href=#-hw-print-module-graph>¶</a></h3><p><em>Print a DOT graph of the HWModule&rsquo;s within a top-level module.</em></p><h4 id=options-36>Options&nbsp;<a class=headline-hash href=#options-36>¶</a></h4><pre tabindex=0><code>-verbose-edges : Print information on SSA edges (types, operand #, ...)
</code></pre><h3 id=-hw-specialize><code>-hw-specialize</code>&nbsp;<a class=headline-hash href=#-hw-specialize>¶</a></h3><p><em>Specializes instances of parametric hw.modules</em></p><p>Any <code>hw.instance</code> operation instantiating a parametric <code>hw.module</code> will
trigger a specialization procedure which resolves all parametric types and
values within the module based on the set of provided parameters to the
<code>hw.instance</code> operation. This specialized module is created as a new
<code>hw.module</code> and the referring <code>hw.instance</code> operation is rewritten to
instantiate the newly specialized module.</p><h3 id=-hw-verify-irn><code>-hw-verify-irn</code>&nbsp;<a class=headline-hash href=#-hw-verify-irn>¶</a></h3><p><em>Verify InnerRefNamespaceLike operations, if not self-verifying.</em></p><h2 id=ibis-dialect-passes>Ibis Dialect Passes&nbsp;<a class=headline-hash href=#ibis-dialect-passes>¶</a></h2><h3 id=-ibis-add-operator-library><code>-ibis-add-operator-library</code>&nbsp;<a class=headline-hash href=#-ibis-add-operator-library>¶</a></h3><p><em>Injects the Ibis operator library into the IR</em></p><p>Injects the Ibis operator library into the IR, which contains the
definitions of the Ibis operators.</p><h3 id=-ibis-argify-blocks><code>-ibis-argify-blocks</code>&nbsp;<a class=headline-hash href=#-ibis-argify-blocks>¶</a></h3><p><em>Add arguments to ibis blocks</em></p><p>Analyses <code>ibis.sblock</code> operations and converts any SSA value defined outside
the <code>ibis.sblock</code> to a block argument. As a result, <code>ibis.sblock.isolated</code>
are produced.</p><h3 id=-ibis-call-prep><code>-ibis-call-prep</code>&nbsp;<a class=headline-hash href=#-ibis-call-prep>¶</a></h3><p><em>Convert ibis method calls to use <code>dc.value</code></em></p><h3 id=-ibis-clean-selfdrivers><code>-ibis-clean-selfdrivers</code>&nbsp;<a class=headline-hash href=#-ibis-clean-selfdrivers>¶</a></h3><p><em>Ibis clean selfdrivers pass</em></p><ul><li>Removes <code>ibis.port.input</code>s which are driven by operations within the same
container.</li><li>Removes reads of instance ports which are also written to within the same
container.</li></ul><h3 id=-ibis-containerize><code>-ibis-containerize</code>&nbsp;<a class=headline-hash href=#-ibis-containerize>¶</a></h3><p><em>Ibis containerization pass</em></p><p>Convert Ibis classes to containers, and outlines containers inside classes.</p><h3 id=-ibis-convert-cf-to-handshake><code>-ibis-convert-cf-to-handshake</code>&nbsp;<a class=headline-hash href=#-ibis-convert-cf-to-handshake>¶</a></h3><p><em>Converts an <code>ibis.method</code> to <code>ibis.method.df</code></em></p><p>Converts an <code>ibis.method</code> from using <code>cf</code> operations and MLIR blocks to
an <code>ibis.method.df</code> operation, using the <code>handshake</code> dialect to represent
control flow through the <code>handshake</code> fine grained dataflow operations.</p><h3 id=-ibis-convert-containers-to-hw><code>-ibis-convert-containers-to-hw</code>&nbsp;<a class=headline-hash href=#-ibis-convert-containers-to-hw>¶</a></h3><p><em>Ibis containers to hw conversion pass</em></p><p>Converts <code>ibis.container</code> ops to <code>hw.module</code> ops.</p><h3 id=-ibis-convert-handshake-to-dc><code>-ibis-convert-handshake-to-dc</code>&nbsp;<a class=headline-hash href=#-ibis-convert-handshake-to-dc>¶</a></h3><p><em>Converts an <code>ibis.method.df</code> to use DC</em></p><p>Converts an <code>ibis.method.df</code> from using <code>handshake</code> operations to
<code>dc</code> operations.</p><h3 id=-ibis-convert-methods-to-containers><code>-ibis-convert-methods-to-containers</code>&nbsp;<a class=headline-hash href=#-ibis-convert-methods-to-containers>¶</a></h3><p><em>Converts <code>ibis.method.df</code> to <code>ibis.container</code>s</em></p><h3 id=-ibis-inline-sblocks><code>-ibis-inline-sblocks</code>&nbsp;<a class=headline-hash href=#-ibis-inline-sblocks>¶</a></h3><p><em>Inlines <code>ibis.sblock</code> operations as MLIR blocks</em></p><p>Inlines <code>ibis.sblock</code> operations, by creating MLIR blocks and <code>cf</code>
operations, while adding attributes to the parent operation about
<code>sblock</code>-specific attributes.</p><p>The parent attributes are located under the <code>ibis.blockinfo</code> identifier as
a dictionary attribute.
Each entry in the dictionary consists of:</p><ul><li>Key: an ID (numerical) string identifying the block.</li><li>Value: a dictionary of attributes. As a minimum this will contain a
<code>loc</code>-keyed attribute specifying the location of the block.</li></ul><h3 id=-ibis-lower-portrefs><code>-ibis-lower-portrefs</code>&nbsp;<a class=headline-hash href=#-ibis-lower-portrefs>¶</a></h3><p><em>Ibis portref lowering pass</em></p><p>Lower <code>ibis.portref&lt;portref &lt;T>></code> to T (i.e. portref resolution).</p><p>We do this by analyzing how a portref is used
inside a container, and then creating an in- or output port based on that.
That is:</p><ul><li>write to <code>portref&lt;in portref&lt;in, T>></code> becomes <code>out T</code>
i.e this container wants to write to an input of another container, hence
it will produce an output value that will drive that input port.</li><li>read from <code>portref&lt;in portref&lt;out, T>></code> becomes <code>in T</code>
i.e. this container wants to read from an output of another container,
hence it will have an input port that will be driven by that output port.</li><li>write to <code>portref&lt;out portref&lt;out, T>></code> becomes <code>out T</code>
i.e. a port reference inside the module will be driven by a value from
the outside.</li><li>read from <code>portref&lt;out portref&lt;in, T>></code> becomes <code>in T</code>
i.e. a port reference inside the module will be driven by a value from
the outside.</li></ul><p>A benefit of having portref lowering separate from portref tunneling is that
portref lowering can be done on an <code>ibis.container</code> granularity, allowing
for a bit of parallelism in the flow.</p><h3 id=-ibis-prepare-scheduling><code>-ibis-prepare-scheduling</code>&nbsp;<a class=headline-hash href=#-ibis-prepare-scheduling>¶</a></h3><p><em>Prepare <code>ibis.sblock</code> operations for scheduling</em></p><p>Prepares <code>ibis.sblock</code> operations for scheduling by:</p><ul><li>creating an <code>ibis.pipleine.header</code> operation</li><li>moving operations of an <code>ibis.sblock</code> into a <code>pipeline.unscheduled</code>
operation, which is connected to the pipeline header.</li></ul><h3 id=-ibis-reblock><code>-ibis-reblock</code>&nbsp;<a class=headline-hash href=#-ibis-reblock>¶</a></h3><p><em>Recreates <code>ibis.sblock</code> operations from a CFG</em></p><p>Recreates <code>ibis.sblock</code> operations from a CFG. Any <code>ibis.block.attributes</code>
operations at the parent operation will be added to the resulting blocks.</p><p>The IR is expected to be in maximal SSA form prior to this pass, given that
the pass will only inspect the terminator operation of a block for any
values that are generated within the block. Maximum SSA form thus ensures
that any value defined within the block is never used outside of the block.</p><p>It is expected that <code>ibis.call</code> operations have been isolated into
their own basic blocks before this pass is run. This implies that all
operations within a block (except for the terminator operation) can be
statically scheduled with each other.</p><p>e.g.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nl>^bb_foo</span><span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nv>%res</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%v</span> <span class=p>=</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>  cf<span class=p>.</span>br <span class=nl>^bb_bar</span><span class=p>(</span><span class=nv>%v</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</span></span></code></pre></div><p>becomes</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nl>^bb_foo</span><span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nv>%v_outer</span> <span class=p>=</span> ibis<span class=p>.</span>sblock<span class=p>(</span><span class=nv>%a0</span> <span class=p>:</span> <span class=nl>i32 =</span> <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%a1</span> <span class=p>:</span> <span class=nl>i32 =</span> <span class=nv>%arg1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%res</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%v</span> <span class=p>=</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    ibis<span class=p>.</span>sblock<span class=p>.</span><span class=kt>return</span> <span class=nv>%v</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  cf<span class=p>.</span>br <span class=nl>^bb_bar</span><span class=p>(</span><span class=nv>%v_outer</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=-ibis-tunneling><code>-ibis-tunneling</code>&nbsp;<a class=headline-hash href=#-ibis-tunneling>¶</a></h3><p><em>Ibis tunneling pass</em></p><p>Tunnels relative <code>get_port</code> ops through the module hierarchy, based on
<code>ibis.path</code> ops. The result of this pass is that various new in- and output
ports of <code>!ibis.portref&lt;...></code> type are created.
After this pass, <code>get_port</code> ops should only exist at the same scope of
container instantiations.</p><p>The user may provide options for <code>readSuffix</code> and <code>writeSuffix</code>, respectively,
which is to be used to generate the name of the ports that are tunneled
through the hierarchy, with respect to how the port was requested to be accessed.
Suffixes must be provided in cases where a port is tunneled for both read and
write accesses, and the suffixes must be different (in this case, the suffixes
will be appended to the target port name, and thus de-alias the resulting ports).</p><h4 id=options-37>Options&nbsp;<a class=headline-hash href=#options-37>¶</a></h4><pre tabindex=0><code>-read-suffix  : Suffix to be used for the port when a port is tunneled for read access
-write-suffix : Suffix to be used for the port when a port is tunneled for write access
</code></pre><h2 id=llhd-dialect-passes>LLHD Dialect Passes&nbsp;<a class=headline-hash href=#llhd-dialect-passes>¶</a></h2><h3 id=-llhd-early-code-motion><code>-llhd-early-code-motion</code>&nbsp;<a class=headline-hash href=#-llhd-early-code-motion>¶</a></h3><p><em>Move side-effect-free instructions and llhd.prb up in the CFG</em></p><p>Moves side-effect-free instructions as far up in the CFG as possible. That
means to the earliest block where all operands are defined. Special care has
to be given to the <code>llhd.prb</code> instruction (which is the only side-effect
instruction moved by this pass) as it must stay in the same temporal region,
because otherwise it might sample an older or newer state of the signal.
This pass is designed as a preparatory pass for the Temporal Code Motion
pass to be able to move the <code>llhd.drv</code> operations in a single TR exiting
block without having to move operations defining the operands used by the
<code>llhd.drv</code>. It also enables total control flow elimination as the <code>llhd.prb</code>
instructions would not be moved by other canonicalization passes.</p><h3 id=-llhd-function-elimination><code>-llhd-function-elimination</code>&nbsp;<a class=headline-hash href=#-llhd-function-elimination>¶</a></h3><p><em>Deletes all functions.</em></p><p>Deletes all functions in the module. In case there is still a function
call in an entity or process, it fails.
This pass is intended as a post-inlining pass to check if all functions
could be successfully inlined and remove the inlined functions. This
is necessary because Structural LLHD does not allow functions. Fails in
the case that there is still a function call left in a <code>llhd.proc</code> or
<code>llhd.entity</code>.</p><h3 id=-llhd-memory-to-block-argument><code>-llhd-memory-to-block-argument</code>&nbsp;<a class=headline-hash href=#-llhd-memory-to-block-argument>¶</a></h3><p><em>Promote memory to block arguments.</em></p><p>Promotes memory locations allocated with <code>llhd.var</code> to block arguments. This
enables other optimizations and is required to be able to lower behavioral
LLHD to structural LLHD. This is because there are no memory model and
control flow in structural LLHD. After executing this pass, the
&ldquo;-llhd-block-argument-to-mux&rdquo; pass can be used to convert the block
arguments to multiplexers to enable more control-flow elimination.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llhd<span class=p>.</span>proc <span class=nf>@check_simple</span><span class=p>(</span><span class=nv>%condsig</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c5</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>5</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%cond</span> <span class=p>=</span> llhd<span class=p>.</span>prb <span class=nv>%condsig</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%ptr</span> <span class=p>=</span> llhd<span class=p>.</span>var <span class=nv>%c5</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  cond_br <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2
</span></span></span><span class=line><span class=cl><span class=nl>^bb1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c6</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>6</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  llhd<span class=p>.</span>store <span class=nv>%ptr</span><span class=p>,</span> <span class=nv>%c6</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  br <span class=nl>^bb2
</span></span></span><span class=line><span class=cl><span class=nl>^bb2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nv>%ld</span> <span class=p>=</span> llhd<span class=p>.</span>load <span class=nv>%ptr</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%res</span> <span class=p>=</span> llhd<span class=p>.</span>not <span class=nv>%ld</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  llhd<span class=p>.</span>halt
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>is transformed to</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llhd<span class=p>.</span>proc <span class=nf>@check_simple</span><span class=p>(</span><span class=nv>%condsig</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c5</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>5</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%cond</span> <span class=p>=</span> llhd<span class=p>.</span>prb <span class=nv>%condsig</span> <span class=p>:</span> <span class=p>!</span>llhd<span class=p>.</span>sig<span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  cond_br <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2</span><span class=p>(</span><span class=nv>%c5</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nl>^bb1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c6</span> <span class=p>=</span> llhd<span class=p>.</span>const <span class=m>6</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  br <span class=nl>^bb2</span><span class=p>(</span><span class=nv>%c6</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nl>^bb2</span><span class=p>(</span><span class=nv>%arg</span> <span class=p>:</span> <span class=k>i32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nv>%res</span> <span class=p>=</span> llhd<span class=p>.</span>not <span class=nv>%arg</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  llhd<span class=p>.</span>halt
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=-llhd-process-lowering><code>-llhd-process-lowering</code>&nbsp;<a class=headline-hash href=#-llhd-process-lowering>¶</a></h3><p><em>Lowers LLHD Processes to Entities.</em></p><p>TODO</p><h2 id=msft-dialect-passes>MSFT Dialect Passes&nbsp;<a class=headline-hash href=#msft-dialect-passes>¶</a></h2><h3 id=-msft-export-tcl><code>-msft-export-tcl</code>&nbsp;<a class=headline-hash href=#-msft-export-tcl>¶</a></h3><p><em>Create tcl ops</em></p><h4 id=options-38>Options&nbsp;<a class=headline-hash href=#options-38>¶</a></h4><pre tabindex=0><code>-tops     : List of top modules to export Tcl for
-tcl-file : File to output Tcl into
</code></pre><h3 id=-msft-lower-constructs><code>-msft-lower-constructs</code>&nbsp;<a class=headline-hash href=#-msft-lower-constructs>¶</a></h3><p><em>Lower high-level constructs</em></p><h3 id=-msft-lower-instances><code>-msft-lower-instances</code>&nbsp;<a class=headline-hash href=#-msft-lower-instances>¶</a></h3><p><em>Lower dynamic instances</em></p><h2 id=om-dialect-passes>OM Dialect Passes&nbsp;<a class=headline-hash href=#om-dialect-passes>¶</a></h2><h3 id=-om-freeze-paths><code>-om-freeze-paths</code>&nbsp;<a class=headline-hash href=#-om-freeze-paths>¶</a></h3><p><em>Hard code all path information</em></p><p>Replaces paths to hardware with hard-coded string paths. This pass should
only run once the hierarchy will no longer change, and the final names for
objects have been decided.</p><h3 id=-om-link-modules><code>-om-link-modules</code>&nbsp;<a class=headline-hash href=#-om-link-modules>¶</a></h3><p><em>Link separated OM modules into a single module</em></p><p>Flatten nested modules and resolve external classes.</p><h2 id=pipeline-dialect-passes>Pipeline Dialect Passes&nbsp;<a class=headline-hash href=#pipeline-dialect-passes>¶</a></h2><h3 id=-pipeline-explicit-regs><code>-pipeline-explicit-regs</code>&nbsp;<a class=headline-hash href=#-pipeline-explicit-regs>¶</a></h3><p><em>Makes stage registers explicit.</em></p><p>Makes all stage-crossing def-use chains into explicit registers.</p><h3 id=-pipeline-schedule-linear><code>-pipeline-schedule-linear</code>&nbsp;<a class=headline-hash href=#-pipeline-schedule-linear>¶</a></h3><p><em>Schedules <code>pipeline.unscheduled</code> operations.</em></p><p>Schedules <code>pipeline.unscheduled</code> operations based on operator latencies.</p><h2 id=seq-dialect-passes>Seq Dialect Passes&nbsp;<a class=headline-hash href=#seq-dialect-passes>¶</a></h2><h3 id=-externalize-clock-gate><code>-externalize-clock-gate</code>&nbsp;<a class=headline-hash href=#-externalize-clock-gate>¶</a></h3><p><em>Convert seq.clock_gate ops into hw.module.extern instances</em></p><h4 id=options-39>Options&nbsp;<a class=headline-hash href=#options-39>¶</a></h4><pre tabindex=0><code>-name          : Name of the external clock gate module
-input         : Name of the clock input
-output        : Name of the gated clock output
-enable        : Name of the enable input
-test-enable   : Name of the optional test enable input
-instance-name : Name of the generated instances
</code></pre><h4 id=statistics-26>Statistics&nbsp;<a class=headline-hash href=#statistics-26>¶</a></h4><pre tabindex=0><code>num-clock-gates-converted : Number of clock gates converted to external module instances
</code></pre><h3 id=-hw-memory-sim><code>-hw-memory-sim</code>&nbsp;<a class=headline-hash href=#-hw-memory-sim>¶</a></h3><p><em>Implement FIRRTMMem memories nodes with simulation model</em></p><p>This pass replaces generated module nodes of type FIRRTLMem with a model
suitable for simulation.</p><h4 id=options-40>Options&nbsp;<a class=headline-hash href=#options-40>¶</a></h4><pre tabindex=0><code>-disable-mem-randomization                                : Disable emission of memory randomization code
-disable-reg-randomization                                : Disable emission of register randomization code
-repl-seq-mem                                             : Prepare seq mems for macro replacement
-read-enable-mode                                         : specify the behaviour of the read enable signal
-add-mux-pragmas                                          : Add mux pragmas to memory reads
-add-vivado-ram-address-conflict-synthesis-bug-workaround : Add a vivado attribute to specify a ram style of an array register
</code></pre><h3 id=-lower-seq-fifo><code>-lower-seq-fifo</code>&nbsp;<a class=headline-hash href=#-lower-seq-fifo>¶</a></h3><p><em>Lower seq.fifo ops</em></p><h3 id=-lower-seq-hlmem><code>-lower-seq-hlmem</code>&nbsp;<a class=headline-hash href=#-lower-seq-hlmem>¶</a></h3><p><em>Lowers seq.hlmem operations.</em></p><h3 id=-lower-seq-shiftreg><code>-lower-seq-shiftreg</code>&nbsp;<a class=headline-hash href=#-lower-seq-shiftreg>¶</a></h3><p><em>Lower seq.shiftreg ops</em></p><p>Default pass for lowering shift register operations. This will lower
into a chain of <code>seq.compreg.ce</code> operations.
Note that this is <em>not</em> guaranteed to be a performant implementation,
but instead a default, fallback lowering path which is guaranteed to
provide a semantically valid path to verilog emissions.
Users are expected to provide a custom lowering pass to maps <code>seq.shiftreg</code>
operations to target-specific primitives.</p><h2 id=ssp-dialect-passes>SSP Dialect Passes&nbsp;<a class=headline-hash href=#ssp-dialect-passes>¶</a></h2><h3 id=-ssp-print><code>-ssp-print</code>&nbsp;<a class=headline-hash href=#-ssp-print>¶</a></h3><p><em>Prints all SSP instances as DOT graphs.</em></p><h3 id=-ssp-roundtrip><code>-ssp-roundtrip</code>&nbsp;<a class=headline-hash href=#-ssp-roundtrip>¶</a></h3><p><em>Roundtrips all SSP instances via the scheduling infrastructure</em></p><h4 id=options-41>Options&nbsp;<a class=headline-hash href=#options-41>¶</a></h4><pre tabindex=0><code>-check  : Check the problem&#39;s input constraints.
-verify : Verify the problem&#39;s solution constraints.
</code></pre><h3 id=-ssp-schedule><code>-ssp-schedule</code>&nbsp;<a class=headline-hash href=#-ssp-schedule>¶</a></h3><p><em>Schedules all SSP instances.</em></p><h4 id=options-42>Options&nbsp;<a class=headline-hash href=#options-42>¶</a></h4><pre tabindex=0><code>-scheduler : Scheduling algorithm to use.
-options   : Scheduler-specific options.
</code></pre><h2 id=sv-dialect-passes>SV Dialect Passes&nbsp;<a class=headline-hash href=#sv-dialect-passes>¶</a></h2><h3 id=-hw-cleanup><code>-hw-cleanup</code>&nbsp;<a class=headline-hash href=#-hw-cleanup>¶</a></h3><p><em>Cleanup transformations for operations in hw.module bodies</em></p><p>This pass merges sv.alwaysff operations with the same condition, sv.ifdef
nodes with the same condition, and perform other cleanups for the IR.
This is a good thing to run early in the HW/SV pass pipeline to expose
opportunities for other simpler passes (like canonicalize).</p><h4 id=options-43>Options&nbsp;<a class=headline-hash href=#options-43>¶</a></h4><pre tabindex=0><code>-merge-always-blocks : Allow always and always_ff blocks to be merged
</code></pre><h3 id=-hw-eliminate-inout-ports><code>-hw-eliminate-inout-ports</code>&nbsp;<a class=headline-hash href=#-hw-eliminate-inout-ports>¶</a></h3><p><em>Raises usages of inout ports into explicit input and output ports</em></p><p>This pass raises usages of inout ports into explicit in- and output ports.
This is done by analyzing the usage of the inout ports and creating new
input and output ports at the using module, and subsequently moving the
inout read- and writes to the instantiation site.</p><h4 id=options-44>Options&nbsp;<a class=headline-hash href=#options-44>¶</a></h4><pre tabindex=0><code>-read-suffix  : Suffix to be used for the port when the inout port has readers
-write-suffix : Suffix to be used for the port when the inout port has writers
</code></pre><h3 id=-hw-export-module-hierarchy><code>-hw-export-module-hierarchy</code>&nbsp;<a class=headline-hash href=#-hw-export-module-hierarchy>¶</a></h3><p><em>Export module and instance hierarchy information</em></p><p>This pass exports the module and instance hierarchy tree for each module
with the firrtl.moduleHierarchyFile attribute. These are lowered to
sv.verbatim ops with the output_file attribute.</p><h3 id=-hw-generator-callout><code>-hw-generator-callout</code>&nbsp;<a class=headline-hash href=#-hw-generator-callout>¶</a></h3><p><em>Lower Generator Schema to external module</em></p><p>This pass calls an external program for all the hw.module.generated nodes,
following the description in the hw.generator.schema node.</p><h4 id=options-45>Options&nbsp;<a class=headline-hash href=#options-45>¶</a></h4><pre tabindex=0><code>-schema-name                    : Name of the schema to process
-generator-executable           : Generator program executable with optional full path
-generator-executable-arguments : Generator program arguments separated by ;
</code></pre><h3 id=-hw-legalize-modules><code>-hw-legalize-modules</code>&nbsp;<a class=headline-hash href=#-hw-legalize-modules>¶</a></h3><p><em>Eliminate features marked unsupported in LoweringOptions</em></p><p>This pass lowers away features in the SV/Comb/HW dialects that are
unsupported by some tools, e.g. multidimensional arrays. This pass is
run relatively late in the pipeline in preparation for emission. Any
passes run after this must be aware they cannot introduce new invalid
constructs.</p><h3 id=-hw-stub-external-modules><code>-hw-stub-external-modules</code>&nbsp;<a class=headline-hash href=#-hw-stub-external-modules>¶</a></h3><p><em>Transform external hw modules to empty hw modules</em></p><p>This pass creates empty module bodies for external modules. This is
useful for linting to eliminate missing file errors.</p><h3 id=-prettify-verilog><code>-prettify-verilog</code>&nbsp;<a class=headline-hash href=#-prettify-verilog>¶</a></h3><p><em>Transformations to improve quality of ExportVerilog output</em></p><p>This pass contains elective transformations that improve the quality of
SystemVerilog generated by the ExportVerilog library. This pass is not
compulsory: things that are required for ExportVerilog to be correct
should be included as part of the ExportVerilog pass itself to make sure
it is self contained.</p><h3 id=-sv-extract-test-code><code>-sv-extract-test-code</code>&nbsp;<a class=headline-hash href=#-sv-extract-test-code>¶</a></h3><p><em>Extract simulation only constructs to modules and bind</em></p><p>This pass extracts cover, assume, assert operations to a module, along with
any ops feeding them only, to modules which are instantiated with a bind
statement.</p><h4 id=options-46>Options&nbsp;<a class=headline-hash href=#options-46>¶</a></h4><pre tabindex=0><code>-disable-instance-extraction : Disable extracting instances only that feed test code
-disable-register-extraction : Disable extracting registers only that feed test code
-disable-module-inlining     : Disable inlining modules that only feed test code
</code></pre><h4 id=statistics-27>Statistics&nbsp;<a class=headline-hash href=#statistics-27>¶</a></h4><pre tabindex=0><code>num-ops-extracted : Number of ops extracted
num-ops-erased    : Number of ops erased
</code></pre><h3 id=-sv-trace-iverilog><code>-sv-trace-iverilog</code>&nbsp;<a class=headline-hash href=#-sv-trace-iverilog>¶</a></h3><p><em>Add tracing to an iverilog simulated module</em></p><p>This pass adds the necessary instrumentation to a HWModule to trigger
tracing in an iverilog simulation.</p><h4 id=options-47>Options&nbsp;<a class=headline-hash href=#options-47>¶</a></h4><pre tabindex=0><code>-top-only : If true, will only add tracing to the top-level module.
-module   : Module to trace. If not provided, will trace all modules
-dir-name : Directory to emit into
</code></pre><h2 id=systemc-dialect-passes>SystemC Dialect Passes&nbsp;<a class=headline-hash href=#systemc-dialect-passes>¶</a></h2><h3 id=-systemc-lower-instance-interop><code>-systemc-lower-instance-interop</code>&nbsp;<a class=headline-hash href=#-systemc-lower-instance-interop>¶</a></h3><p><em>Lower all SystemC instance interop operations.</em></p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/HLS/ title="HLS in CIRCT"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - HLS in CIRCT</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/PyCDE/ title="Python CIRCT Design Entry (PyCDE)">Next - Python CIRCT Design Entry (PyCDE) <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li class=active><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>