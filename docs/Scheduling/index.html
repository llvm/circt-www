<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Static scheduling infrastructure - CIRCT</title><meta name=description content="Circuit IR Compilers and Tools"><meta name=generator content="Hugo 0.101.0"><link href=https://circt.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://circt.llvm.org/docs/Scheduling/><link rel=stylesheet href=https://circt.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://circt.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://circt.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://circt.llvm.org//circt-logo.svg width=40px align=absmiddle>
CIRCT</div></h1><p class=description>Circuit IR Compilers and Tools</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/Projects-that-want-to-become-official-LLVM-Projects/circt/40>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li class=parent><a href=https://github.com/llvm/circt/tree/main/>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/circt/tree/main/>GitHub</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>Static scheduling infrastructure</h1><p>Scheduling is a common concern in hardware design, for example in high-level
synthesis flows targeting an FSM+Datapath execution model (&ldquo;static HLS&rdquo;). This
document gives an overview of, and provides rationale for, the infrastructure in
the <code>circt::scheduling</code> namespace. At its core, it defines an <strong>extensible
problem model</strong> that acts as an interface between <strong>clients</strong> (i.e. passes that
have a need to schedule a graph-like IR) and reusable <strong>algorithm</strong>
implementations.</p><p>This infrastructure aims to provide:</p><ul><li>a library of ready-to-use problem definitions and schedulers for clients to
hook into.</li><li>an API to make algorithm implementations comparable and reusable.</li><li>a mechanism to extend problem definitions to model additional concerns and
constraints.</li></ul><h2 id=getting-started>Getting started&nbsp;<a class=headline-hash href=#getting-started>¶</a></h2><p>Let&rsquo;s walk through a simple example. Assume we want to <em>schedule</em> the
computation in the entry block of a function such as <code>@foo(...)</code> in the listing
below. This means we want to assign integer <em>start times</em> to each of the
<em>operations</em> in this untimed IR.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%a1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%a2</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%a3</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%a4</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%a1</span><span class=p>,</span> <span class=nv>%a2</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%0</span><span class=p>,</span> <span class=nv>%a3</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%2</span><span class=p>:</span><span class=nl>3 =</span> <span class=s>&#34;more.results&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nv>%3</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%a4</span><span class=p>,</span> <span class=nv>%2#1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%4</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%2#0</span><span class=p>,</span> <span class=nv>%2#2</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%5</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%3</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%6</span> <span class=p>=</span> <span class=s>&#34;more.operands&#34;</span><span class=p>(</span><span class=nv>%3</span><span class=p>,</span> <span class=nv>%4</span><span class=p>,</span> <span class=nv>%5</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=kt>return</span> <span class=nv>%6</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Our only constraint is that an operation can start <em>after</em> its operands have
been computed. The operations in our source IR are unaware of time, so we need
to associate them with a suitable <em>operator type</em>. Operator types are an
abstraction of the target architecture onto which we want to schedule the source
IR. Here, the only <em>property</em> we need to model is their <em>latency</em>. Let&rsquo;s assume
that additions take 1 time step, the operations in the dummy <code>more.</code> dialect
take 3 time steps. As the return operation just passes control back to the
caller, we assume a latency of 0 time steps for it.</p><h3 id=boilerplate>Boilerplate&nbsp;<a class=headline-hash href=#boilerplate>¶</a></h3><p>The scheduling infrastructure currently has three toplevel header files.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;circt/Scheduling/Problems.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;circt/Scheduling/Algorithms.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;circt/Scheduling/Utilities.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>circt</span><span class=o>::</span><span class=n>scheduling</span><span class=p>;</span>
</span></span></code></pre></div><h3 id=constructing-a-problem-instance>Constructing a problem instance&nbsp;<a class=headline-hash href=#constructing-a-problem-instance>¶</a></h3><p>Our stated goal requires solving an acyclic scheduling problem without resource
constraints, represented by the <code>Problem</code> class in the scheduling
infrastructure. We need to construct an <em>instance</em> of the problem, which serves
as a container for the problem <em>components</em> as well as their properties. The
MLIR operation passed as an argument to the <code>get(...)</code> method is used to emit
diagnostics.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>auto</span> <span class=n>prob</span> <span class=o>=</span> <span class=n>Problem</span><span class=o>::</span><span class=n>get</span><span class=p>(</span><span class=n>func</span><span class=p>);</span>
</span></span></code></pre></div><p>Then, we set up the operator types with the latencies as discussed in the
introduction. Operator types are identified by string handles.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>auto</span> <span class=n>retOpr</span> <span class=o>=</span> <span class=n>prob</span><span class=p>.</span><span class=n>getOrInsertOperatorType</span><span class=p>(</span><span class=s>&#34;return&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>prob</span><span class=p>.</span><span class=n>setLatency</span><span class=p>(</span><span class=n>retOpr</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>addOpr</span> <span class=o>=</span> <span class=n>prob</span><span class=p>.</span><span class=n>getOrInsertOperatorType</span><span class=p>(</span><span class=s>&#34;add&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>prob</span><span class=p>.</span><span class=n>setLatency</span><span class=p>(</span><span class=n>addOpr</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=n>mcOpr</span> <span class=o>=</span> <span class=n>prob</span><span class=p>.</span><span class=n>getOrInsertOperatorType</span><span class=p>(</span><span class=s>&#34;multicycle&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>prob</span><span class=p>.</span><span class=n>setLatency</span><span class=p>(</span><span class=n>mcOpr</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span>
</span></span></code></pre></div><p>Next, we register all operations that we want to consider in the problem
instance, and link them to one of the operator types.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>auto</span> <span class=o>&amp;</span><span class=n>block</span> <span class=o>=</span> <span class=n>func</span><span class=p>.</span><span class=n>getBlocks</span><span class=p>().</span><span class=n>front</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>op</span> <span class=p>:</span> <span class=n>block</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>prob</span><span class=p>.</span><span class=n>insertOperation</span><span class=p>(</span><span class=o>&amp;</span><span class=n>op</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>isa</span><span class=o>&lt;</span><span class=n>func</span><span class=o>::</span><span class=n>ReturnOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>op</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>prob</span><span class=p>.</span><span class=n>setLinkedOperatorType</span><span class=p>(</span><span class=o>&amp;</span><span class=n>op</span><span class=p>,</span> <span class=n>retOpr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>isa</span><span class=o>&lt;</span><span class=n>arith</span><span class=o>::</span><span class=n>AddIOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>op</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>prob</span><span class=p>.</span><span class=n>setLinkedOperatorType</span><span class=p>(</span><span class=o>&amp;</span><span class=n>op</span><span class=p>,</span> <span class=n>addOpr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=n>prob</span><span class=p>.</span><span class=n>setLinkedOperatorType</span><span class=p>(</span><span class=o>&amp;</span><span class=n>op</span><span class=p>,</span> <span class=n>mcOpr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Note that we do not have to tell the instance about the <em>dependences</em> between
the operations in this simple example because the problem model automatically
includes the SSA def-use-edges maintained by MLIR. However, we often have to
consider additional dependences that are not represented by value flow, such as
memory dependences. For these situations, so-called
<a href=#components>auxiliary</a>
dependences between operations are inserted explicitly into the problem:
<code>prob.insertDependence(srcOp, destOp)</code>.</p><h3 id=scheduling>Scheduling&nbsp;<a class=headline-hash href=#scheduling>¶</a></h3><p>Before we attempt to schedule, we invoke the <code>check()</code> method, which ensures
that the constructed instance is complete and valid. For example, the check
would capture if we had forgot to set an operator type&rsquo;s latency. We dump the
instance to visualize the dependence graph.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>auto</span> <span class=n>checkRes</span> <span class=o>=</span> <span class=n>prob</span><span class=p>.</span><span class=n>check</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>assert</span><span class=p>(</span><span class=n>succeeded</span><span class=p>(</span><span class=n>checkRes</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>dumpAsDOT</span><span class=p>(</span><span class=n>prob</span><span class=p>,</span> <span class=s>&#34;sched-problem.dot&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p><img src=https://circt.llvm.org/includes/img/sched-instance.svg alt="Dump of example instance"></p><p>We use a simple list scheduler, available via the <code>Algorithms.h</code> header, to
compute a solution for the instance.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>auto</span> <span class=n>schedRes</span> <span class=o>=</span> <span class=n>scheduleASAP</span><span class=p>(</span><span class=n>prob</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>assert</span><span class=p>(</span><span class=n>succeeded</span><span class=p>(</span><span class=n>schedRes</span><span class=p>));</span>
</span></span></code></pre></div><h3 id=working-with-the-solution>Working with the solution&nbsp;<a class=headline-hash href=#working-with-the-solution>¶</a></h3><p>The solution is now stored in the instance, and we invoke the problem&rsquo;s
<code>verify()</code> method to ensure that the computed start times adhere to the
precedence constraint we stated earlier, i.e. operations start after their
operands have computed their results. We can also convince ourselves of that by
dumping the instance and inspecting the solution.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>auto</span> <span class=n>verifRes</span> <span class=o>=</span> <span class=n>prob</span><span class=p>.</span><span class=n>verify</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>assert</span><span class=p>(</span><span class=n>succeeded</span><span class=p>(</span><span class=n>verifRes</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>dumpAsDOT</span><span class=p>(</span><span class=n>prob</span><span class=p>,</span> <span class=s>&#34;sched-solution.dot&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p><img src=https://circt.llvm.org/includes/img/sched-solution.svg alt="Dump of example instance, including solution"></p><p>To inspect the solution programmatically, we can query the instance in the
following way. Note that by convention, all getters in the problem classes
return <code>Optional&lt;T></code> values, but as we have already verified that the start
times for registered operations are set, we can directly dereference the values.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>op</span> <span class=p>:</span> <span class=n>prob</span><span class=p>.</span><span class=n>getOperations</span><span class=p>())</span>
</span></span><span class=line><span class=cl>  <span class=n>llvm</span><span class=o>::</span><span class=n>dbgs</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>prob</span><span class=p>.</span><span class=n>getStartTime</span><span class=p>(</span><span class=o>&amp;</span><span class=n>op</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span></code></pre></div><p>And that&rsquo;s it! For a more practical example, have a look at the
<a href=https://github.com/llvm/circt/blob/main/lib/Conversion/AffineToPipeline/AffineToPipeline.cpp><code>AffineToPipeline</code></a>
pass.</p><h2 id=extensible-problem-model>Extensible problem model&nbsp;<a class=headline-hash href=#extensible-problem-model>¶</a></h2><h3 id=theory-and-terminology>Theory and terminology&nbsp;<a class=headline-hash href=#theory-and-terminology>¶</a></h3><p>Scheduling problems come in many flavors and variants in the context of hardware
design. In order to make the scheduling infrastructure as modular and flexible
as CIRCT itself, it is build on the following idea of an <em>extensible problem
model</em>:</p><p>An <em>instance</em> is comprised of <em>components</em> called <em>operations</em>, <em>dependences</em>
and <em>operator types</em>. Operations and dependences form a graph structure and
correspond to the source IR to be scheduled. Operator types encode the
characteristics of the target IR. The components as well as the instance can be
annotated with <em>properties</em>. Properties are either <em>input</em> or <em>solution</em>
properties, based on whether they are supplied by the client, or computed by the
algorithm. The values of these properties are subject to the <em>input constraints</em>
and <em>solution constraints</em>, which are a first-class concern in the model and are
intended to be strictly enforced before respectively after scheduling.</p><p>Concrete problem definitions derived from this model share the same
representation of the components, but differ in their sets of properties (and
potentially distinction of input and solution properties) and input and solution
constraints. Hence, we tie together properties and constraints to model a
specific scheduling problem. Extending one (or more!) parent problems means
inheriting or adding properties, and redefining the constraints (as these don&rsquo;t
always compose automatically).</p><p>A key benefit of this approach is that these problem definitions provide a
reliable contract between the clients and algorithms, making it clear which
information needs to be provided, and what kind of solution is to be expected.
Clients can therefore choose a problem definition that fits their needs, and
algorithms can <em>opt-in</em> to accepting a specific subset of problems, which they
can solve efficiently. Extensibility is ensured because new problem definitions
can be added to the infrastructure (or inside a specific lowering flow, or even
out-of-tree) without adapting any existing users.</p><h3 id=implementation>Implementation&nbsp;<a class=headline-hash href=#implementation>¶</a></h3><p>See
<a href=https://github.com/llvm/circt/blob/main/include/circt/Scheduling/Problems.h>Problems.h</a> /
<a href=https://github.com/llvm/circt/blob/main/lib/Scheduling/Problems.cpp>Problems.cpp</a>.</p><h4 id=problem-definitions>Problem definitions&nbsp;<a class=headline-hash href=#problem-definitions>¶</a></h4><p>The <code>Problem</code> class is currently the base of the problem hierarchy. Several
extended problems are
<a href=#available-problem-definitions>currently defined</a> via
virtual multiple inheritance. Upon construction, a <code>containingOp</code> is passed to
instances. This MLIR operation is currently only used to emit diagnostics, and
has no semantic meaning beyond that.</p><h4 id=components>Components&nbsp;<a class=headline-hash href=#components>¶</a></h4><p>The infrastructure uses the following representation of the problem components.</p><p>Operations are just <code>mlir::Operation *</code>s.</p><p>We distinguish two kinds of dependences, <em>def-use</em> and <em>auxiliary</em>. Def-use
dependences are part of the SSA graph maintained by MLIR, and can distinguish
specific result and operand numbers. As we expect any relevant graph-like input
IR to use this MLIR facility, instances automatically consider these edges
between registered operations. Auxiliary dependences, in contrast, only specify
a source and destination operation, and have to be explicitly added to the
instance by the client, e.g. for control or memory dependences. The
<code>detail::Dependence</code> class abstracts the differences between both kinds, in
order to offer a uniform API to iterate over dependences and query their
properties.</p><p>Lastly, operator types are identified by <code>mlir::StringAttr</code>s, in order to give
clients maximum flexibility in modeling their operator library. This may change
in the future, when a CIRCT-wide concept to model physical properties of
hardware emerges.</p><h4 id=properties>Properties&nbsp;<a class=headline-hash href=#properties>¶</a></h4><p>Properties can involve arbitrary data types, as long as these can be stored in
maps. Problem classes offer public getter and setter methods to access a given
components properties. Getters return optional values, in order to indicate if a
property is unset. For example, the signature of the method the queries the
computed start time is <code>Optional&lt;unsigned> getStartTime(Operation *op)</code>.</p><h4 id=constraints>Constraints&nbsp;<a class=headline-hash href=#constraints>¶</a></h4><p>Clients call the virtual <code>Problem::check()</code> method to test any input
constraints, and <code>Problem::verify()</code> to test the solution constraints. Problem
classes are expected to override them as needed. There are no further
restrictions of how these methods are implemented, but it is recommended to
introduce helper methods that test a specific aspect and can be reused in
extended problems. In addition, it makes sense to check/verify the properties in
an order that avoids redundant tests for the presence of a particular property
as well as redundant iteration over the problem components.</p><h2 id=available-problem-definitions>Available problem definitions&nbsp;<a class=headline-hash href=#available-problem-definitions>¶</a></h2><p><em>See the linked Doxygen docs for more details.</em></p><ul><li><a href=https://circt.llvm.org/doxygen/classcirct_1_1scheduling_1_1Problem.html>Problem</a>:
A basic, acyclic problem at the root of the problem hierarchy. Operations are
linked to operator types, which have integer latencies. The solution comprises
integer start times adhering to the precedence constraints implied by the
dependences.</li><li><a href=https://circt.llvm.org/doxygen/classcirct_1_1scheduling_1_1CyclicProblem.html>CyclicProblem</a>:
Cyclic extension of <code>Problem</code>. Its solution solution can be used to construct
a pipelined datapath with a fixed, integer initiation interval, in which the
execution of multiple iterations/samples/etc. may overlap. Operator types are
assumed to be fully pipelined.</li><li><a href=https://circt.llvm.org/doxygen/classcirct_1_1scheduling_1_1SharedOperatorsProblem.html>SharedOperatorsProblem</a>:
A resource-constrained scheduling problem that corresponds to multiplexing
multiple operations onto a pre-allocated number of fully pipelined operator
instances.</li><li><a href=https://circt.llvm.org/doxygen/classcirct_1_1scheduling_1_1ModuloProblem.html>ModuloProblem</a>:
Models an HLS classic: Pipeline scheduling with limited resources.</li><li><a href=https://circt.llvm.org/doxygen/classcirct_1_1scheduling_1_1ChainingProblem.html>ChainingProblem</a>:
Extends <code>Problem</code> to consider the accumulation of physical propagation delays
on combinational paths along SSA dependences.</li><li><a href=https://circt.llvm.org/doxygen/classcirct_1_1scheduling_1_1ChainingCyclicProblem.html>ChainingCyclicProblem</a>:
Extends <code>ChainingProblem</code> and <code>CyclicProblem</code> to consider the accumulation
of physical propagation delays on combinational paths along SSA dependences
on a cyclic scheduling problem. Note that the problem does not model
propagation delays along inter-iteration dependences. These are commonly
represented as auxiliary dependences, which are already excluded in the
parent ChainingProblem. In addition, the ChainingCyclicProblem explicitly
prohibits the use of def-use dependences with a non-zero distance.</li></ul><p>NB: The classes listed above each model a <em>trait</em>-like aspect of scheduling.
These can be used as-is, but are also intended for mixing and matching, even
though we currently do not provide definitions for all possible combinations in
order not to pollute the infrastructure. For example, the <code>ChainingProblem</code> may
be of limited use standalone, but can serve as a parent class for a future
chaining-enabled modulo scheduling problem.</p><h2 id=available-schedulers>Available schedulers&nbsp;<a class=headline-hash href=#available-schedulers>¶</a></h2><ul><li>ASAP list scheduler
(
<a href=https://github.com/llvm/circt/blob/main/lib/Scheduling/ASAPScheduler.cpp><code>ASAPScheduler.cpp</code></a>):
Solves the basic <code>Problem</code> with a worklist algorithm. This is mostly a
problem-API demo from the viewpoint of an algorithm implementation.</li><li>Linear programming-based schedulers
(
<a href=https://github.com/llvm/circt/blob/main/lib/Scheduling/SimplexSchedulers.cpp><code>SimplexSchedulers.cpp</code></a>):
Solves <code>Problem</code>, <code>CyclicProblem</code> and <code>ChainingProblem</code> optimally, and
<code>SharedOperatorsProblem</code> / <code>ModuloProblem</code> with simple (not state-of-the-art!)
heuristics. This family of schedulers shares a tailored implementation of the
simplex algorithm, as proposed by de Dinechin. See the sources for more
details and literature references.</li><li>Integer linear programming-based scheduler
(
<a href=https://github.com/llvm/circt/blob/main/lib/Scheduling/LPSchedulers.cpp><code>LPSchedulers.cpp</code></a>):
Demo implementation for using an ILP solver via the OR-Tools integration.</li></ul><h2 id=utilities>Utilities&nbsp;<a class=headline-hash href=#utilities>¶</a></h2><p>See
<a href=https://github.com/llvm/circt/blob/main/include/circt/Scheduling/Utilities.h><code>Utilities.h</code></a>:</p><ul><li>Topological graph traversal</li><li>DFA to compute combinational path delays</li><li>DOT dump</li></ul><h2 id=adding-a-new-problem>Adding a new problem&nbsp;<a class=headline-hash href=#adding-a-new-problem>¶</a></h2><p><em>See e.g.
<a href=https://github.com/llvm/circt/pull/2233>#2233</a>, which added the
<code>ChainingProblem</code>.</em></p><ul><li>Decide where to add it. Guideline: If it is trait-like and similar to the
existing problem mentioned above, add it to <code>Problems.h</code>. If the model is
specific to your use-case, it is best to start out in locally in your
dialect/pass.</li><li>Declare the new problem class and inherit <em>virtually</em> from the relevant
superclasses (at least <code>Problem</code>).</li><li>Define additional properties (private), and the corresponding public
getters/setters. Getters return <code>Optional&lt;T></code> values, to indicate an unset
state.<ul><li>Note that dependence properties are somewhat expensive to store, making it
desirable that clients and algorithms expect and handle the unset state.
This should be clearly documented. Example: <code>distance</code> property in
<code>CyclicProblem</code>.</li></ul></li><li>Redefine the <code>getProperties(*)</code> methods to get dumping support. These should
consider any properties the new class adds, plus properties defined in the
superclass(es).</li><li>Redefine <code>check()</code> (input constraints) and <code>verify()</code> (solution constraints).
If possible, follow the
<a href=#constraints>design used in the existing problem classes</a>.</li></ul><h3 id=testing>Testing&nbsp;<a class=headline-hash href=#testing>¶</a></h3><p>Please extend the
<a href=https://circt.llvm.org/docs/Dialects/SSP/>SSP</a> dialect to
enable testing of the new problem definition.</p><ul><li>If the problem defines any new properties, add them to
<a href=https://github.com/llvm/circt/blob/main/include/circt/Dialect/SSP/SSPAttributes.td><code>SSPAttributes.td</code></a>.</li><li>Instantiate the
<a href=https://github.com/llvm/circt/blob/main/include/circt/Dialect/SSP/Utilities.h#L457-L459><code>Default&lt;ProblemT></code></a>
template for the new problem.</li><li>Handle the problem class in the
<a href=https://github.com/llvm/circt/blob/main/lib/Dialect/SSP/Transforms/Roundtrip.cpp><code>-ssp-roundtrip</code></a>
pass.</li><li>Write a couple of &ldquo;positive&rdquo; testcases, as well as at least one error test for
each input/solution constraint, as validated by <code>check()</code> / <code>verify()</code>. See
the
<a href=https://github.com/llvm/circt/tree/main/test/Scheduling>existing test cases</a>
for inspiration.</li></ul><h2 id=adding-a-new-scheduler>Adding a new scheduler&nbsp;<a class=headline-hash href=#adding-a-new-scheduler>¶</a></h2><p><em>See e.g.
<a href=https://github.com/llvm/circt/pull/2650>#2650</a>, which added a
scheduler for the <code>CyclicProblem</code>.</em></p><ul><li>Schedulers should opt-in to specific problems by providing entry points for
the problem subclasses they support. Example:<div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>LogicalResult</span> <span class=nf>awesomeScheduler</span><span class=p>(</span><span class=n>Problem</span> <span class=o>&amp;</span><span class=n>prob</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>LogicalResult</span> <span class=nf>awesomeScheduler</span><span class=p>(</span><span class=n>CyclicProblem</span> <span class=o>&amp;</span><span class=n>prob</span><span class=p>);</span>
</span></span></code></pre></div></li><li>Schedulers can expect that the input invariants were enforced by a
<code>check()</code>-call in the client, and must compute a solution that complies with
the solution constraints when the client calls the problem&rsquo;s <code>verify()</code>
method.</li><li>Schedulers can live anywhere. If a new algorithm is not entirely
dialect/pass-specific and supports problems defined in <code>Problems.h</code>, it should
offer entry points in <code>Algorithms.h</code>.</li><li>Objectives are not part of the problem signature. Therefore, if an algorithm
supports optimizing for different objectives, clients should be able to select
one via the entry point(s).</li></ul><h3 id=testing-1>Testing&nbsp;<a class=headline-hash href=#testing-1>¶</a></h3><ul><li>To enable testing, add the new scheduler to the
<a href=https://github.com/llvm/circt/blob/main/lib/Dialect/SSP/Transforms/Schedule.cpp><code>-ssp-schedule</code></a>
pass, and invoke it from the test cases for the supported problems
(
<a href=https://github.com/llvm/circt/blob/main/test/Scheduling/problems.mlir#L2-L4>example</a>).</li><li>If the algorithm may fail in certain situations (e.g., &ldquo;linear program is
infeasible&rdquo;), add suitable error tests as well.</li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://circt.llvm.org/docs/PyCDE/basics/ title="PyCDE Basics"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - PyCDE Basics</a>
<a class="nav nav-next" href=https://circt.llvm.org/docs/RationaleSymbols/ title="Symbol and Inner Symbol Rationale">Next - Symbol and Inner Symbol Rationale <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://circt.llvm.org/>Home</a></li><li><a href=https://circt.llvm.org/talks/>Talks and Related Publications</a></li><li><a href=https://circt.llvm.org/getting_started/>Getting Started</a></li><li class="parent has-sub-menu"><a href=https://circt.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://circt.llvm.org/docs/CommandGuide/>CommandGuide<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/CommandGuide/handshake-runner/>handshake-runner</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Charter/>CIRCT Charter</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESIAppID/></a></li><li><a href=https://circt.llvm.org/docs/Dialects/Arc/>'arc' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Calyx/>'calyx' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/CHIRRTL/>'chirrtl' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Comb/>'comb' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/>`comb` Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/DC/>'dc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/DC/RationaleDC/>DC Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Emit/>'emit' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/>Emission (Emit) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/ESI/>'esi' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/ESI/cosim/>ESI cosimulation model</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/types/>ESI data types and communication types</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/services/>ESI Global Services</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/software_api/>ESI Software APIs</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/notes/>Miscellaneous Notes</a></li><li><a href=https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/>The Elastic Silicon Interconnect dialect</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/>'firrtl' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/>FIRRTL Annotations</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/>FIRRTL Dialect Rationale</a></li><li><a href=https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/>Intrinsics</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/FSM/>'fsm' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/>FSM Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Handshake/>'handshake' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/>Handshake Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HW/>'hw' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HW/RationaleHW/>HW Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/HWArith/>'hwarith' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/>HW Arith Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Ibis/>'ibis' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/>`ibis` Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LLHD/>'llhd' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/>'loopschedule' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/>LoopSchedule Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/LTL/>'ltl' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Moore/>'moore' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/MSFT/>'msft' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/OM/>'om' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/OM/RationaleOM/>Object Model Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Pipeline/>'pipeline' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/>Pipeline Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Seq/>'seq' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/>Seq(uential) Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Sim/>'sim' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/>Simulation (Sim) Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SSP/>'ssp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/>SSP Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SV/>'sv' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SV/RationaleSV/>SV Dialect Rationale</a></li></ul></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/SystemC/>'systemc' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/>SystemC Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/Verif/>'verif' Dialect</a></li><li><a href=https://circt.llvm.org/docs/Dialects/Debug/>Debug Dialect</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/Dialects/Interop/>Interop Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/>Interoperability Dialect Rationale</a></li></ul></li><li><a href=https://circt.llvm.org/docs/Dialects/SMT/>SMT Dialect</a></li></ul></li><li><a href=https://circt.llvm.org/docs/ToolsWorkarounds/>EDA Tool Workarounds</a></li><li><a href=https://circt.llvm.org/docs/FormalVerification/>Formal Verification Tooling</a></li><li><a href=https://circt.llvm.org/docs/GettingStarted/>Getting Started with the CIRCT Project</a></li><li><a href=https://circt.llvm.org/docs/HLS/>HLS in CIRCT</a></li><li><a href=https://circt.llvm.org/docs/Passes/>Passes</a></li><li class=has-sub-menu><a href=https://circt.llvm.org/docs/PyCDE/>Python CIRCT Design Entry (PyCDE)<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://circt.llvm.org/docs/PyCDE/compiling/>Compiling CIRCT and PyCDE</a></li><li><a href=https://circt.llvm.org/docs/PyCDE/basics/>PyCDE Basics</a></li></ul></li><li class=active><a href=https://circt.llvm.org/docs/Scheduling/>Static scheduling infrastructure</a></li><li><a href=https://circt.llvm.org/docs/RationaleSymbols/>Symbol and Inner Symbol Rationale</a></li><li><a href=https://circt.llvm.org/docs/PythonBindings/>Using the Python Bindings</a></li><li><a href=https://circt.llvm.org/docs/VerilogGeneration/>Verilog and SystemVerilog Generation</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>