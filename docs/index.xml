<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code Documentation on CIRCT</title><link>https://circt.llvm.org/docs/</link><description>Recent content in Code Documentation on CIRCT</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Nov 2019 15:26:15 +0000</lastBuildDate><atom:link href="https://circt.llvm.org/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>CIRCT Charter</title><link>https://circt.llvm.org/docs/Charter/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Charter/</guid><description>Abstract Recent trends in computer architecture have resulted in two core problems. Firstly, how do we design complex, heterogeneous systems-on-chip mixing general purpose and specialized components? Secondly, how do we program them? We believe that design tools that represent and manipulate a wide variety of abstractions are central to solving these problems. This projects is focused on using LLVM/MLIR to express these abstractions and to build useable open-source flows based on those abstractions to solve the design problems of the next decade.</description></item><item><title>EDA Tool Workarounds</title><link>https://circt.llvm.org/docs/ToolsWorkarounds/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/ToolsWorkarounds/</guid><description>This documents various bugs found in EDA tools and their workarounds in circt. Each but will have a brief description, example code, and the mitigation added (with links to the commit when possible).
Automatic Variables Cause Latch Warnings Verilator issues a latch warning for fully-initialized, automatic variables. This precludes using locally scoped variables. https://github.com/verilator/verilator/issues/4022
Example module ALU( input clock, input [4:0] operation, input [63:0] inputs_1, inputs_0, inputs_2, input [16:0] immediate, output [63:0] output_0 ); reg [63:0] casez_tmp_1; always_comb begin automatic logic [63:0] lowHigh; casez (operation) 5&amp;#39;b00011: casez_tmp_1 = inputs_0 &amp;amp; inputs_1; 5&amp;#39;b00100: casez_tmp_1 = inputs_0 | inputs_1; 5&amp;#39;b00101: casez_tmp_1 = inputs_0 ^ inputs_1; 5&amp;#39;b01001: begin automatic logic [16:0] _aluOutput_T_22 = immediate &amp;gt;&amp;gt; {14&amp;#39;h0, inputs_2, inputs_1[0], inputs_0[0]}; casez_tmp_1 = {63&amp;#39;h0, _aluOutput_T_22[0]}; end default: casez_tmp_1 = inputs_0; endcase end endmodule Gives:</description></item><item><title>Formal Verification Tooling</title><link>https://circt.llvm.org/docs/FormalVerification/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/FormalVerification/</guid><description>Formally verifying hardware designs is a crucial step during the development process. Various techniques exist, such as logical equivalence checking, model checking, symbolic execution, etc. The preferred technique depends on the level of abstraction, the kind of properties to be verified, runtime limitations, etc. As a hardware compiler collection, CIRCT provides infrastructure to implement formal verification tooling and already comes with a few tools for common use-cases. This document provides an introduction to those tools and gives and overview over the underlying infrastructure for compiler engineers who want to use CIRCT to implement their custom verification tool.</description></item><item><title>Getting Started with the CIRCT Project</title><link>https://circt.llvm.org/docs/GettingStarted/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/GettingStarted/</guid><description>Overview Welcome to the CIRCT project!
&amp;ldquo;CIRCT&amp;rdquo; stands for &amp;ldquo;Circuit IR Compilers and Tools&amp;rdquo;. The CIRCT project is an (experimental!) effort looking to apply MLIR and the LLVM development methodology to the domain of hardware design tools.
Take a look at the following diagram, which gives a brief overview of the current dialects and how they interact:
Setting this up These commands can be used to setup CIRCT project:
Install Dependencies of LLVM/MLIR according to the instructions, including cmake and ninja.</description></item><item><title>HLS in CIRCT</title><link>https://circt.llvm.org/docs/HLS/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/HLS/</guid><description>// write a compelling introduction here
hlstool Flows Dynamically scheduled HLS (DHLS) Calyx hlstool hlstool is a tool for driving various CIRCT-based HLS flows. The tool works by defining pass pipelines that string together various MLIR and CIRCT passes to realize an HLS flow.
For new users to MLIR, it is important to recognize the different between such compiler driver tools, and the MLIR opt tools (optimization drivers), such as mlir-opt and circt-opt.</description></item><item><title>Passes</title><link>https://circt.llvm.org/docs/Passes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Passes/</guid><description>This document describes the available CIRCT passes and their contracts.
Conversion Passes -calyx-native -calyx-remove-groups-fsm -convert-affine-to-loopschedule -convert-comb-to-arith -convert-comb-to-smt -convert-fsm-to-sv -convert-hw-to-btor2 -convert-hw-to-llhd -convert-hw-to-llvm -convert-hw-to-smt -convert-hw-to-systemc -convert-llhd-to-llvm -convert-moore-to-core -convert-to-arcs -convert-verif-to-smt -export-chisel-interface -export-split-chisel-interface -export-split-verilog -export-verilog -handshake-remove-block-structure -hw-lower-instance-choices -legalize-anon-enums -lower-arc-to-llvm -lower-calyx-to-fsm -lower-calyx-to-hw -lower-cf-to-handshake -lower-dc-to-hw -lower-firrtl-to-hw -lower-handshake-to-dc -lower-handshake-to-hw -lower-hw-to-sv -lower-hwarith-to-hw -lower-loopschedule-to-calyx -lower-pipeline-to-hw -lower-scf-to-calyx -lower-seq-firmem -lower-seq-to-sv -lower-sim-to-sv -lower-verif-to-sv -materialize-calyx-to-fsm -prepare-for-emission -test-apply-lowering-options Arc Dialect Passes -arc-add-taps -arc-allocate-state -arc-canonicalizer -arc-dedup -arc-group-resets-and-enables -arc-infer-memories -arc-infer-state-properties -arc-inline -arc-inline-modules -arc-isolate-clocks -arc-latency-retiming -arc-legalize-state-update -arc-lower-arcs-to-funcs -arc-lower-clocks-to-funcs -arc-lower-lut -arc-lower-state -arc-lower-vectorizations -arc-make-tables -arc-mux-to-control-flow -arc-simplify-variadic-ops -arc-split-loops -arc-strip-sv Calyx Dialect Passes -calyx-clk-insertion -calyx-compile-control -calyx-gicm -calyx-go-insertion -calyx-remove-comb-groups Example -calyx-remove-groups -calyx-reset-insertion Comb Dialect Passes -lower-comb DC Dialect Passes -dc-dematerialize-forks-sinks -dc-materialize-forks-sinks ESI Dialect Passes -esi-appid-hier -esi-build-manifest -esi-clean-metadata -esi-connect-services -lower-esi-bundles -lower-esi-ports -lower-esi-to-hw -lower-esi-to-physical -lower-esi-types FIRRTL Dialect Passes -firrtl-add-seqmem-ports -firrtl-blackbox-reader -firrtl-check-comb-loops -firrtl-dedup -firrtl-drop-const -firrtl-drop-names -firrtl-emit-metadata -firrtl-emit-omir -firrtl-expand-whens -firrtl-extract-instances -firrtl-finalize-ir -firrtl-flatten-memory -firrtl-grand-central -firrtl-hoist-passthrough -firrtl-imconstprop -firrtl-imdeadcodeelim -firrtl-infer-resets -firrtl-infer-rw -firrtl-infer-widths -firrtl-inject-dut-hier -firrtl-inliner -firrtl-inner-symbol-dce -firrtl-layer-merge -firrtl-layer-sink -firrtl-lint -firrtl-lower-annotations -firrtl-lower-chirrtl -firrtl-lower-classes -firrtl-lower-intmodules -firrtl-lower-intrinsics -firrtl-lower-layers -firrtl-lower-matches -firrtl-lower-memory -firrtl-lower-open-aggs -firrtl-lower-signatures -firrtl-lower-types -firrtl-lower-xmr -firrtl-materialize-debug-info -firrtl-mem-to-reg-of-vec -firrtl-passive-wires -firrtl-prefix-modules -firrtl-print-field-source -firrtl-print-instance-graph -firrtl-print-nla-table -firrtl-probe-dce -firrtl-randomize-register-init -firrtl-register-optimizer -firrtl-remove-unused-ports -firrtl-resolve-paths -firrtl-resolve-traces -firrtl-sfc-compat -firrtl-specialize-option -firrtl-vb-to-bv -merge-connections -vectorization FSM Dialect Passes -fsm-print-graph Handshake Dialect Passes -handshake-add-ids -handshake-dematerialize-forks-sinks -handshake-insert-buffers -handshake-legalize-memrefs -handshake-lock-functions -handshake-lower-extmem-to-hw -handshake-materialize-forks-sinks -handshake-op-count -handshake-print-dot -handshake-remove-buffers HW Dialect Passes -hw-flatten-io -hw-print-instance-graph -hw-print-module-graph -hw-specialize -hw-verify-irn Ibis Dialect Passes -ibis-add-operator-library -ibis-argify-blocks -ibis-call-prep -ibis-clean-selfdrivers -ibis-containerize -ibis-convert-cf-to-handshake -ibis-convert-containers-to-hw -ibis-convert-handshake-to-dc -ibis-convert-methods-to-containers -ibis-inline-sblocks -ibis-lower-portrefs -ibis-prepare-scheduling -ibis-reblock -ibis-tunneling LLHD Dialect Passes -llhd-early-code-motion -llhd-function-elimination -llhd-memory-to-block-argument -llhd-process-lowering MSFT Dialect Passes -msft-export-tcl -msft-lower-constructs -msft-lower-instances OM Dialect Passes -om-freeze-paths -om-link-modules Pipeline Dialect Passes -pipeline-explicit-regs -pipeline-schedule-linear Seq Dialect Passes -externalize-clock-gate -hw-memory-sim -lower-seq-fifo -lower-seq-hlmem -lower-seq-shiftreg SSP Dialect Passes -ssp-print -ssp-roundtrip -ssp-schedule SV Dialect Passes -hw-cleanup -hw-eliminate-inout-ports -hw-export-module-hierarchy -hw-generator-callout -hw-legalize-modules -hw-stub-external-modules -prettify-verilog -sv-extract-test-code -sv-trace-iverilog SystemC Dialect Passes -systemc-lower-instance-interop Conversion Passes -calyx-native Callout to the Calyx native compiler and run a pass pipeline</description></item><item><title>Static scheduling infrastructure</title><link>https://circt.llvm.org/docs/Scheduling/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Scheduling/</guid><description>Scheduling is a common concern in hardware design, for example in high-level synthesis flows targeting an FSM+Datapath execution model (&amp;ldquo;static HLS&amp;rdquo;). This document gives an overview of, and provides rationale for, the infrastructure in the circt::scheduling namespace. At its core, it defines an extensible problem model that acts as an interface between clients (i.e. passes that have a need to schedule a graph-like IR) and reusable algorithm implementations.
This infrastructure aims to provide:</description></item><item><title>Symbol and Inner Symbol Rationale</title><link>https://circt.llvm.org/docs/RationaleSymbols/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleSymbols/</guid><description>This document describes various design points of the major CIRCT dialects relating to the use of symbols and the introduction of inner symbols and related types. This follows in the spirit of other MLIR Rationale docs.
Introduction Verilog and FIRRTL have, from a software compiler perspective, an unusual number of nameable entities which can be referred to non-locally. These entities have deep nesting in the code structures. The requirements of dealing with these entities and references entails more complexity than provided by MLIR&amp;rsquo;s symbols and symbol tables.</description></item><item><title>Using the Python Bindings</title><link>https://circt.llvm.org/docs/PythonBindings/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/PythonBindings/</guid><description>If you are mainly interested in using CIRCT from Python scripts, you need to compile both LLVM/MLIR and CIRCT with Python bindings enabled. Furthermore, you must use a unified build, where LLVM/MLIR and CIRCT are compiled together in one step.
CIRCT also includes an experimental, opinionated frontend for CIRCT&amp;rsquo;s Python bindings, called PyCDE.
Installing and Building with Wheels CIRCT provides a setup.py script that take care of configuring and building LLVM/MLIR, CIRCT, and CIRCT&amp;rsquo;s Python bindings.</description></item><item><title>Verilog and SystemVerilog Generation</title><link>https://circt.llvm.org/docs/VerilogGeneration/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/VerilogGeneration/</guid><description>Verilog and SystemVerilog are critical components of the hardware design tool ecosystem, but generating syntactically correct Verilog that is acceptable by a wide range of tools is a challenge &amp;ndash; and generating &amp;ldquo;good looking&amp;rdquo; output even more so. This document describes CIRCT&amp;rsquo;s approach and support for generating Verilog and SystemVerilog, some of the features and capabilities provided, and information about the internal layering of the related subsystems.
Why is this hard?</description></item></channel></rss>