<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code Documentation on CIRCT</title><link>https://circt.llvm.org/docs/</link><description>Recent content in Code Documentation on CIRCT</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Nov 2019 15:26:15 +0000</lastBuildDate><atom:link href="https://circt.llvm.org/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>CIRCT Charter</title><link>https://circt.llvm.org/docs/Charter/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Charter/</guid><description>Abstract Recent trends in computer architecture have resulted in two core problems. Firstly, how do we design complex, heterogeneous systems-on-chip mixing general purpose and specialized components? Secondly, how do we program them? We believe that design tools that represent and manipulate a wide variety of abstractions are central to solving these problems. This projects is focused on using LLVM/MLIR to express these abstractions and to build useable open-source flows based on those abstractions to solve the design problems of the next decade.</description></item><item><title>Getting Started with the CIRCT Project</title><link>https://circt.llvm.org/docs/GettingStarted/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/GettingStarted/</guid><description>Overview Welcome to the CIRCT project!
&amp;ldquo;CIRCT&amp;rdquo; stands for &amp;ldquo;Circuit IR Compilers and Tools&amp;rdquo;. The CIRCT project is an (experimental!) effort looking to apply MLIR and the LLVM development methodology to the domain of hardware design tools.
Take a look at the following diagram, which gives a brief overview of the current dialects and how they interact:
Setting this up These commands can be used to setup CIRCT project:
Install Dependencies of LLVM/MLIR according to the instructions, including cmake and ninja.</description></item><item><title>Passes</title><link>https://circt.llvm.org/docs/Passes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Passes/</guid><description>This document describes the available CIRCT passes and their contracts.
Conversion Passes -convert-affine-to-staticlogic: Convert Affine dialect to StaticLogic pipelines -convert-hw-to-llhd: Convert HW to LLHD -convert-llhd-to-llvm: Convert LLHD to LLVM -convert-moore-to-core: Convert Moore to Core -create-pipeline: Create StaticLogic pipeline operations -export-split-verilog: Emit the IR to a (System)Verilog directory of files -export-verilog: Emit the IR to a (System)Verilog file -handshake-remove-block-structure: Remove block structure in Handshake IR -lower-calyx-to-hw: Lower Calyx to HW -lower-firrtl-to-hw: Lower FIRRTL to HW -lower-handshake-to-firrtl: Lower Handshake to FIRRTL -lower-handshake-to-hw: Lower Handshake to ESI/HW/Comb/Seq -lower-scf-to-calyx: Lower SCF/Standard to Calyx -lower-static-logic-to-calyx: Lower StaticLogic to Calyx -lower-std-to-handshake: Lower Standard MLIR into Handshake IR -test-prepare-for-emission: Prepare IR for ExportVerilog Calyx Dialect Passes -calyx-clk-insertion: Inserts assignments from component clock to sub-component clock.</description></item><item><title>PyCDE</title><link>https://circt.llvm.org/docs/PyCDE/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/PyCDE/</guid><description>PyCDE stands for Python circuit design entry. It is an experimental, opinionated, Python-based fronted for CIRCT&amp;rsquo;s Python bindings. The goal is to make the definition of hardware modules using the bindings simple.
Installation via Pip PyCDE is now being released on PyPI: https://pypi.org/project/pycde/
Installing and Building with Wheels The simplest way to get started using PyCDE is to install it with the pip install command:
$ cd circt $ pip install frontends/PyCDE --use-feature=in-tree-build If you just want to build the wheel, use the pip wheel command:</description></item><item><title>Static scheduling infrastructure</title><link>https://circt.llvm.org/docs/Scheduling/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Scheduling/</guid><description>Scheduling is a common concern in hardware design, for example in high-level synthesis flows targeting an FSM+Datapath execution model (&amp;ldquo;static HLS&amp;rdquo;). This document gives an overview of, and provides rationale for, the infrastructure in the circt::scheduling namespace. At its core, it defines an extensible problem model that acts as an interface between clients (i.e. passes that have a need to schedule a graph-like IR) and reusable algorithm implementations.
This infrastructure aims to provide:</description></item><item><title>Symbol and Inner Symbol Rationale</title><link>https://circt.llvm.org/docs/RationaleSymbols/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleSymbols/</guid><description>This document describes various design points of the major CIRCT dialects relating to the use of symbols and the introduction of inner symbols and related types. This follows in the spirit of other MLIR Rationale docs.
Introduction Verilog and FIRRTL have, from a software compiler perspective, an unusual number of nameable entities which can be referred to non-locally. These entities have deep nesting in the code structures. The requirements of dealing with these entities and references entails more complexity than provided by MLIR&amp;rsquo;s symbols and symbol tables.</description></item><item><title>Using the Python Bindings</title><link>https://circt.llvm.org/docs/PythonBindings/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/PythonBindings/</guid><description>If you are mainly interested in using CIRCT from Python scripts, you need to compile both LLVM/MLIR and CIRCT with Python bindings enabled. Furthermore, you must use a unified build, where LLVM/MLIR and CIRCT are compiled together in one step.
CIRCT also includes an experimental, opinionated frontend for CIRCT&amp;rsquo;s Python bindings, called PyCDE.
Installing and Building with Wheels CIRCT provides a setup.py script that take care of configuring and building LLVM/MLIR, CIRCT, and CIRCT&amp;rsquo;s Python bindings.</description></item><item><title>Verilog and SystemVerilog Generation</title><link>https://circt.llvm.org/docs/VerilogGeneration/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/VerilogGeneration/</guid><description>Verilog and SystemVerilog are critical components of the hardware design tool ecosystem, but generating syntactically correct Verilog that is acceptable by a wide range of tools is a challenge &amp;ndash; and generating &amp;ldquo;good looking&amp;rdquo; output even more so. This document describes CIRCT&amp;rsquo;s approach and support for generating Verilog and SystemVerilog, some of the features and capabilities provided, and information about the internal layering of the related subsystems.
Why is this hard?</description></item></channel></rss>