<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CIRCT: circt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CIRCT
   &#160;<span id="projectnumber">19.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">circt Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file defines an intermediate representation for circuits acting as an abstraction for constraints defined over an SMT's solver context.  
<a href="namespacecirct.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecirct_1_1analysis"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1analysis.html">analysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1arc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1arc.html">arc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1calyx"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1calyx.html">calyx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1calyxToFSM"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1calyxToFSM.html">calyxToFSM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1chirrtl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1chirrtl.html">chirrtl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1comb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1comb.html">comb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1dc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1dc.html">dc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1debug"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1debug.html">debug</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1emit"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1emit.html">emit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1esi"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1esi.html">esi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1ExportSMTLIB"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1ExportSMTLIB.html">ExportSMTLIB</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1ExportSystemC"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1ExportSystemC.html">ExportSystemC</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1ExportVerilog"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1ExportVerilog.html">ExportVerilog</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1firrtl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1firrtl.html">firrtl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1firtool"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1firtool.html">firtool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1fsm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1fsm.html">fsm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1handshake"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1handshake.html">handshake</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1handshaketodc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1handshaketodc.html">handshaketodc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1hw"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1hw.html">hw</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1hwarith"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1hwarith.html">hwarith</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1ibis"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1ibis.html">ibis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1igraph"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1igraph.html">igraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1ImportVerilog"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1ImportVerilog.html">ImportVerilog</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1llhd"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1llhd.html">llhd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1loopschedule"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1loopschedule.html">loopschedule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1ltl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1ltl.html">ltl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1moore"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1moore.html">moore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1msft"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1msft.html">msft</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1om"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1om.html">om</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1parsing__util"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1parsing__util.html">parsing_util</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1pipeline"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1pipeline.html">pipeline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1pipelinetocalyx"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1pipelinetocalyx.html">pipelinetocalyx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1pretty"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1pretty.html">pretty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1python"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1python.html">python</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1reduce"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1reduce.html">reduce</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1scfToCalyx"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1scfToCalyx.html">scfToCalyx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1scftocalyx"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1scftocalyx.html">scftocalyx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1scheduling"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1scheduling.html">scheduling</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1seq"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1seq.html">seq</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1sim"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1sim.html">sim</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1smt"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1smt.html">smt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1ssp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1ssp.html">ssp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1sv"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1sv.html">sv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1systemc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1systemc.html">systemc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1test"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1test.html">test</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecirct_1_1verif"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct_1_1verif.html">verif</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1DebugAnalysis.html">DebugAnalysis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify operations and values that are only used for debug info.  <a href="structcirct_1_1DebugAnalysis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1DIModule.html">DIModule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1DIInstance.html">DIInstance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1DIVariable.html">DIVariable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1DebugInfo.html">DebugInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug information attached to an operation and the operations nested within.  <a href="structcirct_1_1DebugInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1HWArithToHWTypeConverter.html">HWArithToHWTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper type converter class that automatically populates the relevant materializations and type conversions for converting HWArith to HW.  <a href="classcirct_1_1HWArithToHWTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1HWToLLVMEndianessConverter.html">HWToLLVMEndianessConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1ImportVerilogOptions.html">ImportVerilogOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options that control how Verilog input files are parsed and processed.  <a href="structcirct_1_1ImportVerilogOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1TypeConversionPattern.html">TypeConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic pattern which replaces an operation by one of the same operation name, but with converted attributes, operands, and result types to eliminate illegal types.  <a href="structcirct_1_1TypeConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1TypeOpConversionPattern.html">TypeOpConversionPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1LogicExporter.html">LogicExporter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class traversing MLIR IR to extrapolate the logic of a given circuit.  <a href="classcirct_1_1LogicExporter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1Solver.html">Solver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A satisfiability checker for circuit equivalence.  <a href="classcirct_1_1Solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1Reduction.html">Reduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract reduction pattern.  <a href="structcirct_1_1Reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1OpReduction.html">OpReduction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1PassReduction.html">PassReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reduction pattern that applies an <code>mlir::Pass</code>.  <a href="structcirct_1_1PassReduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1ReducePatternSet.html">ReducePatternSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1ReducePatternDialectInterface.html">ReducePatternDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dialect interface to provide reduction patterns to a reducer tool.  <a href="structcirct_1_1ReducePatternDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1ReducePatternInterfaceCollection.html">ReducePatternInterfaceCollection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1Tester.html">Tester</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A testing environment for reduction attempts.  <a href="classcirct_1_1Tester.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1TestCase.html">TestCase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single test case to be run by a tester.  <a href="classcirct_1_1TestCase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1BackedgeBuilder.html">BackedgeBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate one of these and use it to build typed backedges.  <a href="classcirct_1_1BackedgeBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1Backedge.html">Backedge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classcirct_1_1Backedge.html" title="Backedge is a wrapper class around a Value.">Backedge</a></code> is a wrapper class around a <code>Value</code>.  <a href="classcirct_1_1Backedge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1StringAttrOrRef.html">StringAttrOrRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper union that can represent a <code>StringAttr</code>, <code>StringRef</code>, or <code>Twine</code>.  <a href="classcirct_1_1StringAttrOrRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1FieldRef.html">FieldRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a reference to a specific field or element of an aggregate value.  <a href="classcirct_1_1FieldRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1LoweringOptions.html">LoweringOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options which control the emission from CIRCT to Verilog.  <a href="structcirct_1_1LoweringOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1LoweringOptionsParser.html">LoweringOptionsParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commandline parser for <a class="el" href="structcirct_1_1LoweringOptions.html" title="Options which control the emission from CIRCT to Verilog.">LoweringOptions</a>.  <a href="structcirct_1_1LoweringOptionsParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1LoweringOptionsOption.html">LoweringOptionsOption</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1Namespace.html">Namespace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A namespace that is used to store existing names and generate new names in some scope within the IR.  <a href="classcirct_1_1Namespace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1VerbosePassInstrumentation.html">VerbosePassInstrumentation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1SymbolCacheBase.html">SymbolCacheBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base symbol cache class to allow for cache lookup through a pointer to some abstract cache.  <a href="classcirct_1_1SymbolCacheBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1SymbolCache.html">SymbolCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default symbol cache implementation; stores associations between names (StringAttr's) to mlir::Operation's.  <a href="classcirct_1_1SymbolCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1ValueMapper.html">ValueMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classcirct_1_1ValueMapper.html" title="The ValueMapper class facilitates the definition and connection of SSA def-use chains between two loc...">ValueMapper</a> class facilitates the definition and connection of SSA def-use chains between two location - a 'from' location (defining use-def chains) and a 'to' location (where new operations are created based on the 'from' location).  <a href="classcirct_1_1ValueMapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1SSAMaximizationStrategy.html">SSAMaximizationStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy class to control the behavior of SSA maximization.  <a href="classcirct_1_1SSAMaximizationStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcirct_1_1FirMemConfig.html">FirMemConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configuration of a FIR memory.  <a href="structcirct_1_1FirMemConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1FirMemLowering.html">FirMemLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FIR memory lowering helper.  <a href="classcirct_1_1FirMemLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcirct_1_1FirRegLowering.html">FirRegLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower FirRegOp to <code>sv.reg</code> and <code>sv.always</code>.  <a href="classcirct_1_1FirRegLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac84e30e51c8bb7f99590767a99ac0161"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ac84e30e51c8bb7f99590767a99ac0161">createAffineToLoopSchedule</a> ()</td></tr>
<tr class="separator:ac84e30e51c8bb7f99590767a99ac0161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60845b4a17984b09d46bc1b38627a80"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ac60845b4a17984b09d46bc1b38627a80">createLowerArcToLLVMPass</a> ()</td></tr>
<tr class="separator:ac60845b4a17984b09d46bc1b38627a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edc03584607447773267c1791edc0b1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a3edc03584607447773267c1791edc0b1">createCalyxNativePass</a> ()</td></tr>
<tr class="separator:a3edc03584607447773267c1791edc0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011024697ebd49e412ef36ee5259e048"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a011024697ebd49e412ef36ee5259e048">createCalyxToFSMPass</a> ()</td></tr>
<tr class="separator:a011024697ebd49e412ef36ee5259e048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943e8d5476ac817f8dcf3d4db3d236b9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a943e8d5476ac817f8dcf3d4db3d236b9">createMaterializeCalyxToFSMPass</a> ()</td></tr>
<tr class="separator:a943e8d5476ac817f8dcf3d4db3d236b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f284eeeb2471adca9113c7419cc5fe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a03f284eeeb2471adca9113c7419cc5fe">createRemoveGroupsFromFSMPass</a> ()</td></tr>
<tr class="separator:a03f284eeeb2471adca9113c7419cc5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfcfa6773667451344ece7a62fcc079"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a7dfcfa6773667451344ece7a62fcc079">createCalyxToHWPass</a> ()</td></tr>
<tr class="separator:a7dfcfa6773667451344ece7a62fcc079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa894b775b2e21df1a6adf14c639c3afe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#aa894b775b2e21df1a6adf14c639c3afe">createHandshakeAnalysisPass</a> ()</td></tr>
<tr class="separator:aa894b775b2e21df1a6adf14c639c3afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895098b1bbb91ce21d30693715d75389"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a895098b1bbb91ce21d30693715d75389">createCFToHandshakePass</a> (bool sourceConstants=false, bool disableTaskPipelining=false)</td></tr>
<tr class="separator:a895098b1bbb91ce21d30693715d75389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02e04be8495987ff76ba0f791038512"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; handshake::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#af02e04be8495987ff76ba0f791038512">createHandshakeCanonicalizePass</a> ()</td></tr>
<tr class="separator:af02e04be8495987ff76ba0f791038512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe33fafaca8cb3676572fbeceba838e4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; handshake::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#abe33fafaca8cb3676572fbeceba838e4">createHandshakeRemoveBlockPass</a> ()</td></tr>
<tr class="separator:abe33fafaca8cb3676572fbeceba838e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9dd96e6afbbe667a58553306cc0e68"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a6d9dd96e6afbbe667a58553306cc0e68">insertMergeBlocks</a> (mlir::Region &amp;r, mlir::ConversionPatternRewriter &amp;rewriter)</td></tr>
<tr class="memdesc:a6d9dd96e6afbbe667a58553306cc0e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert additional blocks that serve as counterparts to the blocks that diverged the control flow.  <a href="namespacecirct.html#a6d9dd96e6afbbe667a58553306cc0e68">More...</a><br /></td></tr>
<tr class="separator:a6d9dd96e6afbbe667a58553306cc0e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad9e087642b4c838c212e5b3c0d1c9b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a2ad9e087642b4c838c212e5b3c0d1c9b">createInsertMergeBlocksPass</a> ()</td></tr>
<tr class="separator:a2ad9e087642b4c838c212e5b3c0d1c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e52a7793131eac522c1da31fdd13bef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a1e52a7793131eac522c1da31fdd13bef">populateCombToArithConversionPatterns</a> (TypeConverter &amp;converter, RewritePatternSet &amp;patterns)</td></tr>
<tr class="separator:a1e52a7793131eac522c1da31fdd13bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6e347007a741999cc0fdca1454a05d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#aad6e347007a741999cc0fdca1454a05d">createConvertCombToArithPass</a> ()</td></tr>
<tr class="separator:aad6e347007a741999cc0fdca1454a05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335a541a046f38e34b599b627646473e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a335a541a046f38e34b599b627646473e">populateCombToLLVMConversionPatterns</a> (mlir::LLVMTypeConverter &amp;converter, RewritePatternSet &amp;patterns)</td></tr>
<tr class="memdesc:a335a541a046f38e34b599b627646473e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Comb to LLVM conversion patterns.  <a href="namespacecirct.html#a335a541a046f38e34b599b627646473e">More...</a><br /></td></tr>
<tr class="separator:a335a541a046f38e34b599b627646473e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707c712628af185e79d61aa10cd73234"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a707c712628af185e79d61aa10cd73234">populateCombToSMTConversionPatterns</a> (TypeConverter &amp;converter, RewritePatternSet &amp;patterns)</td></tr>
<tr class="memdesc:a707c712628af185e79d61aa10cd73234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the HW to SMT conversion patterns.  <a href="namespacecirct.html#a707c712628af185e79d61aa10cd73234">More...</a><br /></td></tr>
<tr class="separator:a707c712628af185e79d61aa10cd73234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e92dfead270741ef9127e9324f2208b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a3e92dfead270741ef9127e9324f2208b">createConvertToArcsPass</a> (const ConvertToArcsOptions &amp;options={})</td></tr>
<tr class="separator:a3e92dfead270741ef9127e9324f2208b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6adb8c10b38b0be83bf41c4e1b04333"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ab6adb8c10b38b0be83bf41c4e1b04333">createDCToHWPass</a> ()</td></tr>
<tr class="separator:ab6adb8c10b38b0be83bf41c4e1b04333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdc38d1b7670ad39780cd57bcb371de"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a5bdc38d1b7670ad39780cd57bcb371de">createExportChiselInterfacePass</a> (llvm::raw_ostream &amp;os)</td></tr>
<tr class="separator:a5bdc38d1b7670ad39780cd57bcb371de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d644b0af607b8714198cf0de99ac213"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a1d644b0af607b8714198cf0de99ac213">createExportSplitChiselInterfacePass</a> (mlir::StringRef outputDirectory=&quot;./&quot;)</td></tr>
<tr class="separator:a1d644b0af607b8714198cf0de99ac213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3eabfa1662055b499aa587a0b3c01f3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ad3eabfa1662055b499aa587a0b3c01f3">createExportChiselInterfacePass</a> ()</td></tr>
<tr class="separator:ad3eabfa1662055b499aa587a0b3c01f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbb547d156db232c1e5fbdfc6fb7c06"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a8bbb547d156db232c1e5fbdfc6fb7c06">createTestApplyLoweringOptionPass</a> (llvm::StringRef options)</td></tr>
<tr class="separator:a8bbb547d156db232c1e5fbdfc6fb7c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9cbce120f38be2c241c0f7381f9e0b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#abd9cbce120f38be2c241c0f7381f9e0b">createTestApplyLoweringOptionPass</a> ()</td></tr>
<tr class="separator:abd9cbce120f38be2c241c0f7381f9e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d19dc78501d41e2c31e18f387f786d3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a0d19dc78501d41e2c31e18f387f786d3">createHWLowerInstanceChoicesPass</a> ()</td></tr>
<tr class="separator:a0d19dc78501d41e2c31e18f387f786d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca653a43a6325cdd2fdeca576f9b8b4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#adca653a43a6325cdd2fdeca576f9b8b4">createPrepareForEmissionPass</a> ()</td></tr>
<tr class="separator:adca653a43a6325cdd2fdeca576f9b8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8439a734e7d96453aa4ba13a9fc8591"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ab8439a734e7d96453aa4ba13a9fc8591">createLegalizeAnonEnumsPass</a> ()</td></tr>
<tr class="separator:ab8439a734e7d96453aa4ba13a9fc8591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae996c248ae7cb3f8ffb344d84022f3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a5ae996c248ae7cb3f8ffb344d84022f3">createExportVerilogPass</a> (std::unique_ptr&lt; llvm::raw_ostream &gt; os)</td></tr>
<tr class="separator:a5ae996c248ae7cb3f8ffb344d84022f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc15088c1b5bfd5c566c4b309a26458b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#adc15088c1b5bfd5c566c4b309a26458b">createExportVerilogPass</a> (llvm::raw_ostream &amp;os)</td></tr>
<tr class="separator:adc15088c1b5bfd5c566c4b309a26458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45dfc223465e0e8b4728b760adb2664"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ad45dfc223465e0e8b4728b760adb2664">createExportVerilogPass</a> ()</td></tr>
<tr class="separator:ad45dfc223465e0e8b4728b760adb2664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611a14d3fb8514edda384b51998d7427"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a611a14d3fb8514edda384b51998d7427">createExportSplitVerilogPass</a> (llvm::StringRef directory=&quot;./&quot;)</td></tr>
<tr class="separator:a611a14d3fb8514edda384b51998d7427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190e54fae6bf3e6ba5ef813a09660599"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a190e54fae6bf3e6ba5ef813a09660599">exportVerilog</a> (mlir::ModuleOp module, llvm::raw_ostream &amp;os)</td></tr>
<tr class="memdesc:a190e54fae6bf3e6ba5ef813a09660599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export a module containing HW, and SV dialect code.  <a href="namespacecirct.html#a190e54fae6bf3e6ba5ef813a09660599">More...</a><br /></td></tr>
<tr class="separator:a190e54fae6bf3e6ba5ef813a09660599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952880b2424f3eb1eabf2fe2cd040420"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a952880b2424f3eb1eabf2fe2cd040420">exportSplitVerilog</a> (mlir::ModuleOp module, llvm::StringRef dirname)</td></tr>
<tr class="memdesc:a952880b2424f3eb1eabf2fe2cd040420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export a module containing HW, and SV dialect code, as one file per SV module.  <a href="namespacecirct.html#a952880b2424f3eb1eabf2fe2cd040420">More...</a><br /></td></tr>
<tr class="separator:a952880b2424f3eb1eabf2fe2cd040420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef8652b25c8a19be150b3d6c7ac9e78"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a1ef8652b25c8a19be150b3d6c7ac9e78">createLowerFIRRTLToHWPass</a> (bool enableAnnotationWarning=false, bool emitChiselAssertsAsSVA=false)</td></tr>
<tr class="memdesc:a1ef8652b25c8a19be150b3d6c7ac9e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the pass constructor.  <a href="namespacecirct.html#a1ef8652b25c8a19be150b3d6c7ac9e78">More...</a><br /></td></tr>
<tr class="separator:a1ef8652b25c8a19be150b3d6c7ac9e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b260d113fe932da95d9e88ad5931fe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a03b260d113fe932da95d9e88ad5931fe">createConvertFSMToSVPass</a> ()</td></tr>
<tr class="separator:a03b260d113fe932da95d9e88ad5931fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10ff85e83d8cd6f6709399cd6dd086e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#af10ff85e83d8cd6f6709399cd6dd086e">createHandshakeToDCPass</a> ()</td></tr>
<tr class="separator:af10ff85e83d8cd6f6709399cd6dd086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39829130f4b027047ee6947a204add3f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a39829130f4b027047ee6947a204add3f">createHandshakeToHWPass</a> ()</td></tr>
<tr class="separator:a39829130f4b027047ee6947a204add3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaefdabf2102a25f00d783253fdf63e67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#aaefdabf2102a25f00d783253fdf63e67">populateHWArithToHWConversionPatterns</a> (<a class="el" href="classcirct_1_1HWArithToHWTypeConverter.html">HWArithToHWTypeConverter</a> &amp;typeConverter, RewritePatternSet &amp;patterns)</td></tr>
<tr class="memdesc:aaefdabf2102a25f00d783253fdf63e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the HWArith to HW conversion patterns.  <a href="namespacecirct.html#aaefdabf2102a25f00d783253fdf63e67">More...</a><br /></td></tr>
<tr class="separator:aaefdabf2102a25f00d783253fdf63e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5aa1edf0c24af2035aef5e3dc8e4e2e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ae5aa1edf0c24af2035aef5e3dc8e4e2e">createHWArithToHWPass</a> ()</td></tr>
<tr class="separator:ae5aa1edf0c24af2035aef5e3dc8e4e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661555bc389408e1b25cc04e91945d05"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a661555bc389408e1b25cc04e91945d05">createConvertHWToBTOR2Pass</a> (llvm::raw_ostream &amp;os)</td></tr>
<tr class="separator:a661555bc389408e1b25cc04e91945d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7417f55cb2abe15561d63db25cbbb30"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ac7417f55cb2abe15561d63db25cbbb30">createConvertHWToBTOR2Pass</a> ()</td></tr>
<tr class="separator:ac7417f55cb2abe15561d63db25cbbb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b2eb633f3a36e50550baeb8a5873f8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a34b2eb633f3a36e50550baeb8a5873f8">createConvertHWToLLHDPass</a> ()</td></tr>
<tr class="memdesc:a34b2eb633f3a36e50550baeb8a5873f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HW to LLHD conversion pass.  <a href="namespacecirct.html#a34b2eb633f3a36e50550baeb8a5873f8">More...</a><br /></td></tr>
<tr class="separator:a34b2eb633f3a36e50550baeb8a5873f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f915a1f0219db72a41ac48d09e96c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a65f915a1f0219db72a41ac48d09e96c1">populateHWToLLVMTypeConversions</a> (mlir::LLVMTypeConverter &amp;converter)</td></tr>
<tr class="memdesc:a65f915a1f0219db72a41ac48d09e96c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the HW to LLVM type conversions.  <a href="namespacecirct.html#a65f915a1f0219db72a41ac48d09e96c1">More...</a><br /></td></tr>
<tr class="separator:a65f915a1f0219db72a41ac48d09e96c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c564a948b734b37512981e5d56bed11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a0c564a948b734b37512981e5d56bed11">populateHWToLLVMConversionPatterns</a> (mlir::LLVMTypeConverter &amp;converter, RewritePatternSet &amp;patterns, <a class="el" href="classcirct_1_1Namespace.html">Namespace</a> &amp;globals, DenseMap&lt; std::pair&lt; Type, ArrayAttr &gt;, mlir::LLVM::GlobalOp &gt; &amp;constAggregateGlobalsMap)</td></tr>
<tr class="memdesc:a0c564a948b734b37512981e5d56bed11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the HW to LLVM conversion patterns.  <a href="namespacecirct.html#a0c564a948b734b37512981e5d56bed11">More...</a><br /></td></tr>
<tr class="separator:a0c564a948b734b37512981e5d56bed11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0b6b357fb1d81f37be00747d21b031"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a1c0b6b357fb1d81f37be00747d21b031">createConvertHWToLLVMPass</a> ()</td></tr>
<tr class="memdesc:a1c0b6b357fb1d81f37be00747d21b031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an HW to LLVM conversion pass.  <a href="namespacecirct.html#a1c0b6b357fb1d81f37be00747d21b031">More...</a><br /></td></tr>
<tr class="separator:a1c0b6b357fb1d81f37be00747d21b031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea7a8406488724e4af20107b55ae7ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a2ea7a8406488724e4af20107b55ae7ef">populateHWToSMTConversionPatterns</a> (TypeConverter &amp;converter, RewritePatternSet &amp;patterns)</td></tr>
<tr class="memdesc:a2ea7a8406488724e4af20107b55ae7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the HW to SMT conversion patterns.  <a href="namespacecirct.html#a2ea7a8406488724e4af20107b55ae7ef">More...</a><br /></td></tr>
<tr class="separator:a2ea7a8406488724e4af20107b55ae7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ed6ba8317f2515acdd1e91efc44daf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ac4ed6ba8317f2515acdd1e91efc44daf">populateHWToSMTTypeConverter</a> (TypeConverter &amp;converter)</td></tr>
<tr class="memdesc:ac4ed6ba8317f2515acdd1e91efc44daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the HW to SMT type conversions.  <a href="namespacecirct.html#ac4ed6ba8317f2515acdd1e91efc44daf">More...</a><br /></td></tr>
<tr class="separator:ac4ed6ba8317f2515acdd1e91efc44daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae138488e420858a784e24bfc9ea9ec55"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; <a class="el" href="classhw_1_1HWModuleOp.html">hw::HWModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ae138488e420858a784e24bfc9ea9ec55">createLowerHWToSVPass</a> ()</td></tr>
<tr class="separator:ae138488e420858a784e24bfc9ea9ec55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100e5eda876a13295d188c96d8760d0f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a100e5eda876a13295d188c96d8760d0f">createConvertHWToSystemCPass</a> ()</td></tr>
<tr class="memdesc:a100e5eda876a13295d188c96d8760d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a HW to SystemC dialects conversion pass.  <a href="namespacecirct.html#a100e5eda876a13295d188c96d8760d0f">More...</a><br /></td></tr>
<tr class="separator:a100e5eda876a13295d188c96d8760d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c3af24b2c09ed8d9cc0cd2671eb3f4"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ac9c3af24b2c09ed8d9cc0cd2671eb3f4">importVerilog</a> (llvm::SourceMgr &amp;sourceMgr, mlir::MLIRContext *context, mlir::TimingScope &amp;ts, mlir::ModuleOp module, const <a class="el" href="structcirct_1_1ImportVerilogOptions.html">ImportVerilogOptions</a> *options=nullptr)</td></tr>
<tr class="memdesc:ac9c3af24b2c09ed8d9cc0cd2671eb3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse files in a source manager as Verilog source code and populate the given MLIR <code>module</code> with corresponding ops.  <a href="namespacecirct.html#ac9c3af24b2c09ed8d9cc0cd2671eb3f4">More...</a><br /></td></tr>
<tr class="separator:ac9c3af24b2c09ed8d9cc0cd2671eb3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7018555071ac970572f56c73f0fd35a"><td class="memItemLeft" align="right" valign="top">mlir::LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ae7018555071ac970572f56c73f0fd35a">preprocessVerilog</a> (llvm::SourceMgr &amp;sourceMgr, mlir::MLIRContext *context, mlir::TimingScope &amp;ts, llvm::raw_ostream &amp;os, const <a class="el" href="structcirct_1_1ImportVerilogOptions.html">ImportVerilogOptions</a> *options=nullptr)</td></tr>
<tr class="memdesc:ae7018555071ac970572f56c73f0fd35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the files in a source manager through Slang's Verilog preprocessor and emit the result to the given output stream.  <a href="namespacecirct.html#ae7018555071ac970572f56c73f0fd35a">More...</a><br /></td></tr>
<tr class="separator:ae7018555071ac970572f56c73f0fd35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38f84835e25707495eb5370c3e5591d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#af38f84835e25707495eb5370c3e5591d">registerFromVerilogTranslation</a> ()</td></tr>
<tr class="memdesc:af38f84835e25707495eb5370c3e5591d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the <code>import-verilog</code> MLIR translation.  <a href="namespacecirct.html#af38f84835e25707495eb5370c3e5591d">More...</a><br /></td></tr>
<tr class="separator:af38f84835e25707495eb5370c3e5591d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85579b6420c9fb3fbb833b8c1c73d3e1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a85579b6420c9fb3fbb833b8c1c73d3e1">getSlangVersion</a> ()</td></tr>
<tr class="memdesc:a85579b6420c9fb3fbb833b8c1c73d3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a human-readable string describing the slang frontend version linked into CIRCT.  <a href="namespacecirct.html#a85579b6420c9fb3fbb833b8c1c73d3e1">More...</a><br /></td></tr>
<tr class="separator:a85579b6420c9fb3fbb833b8c1c73d3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e131da504433f790ec75e1f9fc5262"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a90e131da504433f790ec75e1f9fc5262">populateLLHDToLLVMTypeConversions</a> (mlir::LLVMTypeConverter &amp;converter)</td></tr>
<tr class="memdesc:a90e131da504433f790ec75e1f9fc5262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the LLHD to LLVM type conversions.  <a href="namespacecirct.html#a90e131da504433f790ec75e1f9fc5262">More...</a><br /></td></tr>
<tr class="separator:a90e131da504433f790ec75e1f9fc5262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfc00eebc213425a364cbe8fb74279a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#abbfc00eebc213425a364cbe8fb74279a">populateLLHDToLLVMConversionPatterns</a> (mlir::LLVMTypeConverter &amp;converter, RewritePatternSet &amp;patterns, size_t &amp;sigCounter, size_t &amp;regCounter)</td></tr>
<tr class="memdesc:abbfc00eebc213425a364cbe8fb74279a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the LLHD to LLVM conversion patterns.  <a href="namespacecirct.html#abbfc00eebc213425a364cbe8fb74279a">More...</a><br /></td></tr>
<tr class="separator:abbfc00eebc213425a364cbe8fb74279a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f03349b31a601f5baadc173fdd3843b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a9f03349b31a601f5baadc173fdd3843b">createConvertLLHDToLLVMPass</a> ()</td></tr>
<tr class="memdesc:a9f03349b31a601f5baadc173fdd3843b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an LLHD to LLVM conversion pass.  <a href="namespacecirct.html#a9f03349b31a601f5baadc173fdd3843b">More...</a><br /></td></tr>
<tr class="separator:a9f03349b31a601f5baadc173fdd3843b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479c780b69e919e7aeeef1d0b71f9756"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a479c780b69e919e7aeeef1d0b71f9756">createLoopScheduleToCalyxPass</a> ()</td></tr>
<tr class="memdesc:a479c780b69e919e7aeeef1d0b71f9756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a LoopSchedule to Calyx conversion pass.  <a href="namespacecirct.html#a479c780b69e919e7aeeef1d0b71f9756">More...</a><br /></td></tr>
<tr class="separator:a479c780b69e919e7aeeef1d0b71f9756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ff05c0734850ae85e7aab67bc32fdc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#aa9ff05c0734850ae85e7aab67bc32fdc">createConvertMooreToCorePass</a> ()</td></tr>
<tr class="memdesc:aa9ff05c0734850ae85e7aab67bc32fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Moore to Comb/HW/LLHD conversion pass.  <a href="namespacecirct.html#aa9ff05c0734850ae85e7aab67bc32fdc">More...</a><br /></td></tr>
<tr class="separator:aa9ff05c0734850ae85e7aab67bc32fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a151146531a7869a94a38dc2e77f8ae"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a6a151146531a7869a94a38dc2e77f8ae">createPipelineToHWPass</a> (const PipelineToHWOptions &amp;options={})</td></tr>
<tr class="memdesc:a6a151146531a7869a94a38dc2e77f8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an SCF to Calyx conversion pass.  <a href="namespacecirct.html#a6a151146531a7869a94a38dc2e77f8ae">More...</a><br /></td></tr>
<tr class="separator:a6a151146531a7869a94a38dc2e77f8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaeb016225c004e9768edb7af6a0a5e6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#acaeb016225c004e9768edb7af6a0a5e6">createSCFToCalyxPass</a> ()</td></tr>
<tr class="memdesc:acaeb016225c004e9768edb7af6a0a5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an SCF to Calyx conversion pass.  <a href="namespacecirct.html#acaeb016225c004e9768edb7af6a0a5e6">More...</a><br /></td></tr>
<tr class="separator:acaeb016225c004e9768edb7af6a0a5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb7a7ce775f1580189a464c437bfc47"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a7cb7a7ce775f1580189a464c437bfc47">createLowerSeqToSVPass</a> (const LowerSeqToSVOptions &amp;options={})</td></tr>
<tr class="separator:a7cb7a7ce775f1580189a464c437bfc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8634f7165e95a98e4d478e89f4518657"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a8634f7165e95a98e4d478e89f4518657">createLowerFirMemPass</a> ()</td></tr>
<tr class="separator:a8634f7165e95a98e4d478e89f4518657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122bde706550dc471f256d819643c674"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a122bde706550dc471f256d819643c674">createLowerSeqFIRRTLInitToSV</a> ()</td></tr>
<tr class="separator:a122bde706550dc471f256d819643c674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac595a5ae4980e2eb97e2d4c0271bd080"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ac595a5ae4980e2eb97e2d4c0271bd080">createLowerSimToSVPass</a> ()</td></tr>
<tr class="separator:ac595a5ae4980e2eb97e2d4c0271bd080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039a40fd6b74b3e3f0001f40fc6dfad7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a039a40fd6b74b3e3f0001f40fc6dfad7">populateVerifToSMTConversionPatterns</a> (TypeConverter &amp;converter, RewritePatternSet &amp;patterns)</td></tr>
<tr class="memdesc:a039a40fd6b74b3e3f0001f40fc6dfad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Verif to SMT conversion patterns.  <a href="namespacecirct.html#a039a40fd6b74b3e3f0001f40fc6dfad7">More...</a><br /></td></tr>
<tr class="separator:a039a40fd6b74b3e3f0001f40fc6dfad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6840c1ef8f8f0c4966bc105246f316db"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classhw_1_1HWModuleOp.html">hw::HWModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a6840c1ef8f8f0c4966bc105246f316db">createLowerVerifToSVPass</a> ()</td></tr>
<tr class="memdesc:a6840c1ef8f8f0c4966bc105246f316db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the Verif to SV conversion pass.  <a href="namespacecirct.html#a6840c1ef8f8f0c4966bc105246f316db">More...</a><br /></td></tr>
<tr class="separator:a6840c1ef8f8f0c4966bc105246f316db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0d6578faea55af939bed33724594fa"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#aec0d6578faea55af939bed33724594fa">doTypeConversion</a> (Operation *op, ValueRange operands, ConversionPatternRewriter &amp;rewriter, const TypeConverter *typeConverter)</td></tr>
<tr class="separator:aec0d6578faea55af939bed33724594fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262877a915999b2532d1782316d6d2b4"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a262877a915999b2532d1782316d6d2b4">parseInputPortList</a> (OpAsmParser &amp;parser, SmallVectorImpl&lt; OpAsmParser::UnresolvedOperand &gt; &amp;<a class="el" href="PassHelpers_8cpp.html#a4a17064ff1ac6efc0b18d4058732686a">inputs</a>, SmallVectorImpl&lt; Type &gt; &amp;inputTypes, ArrayAttr &amp;inputNames)</td></tr>
<tr class="memdesc:a262877a915999b2532d1782316d6d2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a list of instance input ports.  <a href="namespacecirct.html#a262877a915999b2532d1782316d6d2b4">More...</a><br /></td></tr>
<tr class="separator:a262877a915999b2532d1782316d6d2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae839c8955f7669e0f8bf35efa0b57efd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ae839c8955f7669e0f8bf35efa0b57efd">printInputPortList</a> (OpAsmPrinter &amp;p, Operation *op, OperandRange <a class="el" href="PassHelpers_8cpp.html#a4a17064ff1ac6efc0b18d4058732686a">inputs</a>, TypeRange inputTypes, ArrayAttr inputNames)</td></tr>
<tr class="memdesc:ae839c8955f7669e0f8bf35efa0b57efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a list of instance input ports.  <a href="namespacecirct.html#ae839c8955f7669e0f8bf35efa0b57efd">More...</a><br /></td></tr>
<tr class="separator:ae839c8955f7669e0f8bf35efa0b57efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdd86e5df7d34c0e669e84603b8e411"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#affdd86e5df7d34c0e669e84603b8e411">parseOutputPortList</a> (OpAsmParser &amp;parser, SmallVectorImpl&lt; Type &gt; &amp;resultTypes, ArrayAttr &amp;resultNames)</td></tr>
<tr class="memdesc:affdd86e5df7d34c0e669e84603b8e411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a list of instance output ports.  <a href="namespacecirct.html#affdd86e5df7d34c0e669e84603b8e411">More...</a><br /></td></tr>
<tr class="separator:affdd86e5df7d34c0e669e84603b8e411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4558f6f3686ea745fb45daa44a09f7dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a4558f6f3686ea745fb45daa44a09f7dc">printOutputPortList</a> (OpAsmPrinter &amp;p, Operation *op, TypeRange resultTypes, ArrayAttr resultNames)</td></tr>
<tr class="memdesc:a4558f6f3686ea745fb45daa44a09f7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a list of instance output ports.  <a href="namespacecirct.html#a4558f6f3686ea745fb45daa44a09f7dc">More...</a><br /></td></tr>
<tr class="separator:a4558f6f3686ea745fb45daa44a09f7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1a0253d9c5dec321a03c07c2a60ae0"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a4b1a0253d9c5dec321a03c07c2a60ae0">parseOptionalParameterList</a> (OpAsmParser &amp;parser, ArrayAttr &amp;parameters)</td></tr>
<tr class="memdesc:a4b1a0253d9c5dec321a03c07c2a60ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an parameter list if present.  <a href="namespacecirct.html#a4b1a0253d9c5dec321a03c07c2a60ae0">More...</a><br /></td></tr>
<tr class="separator:a4b1a0253d9c5dec321a03c07c2a60ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512e1ba804e5881866906244c227fb1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a512e1ba804e5881866906244c227fb1f">printOptionalParameterList</a> (OpAsmPrinter &amp;p, Operation *op, ArrayAttr parameters)</td></tr>
<tr class="memdesc:a512e1ba804e5881866906244c227fb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a parameter list for a module or instance.  <a href="namespacecirct.html#a512e1ba804e5881866906244c227fb1f">More...</a><br /></td></tr>
<tr class="separator:a512e1ba804e5881866906244c227fb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369bfe3396c123b69c675513b443f04f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a369bfe3396c123b69c675513b443f04f">registerAllDialects</a> (mlir::DialectRegistry &amp;registry)</td></tr>
<tr class="separator:a369bfe3396c123b69c675513b443f04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0ad4bb681b1ea56e5baf3f6a3ba7b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a5c0ad4bb681b1ea56e5baf3f6a3ba7b2">registerAllPasses</a> ()</td></tr>
<tr class="separator:a5c0ad4bb681b1ea56e5baf3f6a3ba7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175655b229eb86638ce75528ad53bc47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a175655b229eb86638ce75528ad53bc47">registerAllTranslations</a> ()</td></tr>
<tr class="separator:a175655b229eb86638ce75528ad53bc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8bfb1f5705447c1522a3607113b937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a6b8bfb1f5705447c1522a3607113b937">populateGenericReducePatterns</a> (MLIRContext *context, <a class="el" href="classcirct_1_1ReducePatternSet.html">ReducePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6b8bfb1f5705447c1522a3607113b937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate reduction patterns that are not specific to certain operations or dialects.  <a href="namespacecirct.html#a6b8bfb1f5705447c1522a3607113b937">More...</a><br /></td></tr>
<tr class="separator:a6b8bfb1f5705447c1522a3607113b937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8bfac24dda6f9e8834ac103fa20e99"><td class="memItemLeft" align="right" valign="top">APInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#abf8bfac24dda6f9e8834ac103fa20e99">sextZeroWidth</a> (APInt value, unsigned <a class="el" href="FIRRTL_8cpp.html#a395d15e7c2b09961c1bfd1da6179b64c">width</a>)</td></tr>
<tr class="memdesc:abf8bfac24dda6f9e8834ac103fa20e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">A safe version of APInt::sext that will NOT assert on zero-width signed APSInts.  <a href="namespacecirct.html#abf8bfac24dda6f9e8834ac103fa20e99">More...</a><br /></td></tr>
<tr class="separator:abf8bfac24dda6f9e8834ac103fa20e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a53b9396aa3980bc8f79596626db5d"><td class="memItemLeft" align="right" valign="top">APSInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a51a53b9396aa3980bc8f79596626db5d">extOrTruncZeroWidth</a> (APSInt value, unsigned <a class="el" href="FIRRTL_8cpp.html#a395d15e7c2b09961c1bfd1da6179b64c">width</a>)</td></tr>
<tr class="memdesc:a51a53b9396aa3980bc8f79596626db5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A safe version of APSInt::extOrTrunc that will NOT assert on zero-width signed APSInts.  <a href="namespacecirct.html#a51a53b9396aa3980bc8f79596626db5d">More...</a><br /></td></tr>
<tr class="separator:a51a53b9396aa3980bc8f79596626db5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf1f6f10afd9d3c4a3cbbf5ba62315e"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a5bf1f6f10afd9d3c4a3cbbf5ba62315e">parseImplicitSSAName</a> (OpAsmParser &amp;parser, StringAttr &amp;attr)</td></tr>
<tr class="memdesc:a5bf1f6f10afd9d3c4a3cbbf5ba62315e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an implicit SSA name string attribute.  <a href="namespacecirct.html#a5bf1f6f10afd9d3c4a3cbbf5ba62315e">More...</a><br /></td></tr>
<tr class="separator:a5bf1f6f10afd9d3c4a3cbbf5ba62315e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf876aaca64dfbde8a059d750877522"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#abdf876aaca64dfbde8a059d750877522">parseImplicitSSAName</a> (OpAsmParser &amp;parser, NamedAttrList &amp;attrs)</td></tr>
<tr class="memdesc:abdf876aaca64dfbde8a059d750877522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an attribute dictionary and ensure that it contains a <code>name</code> field by inferring its value from the SSA name of the operation's first result if necessary.  <a href="namespacecirct.html#abdf876aaca64dfbde8a059d750877522">More...</a><br /></td></tr>
<tr class="separator:abdf876aaca64dfbde8a059d750877522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be41639d361e361bf0dced94a6816d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a8be41639d361e361bf0dced94a6816d8">inferImplicitSSAName</a> (OpAsmParser &amp;parser, NamedAttrList &amp;attrs)</td></tr>
<tr class="memdesc:a8be41639d361e361bf0dced94a6816d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that <code>attrs</code> contains a <code>name</code> attribute by inferring its value from the SSA name of the operation's first result if necessary.  <a href="namespacecirct.html#a8be41639d361e361bf0dced94a6816d8">More...</a><br /></td></tr>
<tr class="separator:a8be41639d361e361bf0dced94a6816d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabca51b288ce0412ae93af6414442ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#adabca51b288ce0412ae93af6414442ad">printImplicitSSAName</a> (OpAsmPrinter &amp;p, Operation *op, StringAttr attr)</td></tr>
<tr class="memdesc:adabca51b288ce0412ae93af6414442ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an implicit SSA name string attribute.  <a href="namespacecirct.html#adabca51b288ce0412ae93af6414442ad">More...</a><br /></td></tr>
<tr class="separator:adabca51b288ce0412ae93af6414442ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0425b842d212dd3edee7dbec17c59a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a5f0425b842d212dd3edee7dbec17c59a">printImplicitSSAName</a> (OpAsmPrinter &amp;p, Operation *op, DictionaryAttr attrs, ArrayRef&lt; StringRef &gt; extraElides={})</td></tr>
<tr class="memdesc:a5f0425b842d212dd3edee7dbec17c59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an attribute dictionary and elide the <code>name</code> field if its value matches the SSA name of the operation's first result.  <a href="namespacecirct.html#a5f0425b842d212dd3edee7dbec17c59a">More...</a><br /></td></tr>
<tr class="separator:a5f0425b842d212dd3edee7dbec17c59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c60cfe9ba173cc6034a8a516017b74a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a4c60cfe9ba173cc6034a8a516017b74a">elideImplicitSSAName</a> (OpAsmPrinter &amp;printer, Operation *op, DictionaryAttr attrs, SmallVectorImpl&lt; StringRef &gt; &amp;elides)</td></tr>
<tr class="memdesc:a4c60cfe9ba173cc6034a8a516017b74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code>name</code> attribute in <code>attrs</code> matches the SSA name of the operation's first result.  <a href="namespacecirct.html#a4c60cfe9ba173cc6034a8a516017b74a">More...</a><br /></td></tr>
<tr class="separator:a4c60cfe9ba173cc6034a8a516017b74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f76ec9a9494fd34f7f0b358963bd58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a14f76ec9a9494fd34f7f0b358963bd58">printOptionalBinaryOpTypes</a> (OpAsmPrinter &amp;p, Operation *op, Type lhs, Type rhs)</td></tr>
<tr class="memdesc:a14f76ec9a9494fd34f7f0b358963bd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print/parse binary operands type only when types are different.  <a href="namespacecirct.html#a14f76ec9a9494fd34f7f0b358963bd58">More...</a><br /></td></tr>
<tr class="separator:a14f76ec9a9494fd34f7f0b358963bd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec81fa858386cbf254b594f34e7aed69"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#aec81fa858386cbf254b594f34e7aed69">parseOptionalBinaryOpTypes</a> (OpAsmParser &amp;parser, Type &amp;lhs, Type &amp;rhs)</td></tr>
<tr class="separator:aec81fa858386cbf254b594f34e7aed69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a517eb5287f347b22bcc338f0569ad"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a14a517eb5287f347b22bcc338f0569ad">parseKeywordBool</a> (OpAsmParser &amp;parser, BoolAttr &amp;attr, StringRef trueKeyword, StringRef falseKeyword)</td></tr>
<tr class="memdesc:a14a517eb5287f347b22bcc338f0569ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a boolean as one of two keywords.  <a href="namespacecirct.html#a14a517eb5287f347b22bcc338f0569ad">More...</a><br /></td></tr>
<tr class="separator:a14a517eb5287f347b22bcc338f0569ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e45eff90b395ee15721c2fb2615b575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a5e45eff90b395ee15721c2fb2615b575">printKeywordBool</a> (OpAsmPrinter &amp;printer, Operation *op, BoolAttr attr, StringRef trueKeyword, StringRef falseKeyword)</td></tr>
<tr class="memdesc:a5e45eff90b395ee15721c2fb2615b575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a boolean as one of two keywords.  <a href="namespacecirct.html#a5e45eff90b395ee15721c2fb2615b575">More...</a><br /></td></tr>
<tr class="separator:a5e45eff90b395ee15721c2fb2615b575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17291e378f8102fedebb94060cd838b3"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a17291e378f8102fedebb94060cd838b3">debugHeader</a> (llvm::StringRef str, int <a class="el" href="FIRRTL_8cpp.html#a395d15e7c2b09961c1bfd1da6179b64c">width</a>=80)</td></tr>
<tr class="memdesc:a17291e378f8102fedebb94060cd838b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a "header"-like string to the debug stream with a certain width.  <a href="namespacecirct.html#a17291e378f8102fedebb94060cd838b3">More...</a><br /></td></tr>
<tr class="separator:a17291e378f8102fedebb94060cd838b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae031e9a7373bc6a0aaa612a429228533"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ae031e9a7373bc6a0aaa612a429228533">debugPassHeader</a> (const mlir::Pass *pass, int <a class="el" href="FIRRTL_8cpp.html#a395d15e7c2b09961c1bfd1da6179b64c">width</a>=80)</td></tr>
<tr class="memdesc:ae031e9a7373bc6a0aaa612a429228533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a boilerplate header for a pass to the debug stream.  <a href="namespacecirct.html#ae031e9a7373bc6a0aaa612a429228533">More...</a><br /></td></tr>
<tr class="separator:ae031e9a7373bc6a0aaa612a429228533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a0abe53fdab04c5b4457e9f1a530a5"><td class="memItemLeft" align="right" valign="top">llvm::raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#af5a0abe53fdab04c5b4457e9f1a530a5">debugFooter</a> (int <a class="el" href="FIRRTL_8cpp.html#a395d15e7c2b09961c1bfd1da6179b64c">width</a>=80)</td></tr>
<tr class="memdesc:af5a0abe53fdab04c5b4457e9f1a530a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a boilerplate footer to the debug stream to indicate that a pass has ended.  <a href="namespacecirct.html#af5a0abe53fdab04c5b4457e9f1a530a5">More...</a><br /></td></tr>
<tr class="separator:af5a0abe53fdab04c5b4457e9f1a530a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ce86f7290ab1b7e8dd11e3c6f18740"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a65ce86f7290ab1b7e8dd11e3c6f18740">hash_value</a> (const <a class="el" href="classcirct_1_1FieldRef.html">FieldRef</a> &amp;fieldRef)</td></tr>
<tr class="memdesc:a65ce86f7290ab1b7e8dd11e3c6f18740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a hash code for a <a class="el" href="classcirct_1_1FieldRef.html" title="This class represents a reference to a specific field or element of an aggregate value.">FieldRef</a>.  <a href="namespacecirct.html#a65ce86f7290ab1b7e8dd11e3c6f18740">More...</a><br /></td></tr>
<tr class="separator:a65ce86f7290ab1b7e8dd11e3c6f18740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5db2810fb5a0ee221fc6f9d590706a"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; APInt &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#acd5db2810fb5a0ee221fc6f9d590706a">getConstantInt</a> (Attribute operand)</td></tr>
<tr class="memdesc:acd5db2810fb5a0ee221fc6f9d590706a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the integer value of a constant operand.  <a href="namespacecirct.html#acd5db2810fb5a0ee221fc6f9d590706a">More...</a><br /></td></tr>
<tr class="separator:acd5db2810fb5a0ee221fc6f9d590706a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3045661a06fca02c977b4e38ccd8c2a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ae3045661a06fca02c977b4e38ccd8c2a">isConstantZero</a> (Attribute operand)</td></tr>
<tr class="memdesc:ae3045661a06fca02c977b4e38ccd8c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a constant operand is a zero value.  <a href="namespacecirct.html#ae3045661a06fca02c977b4e38ccd8c2a">More...</a><br /></td></tr>
<tr class="separator:ae3045661a06fca02c977b4e38ccd8c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcb6e049887b4c54e3016e34f6889d8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#afbcb6e049887b4c54e3016e34f6889d8">isConstantOne</a> (Attribute operand)</td></tr>
<tr class="memdesc:afbcb6e049887b4c54e3016e34f6889d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a constant operand is a one value.  <a href="namespacecirct.html#afbcb6e049887b4c54e3016e34f6889d8">More...</a><br /></td></tr>
<tr class="separator:afbcb6e049887b4c54e3016e34f6889d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b41a94e59fb70245e61fba51c4c5c7"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#aa1b41a94e59fb70245e61fba51c4c5c7">convertAttributeToJSON</a> (llvm::json::OStream &amp;json, Attribute attr)</td></tr>
<tr class="memdesc:aa1b41a94e59fb70245e61fba51c4c5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a simple attribute to JSON.  <a href="namespacecirct.html#aa1b41a94e59fb70245e61fba51c4c5c7">More...</a><br /></td></tr>
<tr class="separator:aa1b41a94e59fb70245e61fba51c4c5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0c0300e4eddbfeef59a7696d469f86"><td class="memItemLeft" align="right" valign="top">Attribute&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a1d0c0300e4eddbfeef59a7696d469f86">convertJSONToAttribute</a> (MLIRContext *context, llvm::json::Value &amp;value, llvm::json::Path p)</td></tr>
<tr class="memdesc:a1d0c0300e4eddbfeef59a7696d469f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert arbitrary JSON to an MLIR Attribute.  <a href="namespacecirct.html#a1d0c0300e4eddbfeef59a7696d469f86">More...</a><br /></td></tr>
<tr class="separator:a1d0c0300e4eddbfeef59a7696d469f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673a2179bef14bddbb26126af51af5d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a673a2179bef14bddbb26126af51af5d5">isUselessName</a> (StringRef name)</td></tr>
<tr class="memdesc:a673a2179bef14bddbb26126af51af5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a possibly useless temporary name.  <a href="namespacecirct.html#a673a2179bef14bddbb26126af51af5d5">More...</a><br /></td></tr>
<tr class="separator:a673a2179bef14bddbb26126af51af5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13297d900dfc6cc1da3f566e5965c52"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ae13297d900dfc6cc1da3f566e5965c52">chooseName</a> (StringRef a, StringRef b)</td></tr>
<tr class="memdesc:ae13297d900dfc6cc1da3f566e5965c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose a good name for an item from two options.  <a href="namespacecirct.html#ae13297d900dfc6cc1da3f566e5965c52">More...</a><br /></td></tr>
<tr class="separator:ae13297d900dfc6cc1da3f566e5965c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d5f5209621fb70af4387fb49703438"><td class="memItemLeft" align="right" valign="top">StringAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a53d5f5209621fb70af4387fb49703438">chooseName</a> (StringAttr a, StringAttr b)</td></tr>
<tr class="memdesc:a53d5f5209621fb70af4387fb49703438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose a good name for an item from two options.  <a href="namespacecirct.html#a53d5f5209621fb70af4387fb49703438">More...</a><br /></td></tr>
<tr class="separator:a53d5f5209621fb70af4387fb49703438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a36a13343224fde564b21c59fb2621"><td class="memItemLeft" align="right" valign="top">StringAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a49a36a13343224fde564b21c59fb2621">chooseName</a> (Operation *a, Operation *b)</td></tr>
<tr class="memdesc:a49a36a13343224fde564b21c59fb2621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose the better name between two ops.  <a href="namespacecirct.html#a49a36a13343224fde564b21c59fb2621">More...</a><br /></td></tr>
<tr class="separator:a49a36a13343224fde564b21c59fb2621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c7d0bc617af07d541245f1dd05cd8f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ac6c7d0bc617af07d541245f1dd05cd8f">createSimpleCanonicalizerPass</a> ()</td></tr>
<tr class="memdesc:ac6c7d0bc617af07d541245f1dd05cd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a simple canonicalizer pass.  <a href="namespacecirct.html#ac6c7d0bc617af07d541245f1dd05cd8f">More...</a><br /></td></tr>
<tr class="separator:ac6c7d0bc617af07d541245f1dd05cd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4941ed74ad92b2fabdad18da837748b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ad4941ed74ad92b2fabdad18da837748b">appendPossiblyAbsolutePath</a> (llvm::SmallVectorImpl&lt; char &gt; &amp;base, const llvm::Twine &amp;suffix)</td></tr>
<tr class="memdesc:ad4941ed74ad92b2fabdad18da837748b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a path to an existing path, replacing it if the other path is absolute.  <a href="namespacecirct.html#ad4941ed74ad92b2fabdad18da837748b">More...</a><br /></td></tr>
<tr class="separator:ad4941ed74ad92b2fabdad18da837748b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e64fab2873a9eb8cafa2b7724ff7c86"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a5e64fab2873a9eb8cafa2b7724ff7c86">getCirctVersion</a> ()</td></tr>
<tr class="separator:a5e64fab2873a9eb8cafa2b7724ff7c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9504326c33dc9cce5e8e5b2f8ed061"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ade9504326c33dc9cce5e8e5b2f8ed061">getCirctVersionComment</a> ()</td></tr>
<tr class="separator:ade9504326c33dc9cce5e8e5b2f8ed061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594c9b1dc63c6e132dc608f6560650e7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a594c9b1dc63c6e132dc608f6560650e7">createMapArithToCombPass</a> ()</td></tr>
<tr class="separator:a594c9b1dc63c6e132dc608f6560650e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fd0bbd6f301e89241477a85244ff50"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a83fd0bbd6f301e89241477a85244ff50">createFlattenMemRefPass</a> ()</td></tr>
<tr class="separator:a83fd0bbd6f301e89241477a85244ff50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade81793059ca5b9b3f5d98d00691d5a6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ade81793059ca5b9b3f5d98d00691d5a6">createFlattenMemRefCallsPass</a> ()</td></tr>
<tr class="separator:ade81793059ca5b9b3f5d98d00691d5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d8cc9602171c3edfd90ced14e56ef5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ae9d8cc9602171c3edfd90ced14e56ef5">createStripDebugInfoWithPredPass</a> (const std::function&lt; bool(mlir::Location)&gt; &amp;pred)</td></tr>
<tr class="memdesc:ae9d8cc9602171c3edfd90ced14e56ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to strip debug information from a function.  <a href="namespacecirct.html#ae9d8cc9602171c3edfd90ced14e56ef5">More...</a><br /></td></tr>
<tr class="separator:ae9d8cc9602171c3edfd90ced14e56ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0931e26dbfc0949ad5e165f9b8786a56"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; mlir::Pass &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a0931e26dbfc0949ad5e165f9b8786a56">createMaximizeSSAPass</a> ()</td></tr>
<tr class="separator:a0931e26dbfc0949ad5e165f9b8786a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d52e2db9a6d4700931878bb739ad46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a97d52e2db9a6d4700931878bb739ad46">isUniDimensional</a> (mlir::MemRefType memref)</td></tr>
<tr class="separator:a97d52e2db9a6d4700931878bb739ad46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add007169bb350f7d7b3ffae39b62f4b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#add007169bb350f7d7b3ffae39b62f4b2">isRegionSSAMaximized</a> (Region &amp;region)</td></tr>
<tr class="separator:add007169bb350f7d7b3ffae39b62f4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e86e04af3966613857cdfe6edc585e3"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a7e86e04af3966613857cdfe6edc585e3">maximizeSSA</a> (Value value, PatternRewriter &amp;rewriter)</td></tr>
<tr class="memdesc:a7e86e04af3966613857cdfe6edc585e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a single value within a function into maximal SSA form.  <a href="namespacecirct.html#a7e86e04af3966613857cdfe6edc585e3">More...</a><br /></td></tr>
<tr class="separator:a7e86e04af3966613857cdfe6edc585e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05aa448f25e98193376ff79340d95c9"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#ad05aa448f25e98193376ff79340d95c9">maximizeSSA</a> (Operation *op, <a class="el" href="classcirct_1_1SSAMaximizationStrategy.html">SSAMaximizationStrategy</a> &amp;strategy, PatternRewriter &amp;rewriter)</td></tr>
<tr class="memdesc:ad05aa448f25e98193376ff79340d95c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Considers all of an operation's results for SSA maximization, following a provided strategy.  <a href="namespacecirct.html#ad05aa448f25e98193376ff79340d95c9">More...</a><br /></td></tr>
<tr class="separator:ad05aa448f25e98193376ff79340d95c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5f201f727afb566d3a659c0ee08744"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#afb5f201f727afb566d3a659c0ee08744">maximizeSSA</a> (Block *block, <a class="el" href="classcirct_1_1SSAMaximizationStrategy.html">SSAMaximizationStrategy</a> &amp;strategy, PatternRewriter &amp;rewriter)</td></tr>
<tr class="memdesc:afb5f201f727afb566d3a659c0ee08744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Considers all values defined by a block (i.e., block arguments and operation results within the block) for SSA maximization, following a provided strategy.  <a href="namespacecirct.html#afb5f201f727afb566d3a659c0ee08744">More...</a><br /></td></tr>
<tr class="separator:afb5f201f727afb566d3a659c0ee08744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2eeb7e1f89db7656f7722c5538054e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a4e2eeb7e1f89db7656f7722c5538054e">maximizeSSA</a> (Region &amp;region, <a class="el" href="classcirct_1_1SSAMaximizationStrategy.html">SSAMaximizationStrategy</a> &amp;strategy, PatternRewriter &amp;rewriter)</td></tr>
<tr class="memdesc:a4e2eeb7e1f89db7656f7722c5538054e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Considers all blocks within a region for SSA maximization, following a provided strategy.  <a href="namespacecirct.html#a4e2eeb7e1f89db7656f7722c5538054e">More...</a><br /></td></tr>
<tr class="separator:a4e2eeb7e1f89db7656f7722c5538054e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a29aefc14513714bc25c652c863f6e533"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecirct.html#a29aefc14513714bc25c652c863f6e533">circtBugReportMsg</a></td></tr>
<tr class="memdesc:a29aefc14513714bc25c652c863f6e533"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic bug report message for CIRCT-related projects.  <a href="namespacecirct.html#a29aefc14513714bc25c652c863f6e533">More...</a><br /></td></tr>
<tr class="separator:a29aefc14513714bc25c652c863f6e533"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file defines an intermediate representation for circuits acting as an abstraction for constraints defined over an SMT's solver context. </p>
<p>The InstanceGraph op interface, see InstanceGraphInterface.td for more details.</p>
<p>This file defines a SMT solver interface for the <code>circt-lec</code> tool.</p>
<p>This file defines the logic-exporting class for the <code>circt-lec</code> tool. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ad4941ed74ad92b2fabdad18da837748b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4941ed74ad92b2fabdad18da837748b">&#9670;&nbsp;</a></span>appendPossiblyAbsolutePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::appendPossiblyAbsolutePath </td>
          <td>(</td>
          <td class="paramtype">llvm::SmallVectorImpl&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Twine &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a path to an existing path, replacing it if the other path is absolute. </p>
<p>This mimicks the behaviour of <code>foo/bar</code> and <code>/foo/bar</code> being used in a working directory <code>/home</code>, resulting in <code>/home/foo/bar</code> and <code>/foo/bar</code>, respectively. </p>

<p class="definition">Definition at line <a class="el" href="Path_8cpp_source.html#l00023">23</a> of file <a class="el" href="Path_8cpp_source.html">Path.cpp</a>.</p>

<p class="reference">References <a class="el" href="PortConverter_8cpp_source.html#l00017">append()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html#l06646">createOutputFile()</a>, and <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html#l06161">circt::ExportVerilog::SharedEmitterState::gatherFiles()</a>.</p>

</div>
</div>
<a id="a49a36a13343224fde564b21c59fb2621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a36a13343224fde564b21c59fb2621">&#9670;&nbsp;</a></span>chooseName() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringAttr circt::chooseName </td>
          <td>(</td>
          <td class="paramtype">Operation *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose the better name between two ops. </p>
<p>Picks the "name" attribute as first preference, using "sv.namehint" as an alternative. </p>

<p class="definition">Definition at line <a class="el" href="Naming_8cpp_source.html#l00066">66</a> of file <a class="el" href="Naming_8cpp_source.html">Naming.cpp</a>.</p>

<p class="reference">References <a class="el" href="Naming_8cpp_source.html#l00047">chooseName()</a>, and <a class="el" href="Naming_8cpp_source.html#l00059">getNameOrHint()</a>.</p>

</div>
</div>
<a id="a53d5f5209621fb70af4387fb49703438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d5f5209621fb70af4387fb49703438">&#9670;&nbsp;</a></span>chooseName() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringAttr circt::chooseName </td>
          <td>(</td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose a good name for an item from two options. </p>

<p class="definition">Definition at line <a class="el" href="Naming_8cpp_source.html#l00051">51</a> of file <a class="el" href="Naming_8cpp_source.html">Naming.cpp</a>.</p>

<p class="reference">References <a class="el" href="Naming_8cpp_source.html#l00027">isNameBetter()</a>.</p>

</div>
</div>
<a id="ae13297d900dfc6cc1da3f566e5965c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13297d900dfc6cc1da3f566e5965c52">&#9670;&nbsp;</a></span>chooseName() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef circt::chooseName </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose a good name for an item from two options. </p>

<p class="definition">Definition at line <a class="el" href="Naming_8cpp_source.html#l00047">47</a> of file <a class="el" href="Naming_8cpp_source.html">Naming.cpp</a>.</p>

<p class="reference">References <a class="el" href="Naming_8cpp_source.html#l00027">isNameBetter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Naming_8cpp_source.html#l00066">chooseName()</a>, and <a class="el" href="FIRRTLFolds_8cpp_source.html#l00091">updateName()</a>.</p>

</div>
</div>
<a id="aa1b41a94e59fb70245e61fba51c4c5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b41a94e59fb70245e61fba51c4c5c7">&#9670;&nbsp;</a></span>convertAttributeToJSON()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult circt::convertAttributeToJSON </td>
          <td>(</td>
          <td class="paramtype">llvm::json::OStream &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Attribute&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a simple attribute to JSON. </p>

<p class="definition">Definition at line <a class="el" href="JSON_8cpp_source.html#l00023">23</a> of file <a class="el" href="JSON_8cpp_source.html">JSON.cpp</a>.</p>

</div>
</div>
<a id="a1d0c0300e4eddbfeef59a7696d469f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0c0300e4eddbfeef59a7696d469f86">&#9670;&nbsp;</a></span>convertJSONToAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Attribute circt::convertJSONToAttribute </td>
          <td>(</td>
          <td class="paramtype">MLIRContext *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::json::Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::json::Path&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert arbitrary JSON to an MLIR Attribute. </p>

</div>
</div>
<a id="ac84e30e51c8bb7f99590767a99ac0161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84e30e51c8bb7f99590767a99ac0161">&#9670;&nbsp;</a></span>createAffineToLoopSchedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createAffineToLoopSchedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineToLoopSchedule_8cpp_source.html#l00646">646</a> of file <a class="el" href="AffineToLoopSchedule_8cpp_source.html">AffineToLoopSchedule.cpp</a>.</p>

</div>
</div>
<a id="a3edc03584607447773267c1791edc0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3edc03584607447773267c1791edc0b1">&#9670;&nbsp;</a></span>createCalyxNativePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createCalyxNativePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CalyxNative_8cpp_source.html#l00163">163</a> of file <a class="el" href="CalyxNative_8cpp_source.html">CalyxNative.cpp</a>.</p>

</div>
</div>
<a id="a011024697ebd49e412ef36ee5259e048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011024697ebd49e412ef36ee5259e048">&#9670;&nbsp;</a></span>createCalyxToFSMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createCalyxToFSMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CalyxToFSM_8cpp_source.html#l00402">402</a> of file <a class="el" href="CalyxToFSM_8cpp_source.html">CalyxToFSM.cpp</a>.</p>

</div>
</div>
<a id="a7dfcfa6773667451344ece7a62fcc079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfcfa6773667451344ece7a62fcc079">&#9670;&nbsp;</a></span>createCalyxToHWPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createCalyxToHWPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CalyxToHW_8cpp_source.html#l00481">481</a> of file <a class="el" href="CalyxToHW_8cpp_source.html">CalyxToHW.cpp</a>.</p>

</div>
</div>
<a id="a895098b1bbb91ce21d30693715d75389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895098b1bbb91ce21d30693715d75389">&#9670;&nbsp;</a></span>createCFToHandshakePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; mlir::ModuleOp &gt; &gt; circt::createCFToHandshakePass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sourceConstants</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disableTaskPipelining</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CFToHandshake_8cpp_source.html#l01755">1755</a> of file <a class="el" href="CFToHandshake_8cpp_source.html">CFToHandshake.cpp</a>.</p>

</div>
</div>
<a id="aad6e347007a741999cc0fdca1454a05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6e347007a741999cc0fdca1454a05d">&#9670;&nbsp;</a></span>createConvertCombToArithPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; circt::createConvertCombToArithPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CombToArith_8cpp_source.html#l00315">315</a> of file <a class="el" href="CombToArith_8cpp_source.html">CombToArith.cpp</a>.</p>

</div>
</div>
<a id="a03b260d113fe932da95d9e88ad5931fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b260d113fe932da95d9e88ad5931fe">&#9670;&nbsp;</a></span>createConvertFSMToSVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createConvertFSMToSVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FSMToSV_8cpp_source.html#l00743">743</a> of file <a class="el" href="FSMToSV_8cpp_source.html">FSMToSV.cpp</a>.</p>

</div>
</div>
<a id="ac7417f55cb2abe15561d63db25cbbb30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7417f55cb2abe15561d63db25cbbb30">&#9670;&nbsp;</a></span>createConvertHWToBTOR2Pass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createConvertHWToBTOR2Pass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="HWToBTOR2_8cpp_source.html#l00961">961</a> of file <a class="el" href="HWToBTOR2_8cpp_source.html">HWToBTOR2.cpp</a>.</p>

<p class="reference">References <a class="el" href="Utility_8h_source.html#l00038">lec::outs()</a>.</p>

</div>
</div>
<a id="a661555bc389408e1b25cc04e91945d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661555bc389408e1b25cc04e91945d05">&#9670;&nbsp;</a></span>createConvertHWToBTOR2Pass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createConvertHWToBTOR2Pass </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="HWToBTOR2_8cpp_source.html#l00956">956</a> of file <a class="el" href="HWToBTOR2_8cpp_source.html">HWToBTOR2.cpp</a>.</p>

</div>
</div>
<a id="a34b2eb633f3a36e50550baeb8a5873f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b2eb633f3a36e50550baeb8a5873f8">&#9670;&nbsp;</a></span>createConvertHWToLLHDPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; circt::createConvertHWToLLHDPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a HW to LLHD conversion pass. </p>

<p class="definition">Definition at line <a class="el" href="HWToLLHD_8cpp_source.html#l00285">285</a> of file <a class="el" href="HWToLLHD_8cpp_source.html">HWToLLHD.cpp</a>.</p>

</div>
</div>
<a id="a1c0b6b357fb1d81f37be00747d21b031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0b6b357fb1d81f37be00747d21b031">&#9670;&nbsp;</a></span>createConvertHWToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; circt::createConvertHWToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an HW to LLVM conversion pass. </p>

<p class="definition">Definition at line <a class="el" href="HWToLLVM_8cpp_source.html#l00690">690</a> of file <a class="el" href="HWToLLVM_8cpp_source.html">HWToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a100e5eda876a13295d188c96d8760d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100e5eda876a13295d188c96d8760d0f">&#9670;&nbsp;</a></span>createConvertHWToSystemCPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; circt::createConvertHWToSystemCPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a HW to SystemC dialects conversion pass. </p>

<p class="definition">Definition at line <a class="el" href="HWToSystemC_8cpp_source.html#l00338">338</a> of file <a class="el" href="HWToSystemC_8cpp_source.html">HWToSystemC.cpp</a>.</p>

</div>
</div>
<a id="a9f03349b31a601f5baadc173fdd3843b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f03349b31a601f5baadc173fdd3843b">&#9670;&nbsp;</a></span>createConvertLLHDToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; circt::createConvertLLHDToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an LLHD to LLVM conversion pass. </p>

<p class="definition">Definition at line <a class="el" href="LLHDToLLVM_8cpp_source.html#l01926">1926</a> of file <a class="el" href="LLHDToLLVM_8cpp_source.html">LLHDToLLVM.cpp</a>.</p>

</div>
</div>
<a id="aa9ff05c0734850ae85e7aab67bc32fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ff05c0734850ae85e7aab67bc32fdc">&#9670;&nbsp;</a></span>createConvertMooreToCorePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; circt::createConvertMooreToCorePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an Moore to Comb/HW/LLHD conversion pass. </p>
<p>Create a Moore to core dialects conversion pass. </p>

<p class="definition">Definition at line <a class="el" href="MooreToCore_8cpp_source.html#l00313">313</a> of file <a class="el" href="MooreToCore_8cpp_source.html">MooreToCore.cpp</a>.</p>

</div>
</div>
<a id="a3e92dfead270741ef9127e9324f2208b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e92dfead270741ef9127e9324f2208b">&#9670;&nbsp;</a></span>createConvertToArcsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; circt::createConvertToArcsPass </td>
          <td>(</td>
          <td class="paramtype">const ConvertToArcsOptions &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConvertToArcs_8cpp_source.html#l00459">459</a> of file <a class="el" href="ConvertToArcs_8cpp_source.html">ConvertToArcs.cpp</a>.</p>

</div>
</div>
<a id="ab6adb8c10b38b0be83bf41c4e1b04333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6adb8c10b38b0be83bf41c4e1b04333">&#9670;&nbsp;</a></span>createDCToHWPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createDCToHWPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DCToHW_8cpp_source.html#l00865">865</a> of file <a class="el" href="DCToHW_8cpp_source.html">DCToHW.cpp</a>.</p>

</div>
</div>
<a id="ad3eabfa1662055b499aa587a0b3c01f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3eabfa1662055b499aa587a0b3c01f3">&#9670;&nbsp;</a></span>createExportChiselInterfacePass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createExportChiselInterfacePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExportChiselInterface_8cpp_source.html#l00319">319</a> of file <a class="el" href="ExportChiselInterface_8cpp_source.html">ExportChiselInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="ExportChiselInterface_8cpp_source.html#l00310">createExportChiselInterfacePass()</a>, and <a class="el" href="Utility_8h_source.html#l00038">lec::outs()</a>.</p>

</div>
</div>
<a id="a5bdc38d1b7670ad39780cd57bcb371de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdc38d1b7670ad39780cd57bcb371de">&#9670;&nbsp;</a></span>createExportChiselInterfacePass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createExportChiselInterfacePass </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExportChiselInterface_8cpp_source.html#l00310">310</a> of file <a class="el" href="ExportChiselInterface_8cpp_source.html">ExportChiselInterface.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExportChiselInterface_8cpp_source.html#l00319">createExportChiselInterfacePass()</a>, and <a class="el" href="Firtool_2Firtool_8cpp_source.html#l00048">circt::firtool::populateCHIRRTLToLowFIRRTL()</a>.</p>

</div>
</div>
<a id="a1d644b0af607b8714198cf0de99ac213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d644b0af607b8714198cf0de99ac213">&#9670;&nbsp;</a></span>createExportSplitChiselInterfacePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createExportSplitChiselInterfacePass </td>
          <td>(</td>
          <td class="paramtype">mlir::StringRef&#160;</td>
          <td class="paramname"><em>outputDirectory</em> = <code>&quot;./&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ExportChiselInterface_8cpp_source.html#l00315">315</a> of file <a class="el" href="ExportChiselInterface_8cpp_source.html">ExportChiselInterface.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Firtool_2Firtool_8cpp_source.html#l00048">circt::firtool::populateCHIRRTLToLowFIRRTL()</a>.</p>

</div>
</div>
<a id="a611a14d3fb8514edda384b51998d7427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611a14d3fb8514edda384b51998d7427">&#9670;&nbsp;</a></span>createExportSplitVerilogPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;mlir::Pass&gt; circt::createExportSplitVerilogPass </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>directory</em> = <code>&quot;./&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="Firtool_2Firtool_8cpp_source.html#l00361">circt::firtool::populateExportSplitVerilog()</a>.</p>

</div>
</div>
<a id="ad45dfc223465e0e8b4728b760adb2664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45dfc223465e0e8b4728b760adb2664">&#9670;&nbsp;</a></span>createExportVerilogPass() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createExportVerilogPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html#l06637">6637</a> of file <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html">ExportVerilog.cpp</a>.</p>

<p class="reference">References <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html#l06628">createExportVerilogPass()</a>, and <a class="el" href="Utility_8h_source.html#l00038">lec::outs()</a>.</p>

</div>
</div>
<a id="adc15088c1b5bfd5c566c4b309a26458b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc15088c1b5bfd5c566c4b309a26458b">&#9670;&nbsp;</a></span>createExportVerilogPass() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createExportVerilogPass </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html#l06633">6633</a> of file <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html">ExportVerilog.cpp</a>.</p>

</div>
</div>
<a id="a5ae996c248ae7cb3f8ffb344d84022f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae996c248ae7cb3f8ffb344d84022f3">&#9670;&nbsp;</a></span>createExportVerilogPass() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createExportVerilogPass </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; llvm::raw_ostream &gt;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html#l06628">6628</a> of file <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html">ExportVerilog.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html#l06637">createExportVerilogPass()</a>, and <a class="el" href="Firtool_2Firtool_8cpp_source.html#l00342">circt::firtool::populateExportVerilog()</a>.</p>

</div>
</div>
<a id="ade81793059ca5b9b3f5d98d00691d5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade81793059ca5b9b3f5d98d00691d5a6">&#9670;&nbsp;</a></span>createFlattenMemRefCallsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createFlattenMemRefCallsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FlattenMemRefs_8cpp_source.html#l00377">377</a> of file <a class="el" href="FlattenMemRefs_8cpp_source.html">FlattenMemRefs.cpp</a>.</p>

</div>
</div>
<a id="a83fd0bbd6f301e89241477a85244ff50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83fd0bbd6f301e89241477a85244ff50">&#9670;&nbsp;</a></span>createFlattenMemRefPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createFlattenMemRefPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FlattenMemRefs_8cpp_source.html#l00373">373</a> of file <a class="el" href="FlattenMemRefs_8cpp_source.html">FlattenMemRefs.cpp</a>.</p>

</div>
</div>
<a id="aa894b775b2e21df1a6adf14c639c3afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa894b775b2e21df1a6adf14c639c3afe">&#9670;&nbsp;</a></span>createHandshakeAnalysisPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt;mlir::ModuleOp&gt; &gt; circt::createHandshakeAnalysisPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af02e04be8495987ff76ba0f791038512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02e04be8495987ff76ba0f791038512">&#9670;&nbsp;</a></span>createHandshakeCanonicalizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt;handshake::FuncOp&gt; &gt; circt::createHandshakeCanonicalizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe33fafaca8cb3676572fbeceba838e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe33fafaca8cb3676572fbeceba838e4">&#9670;&nbsp;</a></span>createHandshakeRemoveBlockPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">mlir::OperationPass</a>&lt; handshake::FuncOp &gt; &gt; circt::createHandshakeRemoveBlockPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CFToHandshake_8cpp_source.html#l01762">1762</a> of file <a class="el" href="CFToHandshake_8cpp_source.html">CFToHandshake.cpp</a>.</p>

</div>
</div>
<a id="af10ff85e83d8cd6f6709399cd6dd086e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10ff85e83d8cd6f6709399cd6dd086e">&#9670;&nbsp;</a></span>createHandshakeToDCPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createHandshakeToDCPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="HandshakeToDC_8cpp_source.html#l00567">567</a> of file <a class="el" href="HandshakeToDC_8cpp_source.html">HandshakeToDC.cpp</a>.</p>

</div>
</div>
<a id="a39829130f4b027047ee6947a204add3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39829130f4b027047ee6947a204add3f">&#9670;&nbsp;</a></span>createHandshakeToHWPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createHandshakeToHWPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="HandshakeToHW_8cpp_source.html#l01974">1974</a> of file <a class="el" href="HandshakeToHW_8cpp_source.html">HandshakeToHW.cpp</a>.</p>

</div>
</div>
<a id="ae5aa1edf0c24af2035aef5e3dc8e4e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5aa1edf0c24af2035aef5e3dc8e4e2e">&#9670;&nbsp;</a></span>createHWArithToHWPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; Pass &gt; circt::createHWArithToHWPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="HWArithToHW_8cpp_source.html#l00445">445</a> of file <a class="el" href="HWArithToHW_8cpp_source.html">HWArithToHW.cpp</a>.</p>

</div>
</div>
<a id="a0d19dc78501d41e2c31e18f387f786d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d19dc78501d41e2c31e18f387f786d3">&#9670;&nbsp;</a></span>createHWLowerInstanceChoicesPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createHWLowerInstanceChoicesPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="HWLowerInstanceChoices_8cpp_source.html#l00109">109</a> of file <a class="el" href="HWLowerInstanceChoices_8cpp_source.html">HWLowerInstanceChoices.cpp</a>.</p>

</div>
</div>
<a id="a2ad9e087642b4c838c212e5b3c0d1c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad9e087642b4c838c212e5b3c0d1c9b">&#9670;&nbsp;</a></span>createInsertMergeBlocksPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createInsertMergeBlocksPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InsertMergeBlocks_8cpp_source.html#l00370">370</a> of file <a class="el" href="InsertMergeBlocks_8cpp_source.html">InsertMergeBlocks.cpp</a>.</p>

</div>
</div>
<a id="ab8439a734e7d96453aa4ba13a9fc8591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8439a734e7d96453aa4ba13a9fc8591">&#9670;&nbsp;</a></span>createLegalizeAnonEnumsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createLegalizeAnonEnumsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LegalizeAnonEnums_8cpp_source.html#l00203">203</a> of file <a class="el" href="LegalizeAnonEnums_8cpp_source.html">LegalizeAnonEnums.cpp</a>.</p>

</div>
</div>
<a id="a479c780b69e919e7aeeef1d0b71f9756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479c780b69e919e7aeeef1d0b71f9756">&#9670;&nbsp;</a></span>createLoopScheduleToCalyxPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; circt::createLoopScheduleToCalyxPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a LoopSchedule to Calyx conversion pass. </p>

<p class="definition">Definition at line <a class="el" href="LoopScheduleToCalyx_8cpp_source.html#l01666">1666</a> of file <a class="el" href="LoopScheduleToCalyx_8cpp_source.html">LoopScheduleToCalyx.cpp</a>.</p>

</div>
</div>
<a id="ac60845b4a17984b09d46bc1b38627a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60845b4a17984b09d46bc1b38627a80">&#9670;&nbsp;</a></span>createLowerArcToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; circt::createLowerArcToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LowerArcToLLVM_8cpp_source.html#l00655">655</a> of file <a class="el" href="LowerArcToLLVM_8cpp_source.html">LowerArcToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a8634f7165e95a98e4d478e89f4518657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8634f7165e95a98e4d478e89f4518657">&#9670;&nbsp;</a></span>createLowerFirMemPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; Pass &gt; circt::createLowerFirMemPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LowerFirMem_8cpp_source.html#l00084">84</a> of file <a class="el" href="LowerFirMem_8cpp_source.html">LowerFirMem.cpp</a>.</p>

</div>
</div>
<a id="a1ef8652b25c8a19be150b3d6c7ac9e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef8652b25c8a19be150b3d6c7ac9e78">&#9670;&nbsp;</a></span>createLowerFIRRTLToHWPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createLowerFIRRTLToHWPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableAnnotationWarning</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emitChiselAssertsAsSVA</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the pass constructor. </p>

<p class="definition">Definition at line <a class="el" href="LowerToHW_8cpp_source.html#l00582">582</a> of file <a class="el" href="LowerToHW_8cpp_source.html">LowerToHW.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Firtool_2Firtool_8cpp_source.html#l00227">circt::firtool::populateLowFIRRTLToHW()</a>.</p>

</div>
</div>
<a id="ae138488e420858a784e24bfc9ea9ec55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae138488e420858a784e24bfc9ea9ec55">&#9670;&nbsp;</a></span>createLowerHWToSVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classhw_1_1HWModuleOp.html">hw::HWModuleOp</a> &gt; &gt; circt::createLowerHWToSVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="HWToSV_8cpp_source.html#l00081">81</a> of file <a class="el" href="HWToSV_8cpp_source.html">HWToSV.cpp</a>.</p>

</div>
</div>
<a id="a122bde706550dc471f256d819643c674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122bde706550dc471f256d819643c674">&#9670;&nbsp;</a></span>createLowerSeqFIRRTLInitToSV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;mlir::Pass&gt; circt::createLowerSeqFIRRTLInitToSV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cb7a7ce775f1580189a464c437bfc47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb7a7ce775f1580189a464c437bfc47">&#9670;&nbsp;</a></span>createLowerSeqToSVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; Pass &gt; circt::createLowerSeqToSVPass </td>
          <td>(</td>
          <td class="paramtype">const LowerSeqToSVOptions &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SeqToSV_8cpp_source.html#l00633">633</a> of file <a class="el" href="SeqToSV_8cpp_source.html">SeqToSV.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Firtool_2Firtool_8cpp_source.html#l00260">circt::firtool::populateHWToSV()</a>.</p>

</div>
</div>
<a id="ac595a5ae4980e2eb97e2d4c0271bd080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac595a5ae4980e2eb97e2d4c0271bd080">&#9670;&nbsp;</a></span>createLowerSimToSVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; Pass &gt; circt::createLowerSimToSVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SimToSV_8cpp_source.html#l00206">206</a> of file <a class="el" href="SimToSV_8cpp_source.html">SimToSV.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Firtool_2Firtool_8cpp_source.html#l00260">circt::firtool::populateHWToSV()</a>.</p>

</div>
</div>
<a id="a6840c1ef8f8f0c4966bc105246f316db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6840c1ef8f8f0c4966bc105246f316db">&#9670;&nbsp;</a></span>createLowerVerifToSVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; <a class="el" href="classhw_1_1HWModuleOp.html">hw::HWModuleOp</a> &gt; &gt; circt::createLowerVerifToSVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the Verif to SV conversion pass. </p>

<p class="definition">Definition at line <a class="el" href="VerifToSV_8cpp_source.html#l00153">153</a> of file <a class="el" href="VerifToSV_8cpp_source.html">VerifToSV.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Firtool_2Firtool_8cpp_source.html#l00260">circt::firtool::populateHWToSV()</a>.</p>

</div>
</div>
<a id="a594c9b1dc63c6e132dc608f6560650e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594c9b1dc63c6e132dc608f6560650e7">&#9670;&nbsp;</a></span>createMapArithToCombPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createMapArithToCombPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MapArithToComb_8cpp_source.html#l00188">188</a> of file <a class="el" href="MapArithToComb_8cpp_source.html">MapArithToComb.cpp</a>.</p>

</div>
</div>
<a id="a943e8d5476ac817f8dcf3d4db3d236b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943e8d5476ac817f8dcf3d4db3d236b9">&#9670;&nbsp;</a></span>createMaterializeCalyxToFSMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createMaterializeCalyxToFSMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MaterializeFSM_8cpp_source.html#l00242">242</a> of file <a class="el" href="MaterializeFSM_8cpp_source.html">MaterializeFSM.cpp</a>.</p>

</div>
</div>
<a id="a0931e26dbfc0949ad5e165f9b8786a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0931e26dbfc0949ad5e165f9b8786a56">&#9670;&nbsp;</a></span>createMaximizeSSAPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createMaximizeSSAPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MaximizeSSA_8cpp_source.html#l00242">242</a> of file <a class="el" href="MaximizeSSA_8cpp_source.html">MaximizeSSA.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="IbisPassPipelines_8cpp_source.html#l00041">circt::ibis::loadIbisHighLevelPassPipeline()</a>.</p>

</div>
</div>
<a id="a6a151146531a7869a94a38dc2e77f8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a151146531a7869a94a38dc2e77f8ae">&#9670;&nbsp;</a></span>createPipelineToHWPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createPipelineToHWPass </td>
          <td>(</td>
          <td class="paramtype">const PipelineToHWOptions &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an SCF to Calyx conversion pass. </p>

<p class="definition">Definition at line <a class="el" href="PipelineToHW_8cpp_source.html#l00499">499</a> of file <a class="el" href="PipelineToHW_8cpp_source.html">PipelineToHW.cpp</a>.</p>

</div>
</div>
<a id="adca653a43a6325cdd2fdeca576f9b8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca653a43a6325cdd2fdeca576f9b8b4">&#9670;&nbsp;</a></span>createPrepareForEmissionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createPrepareForEmissionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PrepareForEmission_8cpp_source.html#l01279">1279</a> of file <a class="el" href="PrepareForEmission_8cpp_source.html">PrepareForEmission.cpp</a>.</p>

</div>
</div>
<a id="a03f284eeeb2471adca9113c7419cc5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f284eeeb2471adca9113c7419cc5fe">&#9670;&nbsp;</a></span>createRemoveGroupsFromFSMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createRemoveGroupsFromFSMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="RemoveGroupsFromFSM_8cpp_source.html#l00308">308</a> of file <a class="el" href="RemoveGroupsFromFSM_8cpp_source.html">RemoveGroupsFromFSM.cpp</a>.</p>

</div>
</div>
<a id="acaeb016225c004e9768edb7af6a0a5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaeb016225c004e9768edb7af6a0a5e6">&#9670;&nbsp;</a></span>createSCFToCalyxPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; ModuleOp &gt; &gt; circt::createSCFToCalyxPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an SCF to Calyx conversion pass. </p>

<p class="definition">Definition at line <a class="el" href="SCFToCalyx_8cpp_source.html#l01867">1867</a> of file <a class="el" href="SCFToCalyx_8cpp_source.html">SCFToCalyx.cpp</a>.</p>

</div>
</div>
<a id="ac6c7d0bc617af07d541245f1dd05cd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c7d0bc617af07d541245f1dd05cd8f">&#9670;&nbsp;</a></span>createSimpleCanonicalizerPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; Pass &gt; circt::createSimpleCanonicalizerPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a simple canonicalizer pass. </p>

<p class="definition">Definition at line <a class="el" href="Support_2Passes_8cpp_source.html#l00015">15</a> of file <a class="el" href="Support_2Passes_8cpp_source.html">Passes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Firtool_2Firtool_8cpp_source.html#l00048">circt::firtool::populateCHIRRTLToLowFIRRTL()</a>, <a class="el" href="Firtool_2Firtool_8cpp_source.html#l00260">circt::firtool::populateHWToSV()</a>, and <a class="el" href="Firtool_2Firtool_8cpp_source.html#l00227">circt::firtool::populateLowFIRRTLToHW()</a>.</p>

</div>
</div>
<a id="ae9d8cc9602171c3edfd90ced14e56ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d8cc9602171c3edfd90ced14e56ef5">&#9670;&nbsp;</a></span>createStripDebugInfoWithPredPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; Pass &gt; circt::createStripDebugInfoWithPredPass </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(mlir::Location)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to strip debug information from a function. </p>

<p class="definition">Definition at line <a class="el" href="StripDebugInfoWithPred_8cpp_source.html#l00123">123</a> of file <a class="el" href="StripDebugInfoWithPred_8cpp_source.html">StripDebugInfoWithPred.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Firtool_2Firtool_8cpp_source.html#l00309">detail::populatePrepareForExportVerilog()</a>.</p>

</div>
</div>
<a id="abd9cbce120f38be2c241c0f7381f9e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9cbce120f38be2c241c0f7381f9e0b">&#9670;&nbsp;</a></span>createTestApplyLoweringOptionPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; mlir::Pass &gt; circt::createTestApplyLoweringOptionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ApplyLoweringOptions_8cpp_source.html#l00041">41</a> of file <a class="el" href="ApplyLoweringOptions_8cpp_source.html">ApplyLoweringOptions.cpp</a>.</p>

</div>
</div>
<a id="a8bbb547d156db232c1e5fbdfc6fb7c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bbb547d156db232c1e5fbdfc6fb7c06">&#9670;&nbsp;</a></span>createTestApplyLoweringOptionPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;mlir::Pass&gt; circt::createTestApplyLoweringOptionPass </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5a0abe53fdab04c5b4457e9f1a530a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a0abe53fdab04c5b4457e9f1a530a5">&#9670;&nbsp;</a></span>debugFooter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; circt::debugFooter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>80</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a boilerplate footer to the debug stream to indicate that a pass has ended. </p>
<p>This produces text like the following:</p>
<p>===--------------------------------&mdash;=== </p>

<p class="definition">Definition at line <a class="el" href="Support_2Debug_8cpp_source.html#l00035">35</a> of file <a class="el" href="Support_2Debug_8cpp_source.html">Debug.cpp</a>.</p>

<p class="reference">References <a class="el" href="Utility_8h_source.html#l00028">lec::dbgs()</a>, and <a class="el" href="FIRRTL_8cpp_source.html#l00036">width</a>.</p>

</div>
</div>
<a id="a17291e378f8102fedebb94060cd838b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17291e378f8102fedebb94060cd838b3">&#9670;&nbsp;</a></span>debugHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; circt::debugHeader </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>80</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a "header"-like string to the debug stream with a certain width. </p>
<p>This produces output like the following: </p><pre class="fragment">===- Hello World --------------------===
</pre><p> This is commonly used for generating a header in debug information. The format is modeled after LLVM/MLIR/CIRCT source file headers. </p>

<p class="definition">Definition at line <a class="el" href="Support_2Debug_8cpp_source.html#l00018">18</a> of file <a class="el" href="Support_2Debug_8cpp_source.html">Debug.cpp</a>.</p>

<p class="reference">References <a class="el" href="Utility_8h_source.html#l00028">lec::dbgs()</a>, and <a class="el" href="FIRRTL_8cpp_source.html#l00036">width</a>.</p>

<p class="reference">Referenced by <a class="el" href="Support_2Debug_8cpp_source.html#l00031">debugPassHeader()</a>.</p>

</div>
</div>
<a id="ae031e9a7373bc6a0aaa612a429228533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae031e9a7373bc6a0aaa612a429228533">&#9670;&nbsp;</a></span>debugPassHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::raw_ostream &amp; circt::debugPassHeader </td>
          <td>(</td>
          <td class="paramtype">const mlir::Pass *&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em> = <code>80</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a boilerplate header for a pass to the debug stream. </p>
<p>This generates output like the following if the pass's name is "FooPass":</p>
<p>===- Running FooPass --------------&mdash;===</p>
<p>This is commonly used to generate a header in debug when a pass starts running. </p>

<p class="definition">Definition at line <a class="el" href="Support_2Debug_8cpp_source.html#l00031">31</a> of file <a class="el" href="Support_2Debug_8cpp_source.html">Debug.cpp</a>.</p>

<p class="reference">References <a class="el" href="Support_2Debug_8cpp_source.html#l00018">debugHeader()</a>.</p>

</div>
</div>
<a id="aec0d6578faea55af939bed33724594fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0d6578faea55af939bed33724594fa">&#9670;&nbsp;</a></span>doTypeConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult circt::doTypeConversion </td>
          <td>(</td>
          <td class="paramtype">Operation *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueRange&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConversionPatternRewriter &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TypeConverter *&#160;</td>
          <td class="paramname"><em>typeConverter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ConversionPatterns_8cpp_source.html#l00037">37</a> of file <a class="el" href="ConversionPatterns_8cpp_source.html">ConversionPatterns.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConversionPatterns_8cpp_source.html#l00015">convertFunctionType()</a>, <a class="el" href="ConversionPatterns_8cpp_source.html#l00028">convertModuleType()</a>, <a class="el" href="CalyxOps_8cpp_source.html#l00054">circt::calyx::direction::get()</a>, and <a class="el" href="ESITypes_8cpp_source.html#l00184">circt::esi::innerType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConversionPatterns_8h_source.html#l00036">circt::TypeConversionPattern::matchAndRewrite()</a>, and <a class="el" href="ConversionPatterns_8h_source.html#l00049">circt::TypeOpConversionPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a4c60cfe9ba173cc6034a8a516017b74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c60cfe9ba173cc6034a8a516017b74a">&#9670;&nbsp;</a></span>elideImplicitSSAName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::elideImplicitSSAName </td>
          <td>(</td>
          <td class="paramtype">OpAsmPrinter &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DictionaryAttr&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SmallVectorImpl&lt; StringRef &gt; &amp;&#160;</td>
          <td class="paramname"><em>elides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the <code>name</code> attribute in <code>attrs</code> matches the SSA name of the operation's first result. </p>
<p>If it does, add <code>name</code> to <code>elides</code>. This is helpful during printing of attribute dictionaries in order to determine if the inclusion of the <code>name</code> field would be redundant. </p>

<p class="definition">Definition at line <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html#l00081">81</a> of file <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="FIRLexer_8cpp_source.html#l00026">isdigit</a>.</p>

<p class="reference">Referenced by <a class="el" href="FIRRTLOps_8cpp_source.html#l05609">printFIRRTLImplicitSSAName()</a>, and <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html#l00073">printImplicitSSAName()</a>.</p>

</div>
</div>
<a id="a952880b2424f3eb1eabf2fe2cd040420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952880b2424f3eb1eabf2fe2cd040420">&#9670;&nbsp;</a></span>exportSplitVerilog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult circt::exportSplitVerilog </td>
          <td>(</td>
          <td class="paramtype">mlir::ModuleOp&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>dirname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export a module containing HW, and SV dialect code, as one file per SV module. </p>
<p>Requires that the SV dialect is loaded in to the context.</p>
<p>Files are created in the directory indicated by <code>dirname</code>. </p>

<p class="reference">Referenced by <a class="el" href="CAPI_2ExportVerilog_2ExportVerilog_8cpp_source.html#l00024">mlirExportSplitVerilog()</a>.</p>

</div>
</div>
<a id="a190e54fae6bf3e6ba5ef813a09660599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190e54fae6bf3e6ba5ef813a09660599">&#9670;&nbsp;</a></span>exportVerilog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult circt::exportVerilog </td>
          <td>(</td>
          <td class="paramtype">mlir::ModuleOp&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export a module containing HW, and SV dialect code. </p>
<p>Requires that the SV dialect is loaded in to the context. </p>

<p class="reference">Referenced by <a class="el" href="CAPI_2ExportVerilog_2ExportVerilog_8cpp_source.html#l00017">mlirExportVerilog()</a>.</p>

</div>
</div>
<a id="a51a53b9396aa3980bc8f79596626db5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a53b9396aa3980bc8f79596626db5d">&#9670;&nbsp;</a></span>extOrTruncZeroWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APSInt circt::extOrTruncZeroWidth </td>
          <td>(</td>
          <td class="paramtype">APSInt&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A safe version of APSInt::extOrTrunc that will NOT assert on zero-width signed APSInts. </p>
<p>Instead of asserting, this will zero extend. </p>

<p class="definition">Definition at line <a class="el" href="APInt_8cpp_source.html#l00022">22</a> of file <a class="el" href="APInt_8cpp_source.html">APInt.cpp</a>.</p>

<p class="reference">References <a class="el" href="FIRRTL_8cpp_source.html#l00036">width</a>.</p>

<p class="reference">Referenced by <a class="el" href="FIRRTLFolds_8cpp_source.html#l00149">getExtendedConstant()</a>.</p>

</div>
</div>
<a id="a5e64fab2873a9eb8cafa2b7724ff7c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e64fab2873a9eb8cafa2b7724ff7c86">&#9670;&nbsp;</a></span>getCirctVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* circt::getCirctVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade9504326c33dc9cce5e8e5b2f8ed061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9504326c33dc9cce5e8e5b2f8ed061">&#9670;&nbsp;</a></span>getCirctVersionComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* circt::getCirctVersionComment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="Conversion_2ExportVerilog_2ExportVerilog_8cpp_source.html#l06361">circt::ExportVerilog::SharedEmitterState::collectOpsForFile()</a>, and <a class="el" href="ExportChiselInterface_8cpp_source.html#l00218">exportChiselInterface()</a>.</p>

</div>
</div>
<a id="acd5db2810fb5a0ee221fc6f9d590706a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5db2810fb5a0ee221fc6f9d590706a">&#9670;&nbsp;</a></span>getConstantInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::optional&lt;APInt&gt; circt::getConstantInt </td>
          <td>(</td>
          <td class="paramtype">Attribute&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the integer value of a constant operand. </p>

<p class="definition">Definition at line <a class="el" href="FoldUtils_8h_source.html#l00018">18</a> of file <a class="el" href="FoldUtils_8h_source.html">FoldUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldUtils_8h_source.html#l00034">isConstantOne()</a>, and <a class="el" href="FoldUtils_8h_source.html#l00027">isConstantZero()</a>.</p>

</div>
</div>
<a id="a85579b6420c9fb3fbb833b8c1c73d3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85579b6420c9fb3fbb833b8c1c73d3e1">&#9670;&nbsp;</a></span>getSlangVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string circt::getSlangVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a human-readable string describing the slang frontend version linked into CIRCT. </p>

<p class="definition">Definition at line <a class="el" href="ImportVerilog_8cpp_source.html#l00034">34</a> of file <a class="el" href="ImportVerilog_8cpp_source.html">ImportVerilog.cpp</a>.</p>

</div>
</div>
<a id="a65ce86f7290ab1b7e8dd11e3c6f18740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ce86f7290ab1b7e8dd11e3c6f18740">&#9670;&nbsp;</a></span>hash_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code circt::hash_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcirct_1_1FieldRef.html">FieldRef</a> &amp;&#160;</td>
          <td class="paramname"><em>fieldRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a hash code for a <a class="el" href="classcirct_1_1FieldRef.html" title="This class represents a reference to a specific field or element of an aggregate value.">FieldRef</a>. </p>

<p class="definition">Definition at line <a class="el" href="FieldRef_8h_source.html#l00092">92</a> of file <a class="el" href="FieldRef_8h_source.html">FieldRef.h</a>.</p>

<p class="reference">References <a class="el" href="FieldRef_8h_source.html#l00059">circt::FieldRef::getFieldID()</a>, and <a class="el" href="FieldRef_8h_source.html#l00037">circt::FieldRef::getValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FieldRef_8h_source.html#l00109">llvm::DenseMapInfo&lt; circt::FieldRef &gt;::getHashValue()</a>, and <a class="el" href="InferResets_8cpp_source.html#l00277">llvm::DenseMapInfo&lt; ResetSignal &gt;::getHashValue()</a>.</p>

</div>
</div>
<a id="ac9c3af24b2c09ed8d9cc0cd2671eb3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c3af24b2c09ed8d9cc0cd2671eb3f4">&#9670;&nbsp;</a></span>importVerilog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult circt::importVerilog </td>
          <td>(</td>
          <td class="paramtype">llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::MLIRContext *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::TimingScope &amp;&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::ModuleOp&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcirct_1_1ImportVerilogOptions.html">ImportVerilogOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse files in a source manager as Verilog source code and populate the given MLIR <code>module</code> with corresponding ops. </p>

<p class="reference">Referenced by <a class="el" href="ImportVerilog_8cpp_source.html#l00376">registerFromVerilogTranslation()</a>.</p>

</div>
</div>
<a id="a8be41639d361e361bf0dced94a6816d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be41639d361e361bf0dced94a6816d8">&#9670;&nbsp;</a></span>inferImplicitSSAName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool circt::inferImplicitSSAName </td>
          <td>(</td>
          <td class="paramtype">OpAsmParser &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NamedAttrList &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that <code>attrs</code> contains a <code>name</code> attribute by inferring its value from the SSA name of the operation's first result if necessary. </p>
<p>Returns true if a name was inferred, false if <code>attrs</code> already contained a <code>name</code>. </p>

<p class="definition">Definition at line <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html#l00040">40</a> of file <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="CalyxOps_8cpp_source.html#l00054">circt::calyx::direction::get()</a>, and <a class="el" href="FIRLexer_8cpp_source.html#l00026">isdigit</a>.</p>

<p class="reference">Referenced by <a class="el" href="FIRRTLOps_8cpp_source.html#l05601">parseFIRRTLImplicitSSAName()</a>, and <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html#l00032">parseImplicitSSAName()</a>.</p>

</div>
</div>
<a id="a6d9dd96e6afbbe667a58553306cc0e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9dd96e6afbbe667a58553306cc0e68">&#9670;&nbsp;</a></span>insertMergeBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult circt::insertMergeBlocks </td>
          <td>(</td>
          <td class="paramtype">mlir::Region &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::ConversionPatternRewriter &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert additional blocks that serve as counterparts to the blocks that diverged the control flow. </p>
<p>Manually run merge block insertion on a region.</p>
<p>The resulting merge block tree is guaranteed to be a binary tree.</p>
<p>This transformation does treat loops like a single block and thus does not affect them.</p>
<p>This transformation does treat loops like a single block and thus does not affect them. </p>

</div>
</div>
<a id="afbcb6e049887b4c54e3016e34f6889d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcb6e049887b4c54e3016e34f6889d8">&#9670;&nbsp;</a></span>isConstantOne()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool circt::isConstantOne </td>
          <td>(</td>
          <td class="paramtype">Attribute&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a constant operand is a one value. </p>

<p class="definition">Definition at line <a class="el" href="FoldUtils_8h_source.html#l00034">34</a> of file <a class="el" href="FoldUtils_8h_source.html">FoldUtils.h</a>.</p>

<p class="reference">References <a class="el" href="FoldUtils_8h_source.html#l00018">getConstantInt()</a>.</p>

</div>
</div>
<a id="ae3045661a06fca02c977b4e38ccd8c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3045661a06fca02c977b4e38ccd8c2a">&#9670;&nbsp;</a></span>isConstantZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool circt::isConstantZero </td>
          <td>(</td>
          <td class="paramtype">Attribute&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a constant operand is a zero value. </p>

<p class="definition">Definition at line <a class="el" href="FoldUtils_8h_source.html#l00027">27</a> of file <a class="el" href="FoldUtils_8h_source.html">FoldUtils.h</a>.</p>

<p class="reference">References <a class="el" href="FoldUtils_8h_source.html#l00018">getConstantInt()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FIRRTLFolds_8cpp_source.html#l03267">eraseIfPredFalse()</a>.</p>

</div>
</div>
<a id="add007169bb350f7d7b3ffae39b62f4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add007169bb350f7d7b3ffae39b62f4b2">&#9670;&nbsp;</a></span>isRegionSSAMaximized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool circt::isRegionSSAMaximized </td>
          <td>(</td>
          <td class="paramtype">Region &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MaximizeSSA_8cpp_source.html#l00057">57</a> of file <a class="el" href="MaximizeSSA_8cpp_source.html">MaximizeSSA.cpp</a>.</p>

<p class="reference">References <a class="el" href="MaximizeSSA_8cpp_source.html#l00027">getDefiningBlock()</a>.</p>

</div>
</div>
<a id="a97d52e2db9a6d4700931878bb739ad46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d52e2db9a6d4700931878bb739ad46">&#9670;&nbsp;</a></span>isUniDimensional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool circt::isUniDimensional </td>
          <td>(</td>
          <td class="paramtype">mlir::MemRefType&#160;</td>
          <td class="paramname"><em>memref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="FlattenMemRefs_8cpp_source.html#l00092">hasMultiDimMemRef()</a>.</p>

</div>
</div>
<a id="a673a2179bef14bddbb26126af51af5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673a2179bef14bddbb26126af51af5d5">&#9670;&nbsp;</a></span>isUselessName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool circt::isUselessName </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a possibly useless temporary name. </p>
<p>This method is FIRRTL-centric, dropping useless temporaries. </p>

<p class="definition">Definition at line <a class="el" href="Naming_8cpp_source.html#l00016">16</a> of file <a class="el" href="Naming_8cpp_source.html">Naming.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Naming_8cpp_source.html#l00027">isNameBetter()</a>.</p>

</div>
</div>
<a id="afb5f201f727afb566d3a659c0ee08744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5f201f727afb566d3a659c0ee08744">&#9670;&nbsp;</a></span>maximizeSSA() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult circt::maximizeSSA </td>
          <td>(</td>
          <td class="paramtype">Block *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcirct_1_1SSAMaximizationStrategy.html">SSAMaximizationStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PatternRewriter &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Considers all values defined by a block (i.e., block arguments and operation results within the block) for SSA maximization, following a provided strategy. </p>
<p>This removes any implicit dataflow of the selected values within the enclosing function. The function adds new block arguments wherever necessary to carry the values explicitly between blocks. Succeeds when it was possible to convert the selected values defined by the block into maximal SSA form. </p>

<p class="definition">Definition at line <a class="el" href="MaximizeSSA_8cpp_source.html#l00166">166</a> of file <a class="el" href="MaximizeSSA_8cpp_source.html">MaximizeSSA.cpp</a>.</p>

<p class="reference">References <a class="el" href="MaximizeSSA_8cpp_source.html#l00073">circt::SSAMaximizationStrategy::maximizeArgument()</a>, <a class="el" href="MaximizeSSA_8cpp_source.html#l00076">circt::SSAMaximizationStrategy::maximizeOp()</a>, and <a class="el" href="MaximizeSSA_8cpp_source.html#l00081">maximizeSSA()</a>.</p>

</div>
</div>
<a id="ad05aa448f25e98193376ff79340d95c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05aa448f25e98193376ff79340d95c9">&#9670;&nbsp;</a></span>maximizeSSA() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult circt::maximizeSSA </td>
          <td>(</td>
          <td class="paramtype">Operation *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcirct_1_1SSAMaximizationStrategy.html">SSAMaximizationStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PatternRewriter &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Considers all of an operation's results for SSA maximization, following a provided strategy. </p>
<p>This removes any implicit dataflow of the selected operation's results within the enclosing function. The function adds new block arguments wherever necessary to carry the results explicitly between blocks. Succeeds when it was possible to convert the selected operation's results into maximal SSA form. </p>

<p class="definition">Definition at line <a class="el" href="MaximizeSSA_8cpp_source.html#l00154">154</a> of file <a class="el" href="MaximizeSSA_8cpp_source.html">MaximizeSSA.cpp</a>.</p>

<p class="reference">References <a class="el" href="MaximizeSSA_8cpp_source.html#l00077">circt::SSAMaximizationStrategy::maximizeResult()</a>, and <a class="el" href="MaximizeSSA_8cpp_source.html#l00081">maximizeSSA()</a>.</p>

</div>
</div>
<a id="a4e2eeb7e1f89db7656f7722c5538054e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2eeb7e1f89db7656f7722c5538054e">&#9670;&nbsp;</a></span>maximizeSSA() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult circt::maximizeSSA </td>
          <td>(</td>
          <td class="paramtype">Region &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcirct_1_1SSAMaximizationStrategy.html">SSAMaximizationStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PatternRewriter &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Considers all blocks within a region for SSA maximization, following a provided strategy. </p>
<p>This removes any implicit dataflow of the values defined by selected blocks within the region. The function adds new block arguments wherever necessary to carry the region's values explicitly between blocks. Succeeds when it was possible to convert all of the values defined by selected blocks into maximal SSA form. </p>

<p class="definition">Definition at line <a class="el" href="MaximizeSSA_8cpp_source.html#l00184">184</a> of file <a class="el" href="MaximizeSSA_8cpp_source.html">MaximizeSSA.cpp</a>.</p>

<p class="reference">References <a class="el" href="MaximizeSSA_8cpp_source.html#l00070">circt::SSAMaximizationStrategy::maximizeBlock()</a>, and <a class="el" href="MaximizeSSA_8cpp_source.html#l00081">maximizeSSA()</a>.</p>

</div>
</div>
<a id="a7e86e04af3966613857cdfe6edc585e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e86e04af3966613857cdfe6edc585e3">&#9670;&nbsp;</a></span>maximizeSSA() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult circt::maximizeSSA </td>
          <td>(</td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PatternRewriter &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a single value within a function into maximal SSA form. </p>
<p>This removes any implicit dataflow of this specific value within the enclosing function. The function adds new block arguments wherever necessary to carry the value explicitly between blocks. Succeeds when it was possible to convert the value into maximal SSA form. </p>

<p class="definition">Definition at line <a class="el" href="MaximizeSSA_8cpp_source.html#l00081">81</a> of file <a class="el" href="MaximizeSSA_8cpp_source.html">MaximizeSSA.cpp</a>.</p>

<p class="reference">References <a class="el" href="MaximizeSSA_8cpp_source.html#l00038">addArgToTerminator()</a>, and <a class="el" href="MaximizeSSA_8cpp_source.html#l00027">getDefiningBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MaximizeSSA_8cpp_source.html#l00154">maximizeSSA()</a>, <a class="el" href="CFToHandshake_8cpp_source.html#l01657">maximizeSSANoMem()</a>, and <a class="el" href="CFToHandshake_8h_source.html#l00073">circt::handshake::HandshakeLowering::setControlOnlyPath()</a>.</p>

</div>
</div>
<a id="abdf876aaca64dfbde8a059d750877522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf876aaca64dfbde8a059d750877522">&#9670;&nbsp;</a></span>parseImplicitSSAName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult circt::parseImplicitSSAName </td>
          <td>(</td>
          <td class="paramtype">OpAsmParser &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NamedAttrList &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an attribute dictionary and ensure that it contains a <code>name</code> field by inferring its value from the SSA name of the operation's first result if necessary. </p>

<p class="definition">Definition at line <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html#l00032">32</a> of file <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html#l00040">inferImplicitSSAName()</a>.</p>

</div>
</div>
<a id="a5bf1f6f10afd9d3c4a3cbbf5ba62315e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf1f6f10afd9d3c4a3cbbf5ba62315e">&#9670;&nbsp;</a></span>parseImplicitSSAName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult circt::parseImplicitSSAName </td>
          <td>(</td>
          <td class="paramtype">OpAsmParser &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr &amp;&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an implicit SSA name string attribute. </p>
<p>If the name is not provided in the input text, its value is inferred from the SSA name of the operation's first result.</p>
<p>implicit-name ::= (<code>name</code> str-attr)? </p>

<p class="definition">Definition at line <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html#l00014">14</a> of file <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="FIRLexer_8cpp_source.html#l00026">isdigit</a>.</p>

</div>
</div>
<a id="a262877a915999b2532d1782316d6d2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262877a915999b2532d1782316d6d2b4">&#9670;&nbsp;</a></span>parseInputPortList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult circt::parseInputPortList </td>
          <td>(</td>
          <td class="paramtype">OpAsmParser &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SmallVectorImpl&lt; OpAsmParser::UnresolvedOperand &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SmallVectorImpl&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr &amp;&#160;</td>
          <td class="paramname"><em>inputNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a list of instance input ports. </p>
<p>input-list ::= <code>(</code> ( input-element (<code>,</code> input-element )* )? <code>)</code> input-element ::= identifier <code>:</code> value <code>:</code> type </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2HW_2CustomDirectiveImpl_8cpp_source.html#l00015">15</a> of file <a class="el" href="Dialect_2HW_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="CalyxOps_8cpp_source.html#l00054">circt::calyx::direction::get()</a>, <a class="el" href="PassHelpers_8cpp_source.html#l00253">inputs</a>, and <a class="el" href="ModuleImplementation_8cpp_source.html#l00278">parseInputPort()</a>.</p>

</div>
</div>
<a id="a14a517eb5287f347b22bcc338f0569ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a517eb5287f347b22bcc338f0569ad">&#9670;&nbsp;</a></span>parseKeywordBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult circt::parseKeywordBool </td>
          <td>(</td>
          <td class="paramtype">OpAsmParser &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoolAttr &amp;&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>trueKeyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>falseKeyword</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a boolean as one of two keywords. </p>
<p>The <code>trueKeyword</code> will result in a true boolean; the <code>falseKeyword</code> will result in a false boolean.</p>
<p>labeled-bool ::= (true-label | false-label) </p>

<p class="definition">Definition at line <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html#l00118">118</a> of file <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="CalyxOps_8cpp_source.html#l00054">circt::calyx::direction::get()</a>.</p>

</div>
</div>
<a id="aec81fa858386cbf254b594f34e7aed69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec81fa858386cbf254b594f34e7aed69">&#9670;&nbsp;</a></span>parseOptionalBinaryOpTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult circt::parseOptionalBinaryOpTypes </td>
          <td>(</td>
          <td class="paramtype">OpAsmParser &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html#l00095">95</a> of file <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

</div>
</div>
<a id="a4b1a0253d9c5dec321a03c07c2a60ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1a0253d9c5dec321a03c07c2a60ae0">&#9670;&nbsp;</a></span>parseOptionalParameterList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult circt::parseOptionalParameterList </td>
          <td>(</td>
          <td class="paramtype">OpAsmParser &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an parameter list if present. </p>
<p>module-parameter-list ::= <code>&lt;</code> parameter-decl (<code>,</code> parameter-decl)* <code>&gt;</code> parameter-decl ::= identifier <code>:</code> type parameter-decl ::= identifier <code>:</code> type <code>=</code> attribute </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2HW_2CustomDirectiveImpl_8cpp_source.html#l00093">93</a> of file <a class="el" href="Dialect_2HW_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassHelpers_8cpp_source.html#l00252">builder</a>, and <a class="el" href="CalyxOps_8cpp_source.html#l00054">circt::calyx::direction::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HWOps_8cpp_source.html#l00896">parseHWModuleOp()</a>.</p>

</div>
</div>
<a id="affdd86e5df7d34c0e669e84603b8e411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdd86e5df7d34c0e669e84603b8e411">&#9670;&nbsp;</a></span>parseOutputPortList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult circt::parseOutputPortList </td>
          <td>(</td>
          <td class="paramtype">OpAsmParser &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SmallVectorImpl&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr &amp;&#160;</td>
          <td class="paramname"><em>resultNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a list of instance output ports. </p>
<p>output-list ::= <code>(</code> ( output-element (<code>,</code> output-element )* )? <code>)</code> output-element ::= identifier <code>:</code> type </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2HW_2CustomDirectiveImpl_8cpp_source.html#l00056">56</a> of file <a class="el" href="Dialect_2HW_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="CalyxOps_8cpp_source.html#l00054">circt::calyx::direction::get()</a>.</p>

</div>
</div>
<a id="a1e52a7793131eac522c1da31fdd13bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e52a7793131eac522c1da31fdd13bef">&#9670;&nbsp;</a></span>populateCombToArithConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::populateCombToArithConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">TypeConverter &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RewritePatternSet &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a335a541a046f38e34b599b627646473e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335a541a046f38e34b599b627646473e">&#9670;&nbsp;</a></span>populateCombToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::populateCombToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">mlir::LLVMTypeConverter &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RewritePatternSet &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Comb to LLVM conversion patterns. </p>

</div>
</div>
<a id="a707c712628af185e79d61aa10cd73234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707c712628af185e79d61aa10cd73234">&#9670;&nbsp;</a></span>populateCombToSMTConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::populateCombToSMTConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">TypeConverter &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RewritePatternSet &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the HW to SMT conversion patterns. </p>

<p class="definition">Definition at line <a class="el" href="CombToSMT_8cpp_source.html#l00232">232</a> of file <a class="el" href="CombToSMT_8cpp_source.html">CombToSMT.cpp</a>.</p>

</div>
</div>
<a id="a6b8bfb1f5705447c1522a3607113b937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8bfb1f5705447c1522a3607113b937">&#9670;&nbsp;</a></span>populateGenericReducePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::populateGenericReducePatterns </td>
          <td>(</td>
          <td class="paramtype">MLIRContext *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcirct_1_1ReducePatternSet.html">ReducePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate reduction patterns that are not specific to certain operations or dialects. </p>

<p class="definition">Definition at line <a class="el" href="GenericReductions_8cpp_source.html#l00056">56</a> of file <a class="el" href="GenericReductions_8cpp_source.html">GenericReductions.cpp</a>.</p>

<p class="reference">References <a class="el" href="GenericReductions_8cpp_source.html#l00049">createSimpleCanonicalizerPass()</a>.</p>

</div>
</div>
<a id="aaefdabf2102a25f00d783253fdf63e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaefdabf2102a25f00d783253fdf63e67">&#9670;&nbsp;</a></span>populateHWArithToHWConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::populateHWArithToHWConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcirct_1_1HWArithToHWTypeConverter.html">HWArithToHWTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RewritePatternSet &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the HWArith to HW conversion patterns. </p>

<p class="definition">Definition at line <a class="el" href="HWArithToHW_8cpp_source.html#l00402">402</a> of file <a class="el" href="HWArithToHW_8cpp_source.html">HWArithToHW.cpp</a>.</p>

</div>
</div>
<a id="a0c564a948b734b37512981e5d56bed11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c564a948b734b37512981e5d56bed11">&#9670;&nbsp;</a></span>populateHWToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::populateHWToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">mlir::LLVMTypeConverter &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RewritePatternSet &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcirct_1_1Namespace.html">Namespace</a> &amp;&#160;</td>
          <td class="paramname"><em>globals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DenseMap&lt; std::pair&lt; Type, ArrayAttr &gt;, mlir::LLVM::GlobalOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>constAggregateGlobalsMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the HW to LLVM conversion patterns. </p>

</div>
</div>
<a id="a65f915a1f0219db72a41ac48d09e96c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f915a1f0219db72a41ac48d09e96c1">&#9670;&nbsp;</a></span>populateHWToLLVMTypeConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::populateHWToLLVMTypeConversions </td>
          <td>(</td>
          <td class="paramtype">mlir::LLVMTypeConverter &amp;&#160;</td>
          <td class="paramname"><em>converter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the HW to LLVM type conversions. </p>

</div>
</div>
<a id="a2ea7a8406488724e4af20107b55ae7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea7a8406488724e4af20107b55ae7ef">&#9670;&nbsp;</a></span>populateHWToSMTConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::populateHWToSMTConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">TypeConverter &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RewritePatternSet &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the HW to SMT conversion patterns. </p>

<p class="definition">Definition at line <a class="el" href="HWToSMT_8cpp_source.html#l00118">118</a> of file <a class="el" href="HWToSMT_8cpp_source.html">HWToSMT.cpp</a>.</p>

</div>
</div>
<a id="ac4ed6ba8317f2515acdd1e91efc44daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ed6ba8317f2515acdd1e91efc44daf">&#9670;&nbsp;</a></span>populateHWToSMTTypeConverter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::populateHWToSMTTypeConverter </td>
          <td>(</td>
          <td class="paramtype">TypeConverter &amp;&#160;</td>
          <td class="paramname"><em>converter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the HW to SMT type conversions. </p>

<p class="definition">Definition at line <a class="el" href="HWToSMT_8cpp_source.html#l00052">52</a> of file <a class="el" href="HWToSMT_8cpp_source.html">HWToSMT.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassHelpers_8cpp_source.html#l00252">builder</a>, <a class="el" href="CalyxOps_8cpp_source.html#l00054">circt::calyx::direction::get()</a>, <a class="el" href="PassHelpers_8cpp_source.html#l00253">inputs</a>, and <a class="el" href="FIRRTL_8cpp_source.html#l00036">width</a>.</p>

</div>
</div>
<a id="abbfc00eebc213425a364cbe8fb74279a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfc00eebc213425a364cbe8fb74279a">&#9670;&nbsp;</a></span>populateLLHDToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::populateLLHDToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">mlir::LLVMTypeConverter &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RewritePatternSet &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>sigCounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>regCounter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the LLHD to LLVM conversion patterns. </p>

</div>
</div>
<a id="a90e131da504433f790ec75e1f9fc5262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e131da504433f790ec75e1f9fc5262">&#9670;&nbsp;</a></span>populateLLHDToLLVMTypeConversions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::populateLLHDToLLVMTypeConversions </td>
          <td>(</td>
          <td class="paramtype">mlir::LLVMTypeConverter &amp;&#160;</td>
          <td class="paramname"><em>converter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the LLHD to LLVM type conversions. </p>

</div>
</div>
<a id="a039a40fd6b74b3e3f0001f40fc6dfad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039a40fd6b74b3e3f0001f40fc6dfad7">&#9670;&nbsp;</a></span>populateVerifToSMTConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::populateVerifToSMTConversionPatterns </td>
          <td>(</td>
          <td class="paramtype">TypeConverter &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RewritePatternSet &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Verif to SMT conversion patterns. </p>

<p class="definition">Definition at line <a class="el" href="VerifToSMT_8cpp_source.html#l00162">162</a> of file <a class="el" href="VerifToSMT_8cpp_source.html">VerifToSMT.cpp</a>.</p>

</div>
</div>
<a id="ae7018555071ac970572f56c73f0fd35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7018555071ac970572f56c73f0fd35a">&#9670;&nbsp;</a></span>preprocessVerilog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::LogicalResult circt::preprocessVerilog </td>
          <td>(</td>
          <td class="paramtype">llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::MLIRContext *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mlir::TimingScope &amp;&#160;</td>
          <td class="paramname"><em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcirct_1_1ImportVerilogOptions.html">ImportVerilogOptions</a> *&#160;</td>
          <td class="paramname"><em>options</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the files in a source manager through Slang's Verilog preprocessor and emit the result to the given output stream. </p>

</div>
</div>
<a id="a5f0425b842d212dd3edee7dbec17c59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0425b842d212dd3edee7dbec17c59a">&#9670;&nbsp;</a></span>printImplicitSSAName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::printImplicitSSAName </td>
          <td>(</td>
          <td class="paramtype">OpAsmPrinter &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DictionaryAttr&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayRef&lt; StringRef &gt;&#160;</td>
          <td class="paramname"><em>extraElides</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print an attribute dictionary and elide the <code>name</code> field if its value matches the SSA name of the operation's first result. </p>

<p class="definition">Definition at line <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html#l00073">73</a> of file <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html#l00081">elideImplicitSSAName()</a>.</p>

</div>
</div>
<a id="adabca51b288ce0412ae93af6414442ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabca51b288ce0412ae93af6414442ad">&#9670;&nbsp;</a></span>printImplicitSSAName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::printImplicitSSAName </td>
          <td>(</td>
          <td class="paramtype">OpAsmPrinter &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringAttr&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print an implicit SSA name string attribute. </p>
<p>If the given string attribute does not match the SSA name of the operation's first result, the name is explicitly printed. Prints a leading space in front of <code>name</code> if any name is present.</p>
<p>implicit-name ::= (<code>name</code> str-attr)? </p>

<p class="definition">Definition at line <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html#l00055">55</a> of file <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="FIRLexer_8cpp_source.html#l00026">isdigit</a>.</p>

</div>
</div>
<a id="ae839c8955f7669e0f8bf35efa0b57efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae839c8955f7669e0f8bf35efa0b57efd">&#9670;&nbsp;</a></span>printInputPortList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::printInputPortList </td>
          <td>(</td>
          <td class="paramtype">OpAsmPrinter &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OperandRange&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeRange&#160;</td>
          <td class="paramname"><em>inputTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>inputNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a list of instance input ports. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2HW_2CustomDirectiveImpl_8cpp_source.html#l00042">42</a> of file <a class="el" href="Dialect_2HW_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassHelpers_8cpp_source.html#l00253">inputs</a>.</p>

</div>
</div>
<a id="a5e45eff90b395ee15721c2fb2615b575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e45eff90b395ee15721c2fb2615b575">&#9670;&nbsp;</a></span>printKeywordBool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::printKeywordBool </td>
          <td>(</td>
          <td class="paramtype">OpAsmPrinter &amp;&#160;</td>
          <td class="paramname"><em>printer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoolAttr&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>trueKeyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>falseKeyword</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a boolean as one of two keywords. </p>
<p>If the boolean is true, the <code>trueKeyword</code> is used; if it is false, the <code>falseKeyword</code> is used.</p>
<p>labeled-bool ::= (true-label | false-label) </p>

<p class="definition">Definition at line <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html#l00133">133</a> of file <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

</div>
</div>
<a id="a14f76ec9a9494fd34f7f0b358963bd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f76ec9a9494fd34f7f0b358963bd58">&#9670;&nbsp;</a></span>printOptionalBinaryOpTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::printOptionalBinaryOpTypes </td>
          <td>(</td>
          <td class="paramtype">OpAsmPrinter &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print/parse binary operands type only when types are different. </p>
<p>optional-bin-op-types := type($lhs) (, type($rhs))? </p>

<p class="definition">Definition at line <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html#l00110">110</a> of file <a class="el" href="Support_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

</div>
</div>
<a id="a512e1ba804e5881866906244c227fb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512e1ba804e5881866906244c227fb1f">&#9670;&nbsp;</a></span>printOptionalParameterList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::printOptionalParameterList </td>
          <td>(</td>
          <td class="paramtype">OpAsmPrinter &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a parameter list for a module or instance. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2HW_2CustomDirectiveImpl_8cpp_source.html#l00126">126</a> of file <a class="el" href="Dialect_2HW_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="HWOps_8cpp_source.html#l01019">printModuleOp()</a>.</p>

</div>
</div>
<a id="a4558f6f3686ea745fb45daa44a09f7dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4558f6f3686ea745fb45daa44a09f7dc">&#9670;&nbsp;</a></span>printOutputPortList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::printOutputPortList </td>
          <td>(</td>
          <td class="paramtype">OpAsmPrinter &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Operation *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeRange&#160;</td>
          <td class="paramname"><em>resultTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayAttr&#160;</td>
          <td class="paramname"><em>resultNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a list of instance output ports. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2HW_2CustomDirectiveImpl_8cpp_source.html#l00080">80</a> of file <a class="el" href="Dialect_2HW_2CustomDirectiveImpl_8cpp_source.html">CustomDirectiveImpl.cpp</a>.</p>

</div>
</div>
<a id="a369bfe3396c123b69c675513b443f04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369bfe3396c123b69c675513b443f04f">&#9670;&nbsp;</a></span>registerAllDialects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void circt::registerAllDialects </td>
          <td>(</td>
          <td class="paramtype">mlir::DialectRegistry &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllDialects_8h_source.html#l00051">51</a> of file <a class="el" href="InitAllDialects_8h_source.html">InitAllDialects.h</a>.</p>

</div>
</div>
<a id="a5c0ad4bb681b1ea56e5baf3f6a3ba7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0ad4bb681b1ea56e5baf3f6a3ba7b2">&#9670;&nbsp;</a></span>registerAllPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void circt::registerAllPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllPasses_8h_source.html#l00042">42</a> of file <a class="el" href="InitAllPasses_8h_source.html">InitAllPasses.h</a>.</p>

<p class="reference">References <a class="el" href="PassRegistration_8cpp_source.html#l00020">circt::llhd::initLLHDTransformationPasses()</a>, <a class="el" href="ESIPasses_8cpp_source.html#l00264">circt::esi::registerESIPasses()</a>, and <a class="el" href="CIRCTModule_8cpp_source.html#l00039">registerPasses()</a>.</p>

</div>
</div>
<a id="a175655b229eb86638ce75528ad53bc47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175655b229eb86638ce75528ad53bc47">&#9670;&nbsp;</a></span>registerAllTranslations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void circt::registerAllTranslations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="InitAllTranslations_8h_source.html#l00032">32</a> of file <a class="el" href="InitAllTranslations_8h_source.html">InitAllTranslations.h</a>.</p>

<p class="reference">References <a class="el" href="ModelInfoExport_8cpp_source.html#l00032">circt::arc::registerArcModelInfoTranslation()</a>, <a class="el" href="ExportSMTLIB_8cpp_source.html#l00622">circt::ExportSMTLIB::registerExportSMTLIBTranslation()</a>, <a class="el" href="ExportSystemC_8cpp_source.html#l00128">circt::ExportSystemC::registerExportSystemCTranslation()</a>, <a class="el" href="FIRParser_8cpp_source.html#l05542">circt::firrtl::registerFromFIRFileTranslation()</a>, <a class="el" href="CalyxEmitter_8cpp_source.html#l01023">circt::calyx::registerToCalyxTranslation()</a>, <a class="el" href="FIREmitter_8cpp_source.html#l01473">circt::firrtl::registerToFIRFileTranslation()</a>, and <a class="el" href="TranslateRegistration_8cpp_source.html#l00083">circt::debug::registerTranslations()</a>.</p>

</div>
</div>
<a id="af38f84835e25707495eb5370c3e5591d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38f84835e25707495eb5370c3e5591d">&#9670;&nbsp;</a></span>registerFromVerilogTranslation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void circt::registerFromVerilogTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the <code>import-verilog</code> MLIR translation. </p>
<p>Entry point as an MLIR translation. </p>

<p class="definition">Definition at line <a class="el" href="ImportVerilog_8cpp_source.html#l00376">376</a> of file <a class="el" href="ImportVerilog_8cpp_source.html">ImportVerilog.cpp</a>.</p>

<p class="reference">References <a class="el" href="CalyxOps_8cpp_source.html#l00054">circt::calyx::direction::get()</a>, and <a class="el" href="namespacecirct.html#ac9c3af24b2c09ed8d9cc0cd2671eb3f4">importVerilog()</a>.</p>

</div>
</div>
<a id="abf8bfac24dda6f9e8834ac103fa20e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8bfac24dda6f9e8834ac103fa20e99">&#9670;&nbsp;</a></span>sextZeroWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APInt circt::sextZeroWidth </td>
          <td>(</td>
          <td class="paramtype">APInt&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A safe version of APInt::sext that will NOT assert on zero-width signed APSInts. </p>
<p>Instead of asserting, this will zero extend. </p>

<p class="definition">Definition at line <a class="el" href="APInt_8cpp_source.html#l00018">18</a> of file <a class="el" href="APInt_8cpp_source.html">APInt.cpp</a>.</p>

<p class="reference">References <a class="el" href="FIRRTL_8cpp_source.html#l00036">width</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a29aefc14513714bc25c652c863f6e533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29aefc14513714bc25c652c863f6e533">&#9670;&nbsp;</a></span>circtBugReportMsg</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* circt::circtBugReportMsg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <span class="stringliteral">&quot;PLEASE submit a bug report to https://github.com/llvm/circt and include &quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;the crash backtrace.\n&quot;</span></div>
</div><!-- fragment -->
<p>A generic bug report message for CIRCT-related projects. </p>

<p class="definition">Definition at line <a class="el" href="Version_8h_source.html#l00011">11</a> of file <a class="el" href="Version_8h_source.html">Version.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 28 2024 00:06:56 for CIRCT by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
