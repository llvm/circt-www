<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CIRCT</title><link>https://circt.llvm.org/</link><description>Recent content on CIRCT</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 Oct 2017 15:26:15 +0000</lastBuildDate><atom:link href="https://circt.llvm.org/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://circt.llvm.org/docs/Dialects/ESIAppID/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESIAppID/</guid><description>InnerSymAttr Inner symbol definition
Defines the properties of an inner_sym attribute. It specifies the symbol name and symbol visibility for each field ID. For any ground types, there are no subfields and the field ID is 0. For aggregate types, a unique field ID is assigned to each field by visiting them in a depth-first pre-order. The custom assembly format ensures that for ground types, only @&amp;lt;sym_name&amp;gt; is printed.</description></item><item><title>'arc' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Arc/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Arc/</guid><description>Canonical representation of state transfer in a circuit This is the arc dialect, useful for representing state transfer functions in a circuit.
Operations arc.alloc_memory (circt::arc::AllocMemoryOp) arc.alloc_state (circt::arc::AllocStateOp) arc.alloc_storage (circt::arc::AllocStorageOp) arc.call (circt::arc::CallOp) arc.clock_domain (circt::arc::ClockDomainOp) arc.clock_tree (circt::arc::ClockTreeOp) arc.define (circt::arc::DefineOp) arc.lut (circt::arc::LutOp) arc.memory (circt::arc::MemoryOp) arc.memory_read (circt::arc::MemoryReadOp) arc.memory_read_port (circt::arc::MemoryReadPortOp) arc.memory_write (circt::arc::MemoryWriteOp) arc.memory_write_port (circt::arc::MemoryWritePortOp) arc.model (circt::arc::ModelOp) arc.output (circt::arc::OutputOp) arc.passthrough (circt::arc::PassThroughOp) arc.root_input (circt::arc::RootInputOp) arc.root_output (circt::arc::RootOutputOp) arc.sim.emit (circt::arc::SimEmitValueOp) arc.sim.get_port (circt::arc::SimGetPortOp) arc.sim.instantiate (circt::arc::SimInstantiateOp) arc.sim.set_input (circt::arc::SimSetInputOp) arc.sim.step (circt::arc::SimStepOp) arc.</description></item><item><title>'calyx' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Calyx/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Calyx/</guid><description>Types and operations for the Calyx dialect Calyx is an intermediate language and infrastructure for building compilers that generate custom hardware accelerators. For more information, visit the documentation.
Operations calyx.assign (::circt::calyx::AssignOp) calyx.comb_component (::circt::calyx::CombComponentOp) calyx.comb_group (::circt::calyx::CombGroupOp) calyx.component (::circt::calyx::ComponentOp) calyx.control (::circt::calyx::ControlOp) calyx.cycle (::circt::calyx::CycleOp) calyx.enable (::circt::calyx::EnableOp) calyx.group (::circt::calyx::GroupOp) calyx.group_done (::circt::calyx::GroupDoneOp) calyx.group_go (::circt::calyx::GroupGoOp) calyx.if (::circt::calyx::IfOp) calyx.instance (::circt::calyx::InstanceOp) calyx.invoke (::circt::calyx::InvokeOp) calyx.memory (::circt::calyx::MemoryOp) calyx.par (::circt::calyx::ParOp) calyx.primitive (::circt::calyx::PrimitiveOp) calyx.register (::circt::calyx::RegisterOp) calyx.repeat (::circt::calyx::RepeatOp) calyx.seq (::circt::calyx::SeqOp) calyx.seq_mem (::circt::calyx::SeqMemoryOp) calyx.</description></item><item><title>'chirrtl' Dialect</title><link>https://circt.llvm.org/docs/Dialects/CHIRRTL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/CHIRRTL/</guid><description>Types and operations for the chirrtl dialect This dialect defines the chirrtl dialect, which contains high-level memory defintions which can be lowered to FIRRTL.
Operations chirrtl.combmem (::circt::chirrtl::CombMemOp) chirrtl.debugport (::circt::chirrtl::MemoryDebugPortOp) chirrtl.memoryport (::circt::chirrtl::MemoryPortOp) chirrtl.memoryport.access (::circt::chirrtl::MemoryPortAccessOp) chirrtl.seqmem (::circt::chirrtl::SeqMemOp) Types CMemoryPortType CMemoryType Operations chirrtl.combmem (::circt::chirrtl::CombMemOp) Define a new combinational memory
Syntax:
operation ::= `chirrtl.combmem` (`sym` $inner_sym^)? `` custom&amp;lt;NameKind&amp;gt;($nameKind) `` custom&amp;lt;CombMemOp&amp;gt;(attr-dict) `:` qualified(type($result)) Define a new behavioral combinational memory. Combinational memories have a write latency of 1 and a read latency of 0.</description></item><item><title>'llhd' Dialect</title><link>https://circt.llvm.org/docs/Dialects/LLHD/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/LLHD/</guid><description>A low-level hardware description dialect in MLIR.
Operations llhd.con (::circt::llhd::ConnectOp) llhd.constant_time (::circt::llhd::ConstantTimeOp) llhd.drv (::circt::llhd::DrvOp) llhd.entity (::circt::llhd::EntityOp) llhd.halt (::circt::llhd::HaltOp) llhd.inst (::circt::llhd::InstOp) llhd.load (::circt::llhd::LoadOp) llhd.output (::circt::llhd::OutputOp) llhd.prb (::circt::llhd::PrbOp) llhd.proc (::circt::llhd::ProcOp) llhd.ptr.array_get (::circt::llhd::PtrArrayGetOp) llhd.ptr.array_slice (::circt::llhd::PtrArraySliceOp) llhd.ptr.extract (::circt::llhd::PtrExtractOp) llhd.ptr.struct_extract (::circt::llhd::PtrStructExtractOp) llhd.reg (::circt::llhd::RegOp) llhd.sig (::circt::llhd::SigOp) llhd.sig.array_get (::circt::llhd::SigArrayGetOp) llhd.sig.array_slice (::circt::llhd::SigArraySliceOp) llhd.sig.extract (::circt::llhd::SigExtractOp) llhd.sig.struct_extract (::circt::llhd::SigStructExtractOp) llhd.store (::circt::llhd::StoreOp) llhd.var (::circt::llhd::VarOp) llhd.wait (::circt::llhd::WaitOp) Attributes TimeAttr Type constraints LLHD time type Types PtrType SigType TimeType Operations llhd.con (::circt::llhd::ConnectOp) Connect two signals.</description></item><item><title>'ltl' Dialect</title><link>https://circt.llvm.org/docs/Dialects/LTL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/LTL/</guid><description>This dialect provides operations and types to model Linear Temporal Logic, sequences, and properties, which are useful for hardware verification.
Rationale Sequences and Properties Representing SVAs Sequence Concatenation and Cycle Delay Implication Clocking Disable Iff Representing the LTL Formalism Next / Delay Concatenation Types Overview PropertyType SequenceType Operations ltl.and (circt::ltl::AndOp) ltl.clock (circt::ltl::ClockOp) ltl.concat (circt::ltl::ConcatOp) ltl.delay (circt::ltl::DelayOp) ltl.disable (circt::ltl::DisableOp) ltl.eventually (circt::ltl::EventuallyOp) ltl.implication (circt::ltl::ImplicationOp) ltl.not (circt::ltl::NotOp) ltl.or (circt::ltl::OrOp) Rationale The main goal of the ltl dialect is to capture the core formalism underpinning SystemVerilog Assertions (SVAs), the de facto standard for describing temporal logic sequences and properties in hardware verification.</description></item><item><title>'moore' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Moore/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Moore/</guid><description>This dialect provides operations and types to capture a SystemVerilog design after parsing, type checking, and elaboration.
Rationale Types Operations moore.ashr (::circt::moore::AShrOp) moore.add (::circt::moore::AddOp) moore.and (::circt::moore::AndOp) moore.blocking_assign (::circt::moore::BlockingAssignOp) moore.bool_cast (::circt::moore::BoolCastOp) moore.case_eq (::circt::moore::CaseEqOp) moore.case_ne (::circt::moore::CaseNeOp) moore.concat (::circt::moore::ConcatOp) moore.constant (::circt::moore::ConstantOp) moore.assign (::circt::moore::ContinuousAssignOp) moore.conversion (::circt::moore::ConversionOp) moore.div (::circt::moore::DivOp) moore.eq (::circt::moore::EqOp) moore.ge (::circt::moore::GeOp) moore.gt (::circt::moore::GtOp) moore.instance (::circt::moore::InstanceOp) moore.le (::circt::moore::LeOp) moore.lt (::circt::moore::LtOp) moore.mod (::circt::moore::ModOp) moore.mul (::circt::moore::MulOp) moore.ne (::circt::moore::NeOp) moore.neg (::circt::moore::NegOp) moore.nonblocking_assign (::circt::moore::NonBlockingAssignOp) moore.not (::circt::moore::NotOp) moore.or (::circt::moore::OrOp) moore.</description></item><item><title>'msft' Dialect</title><link>https://circt.llvm.org/docs/Dialects/MSFT/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/MSFT/</guid><description>Microsoft internal support dialect Umbrella dialect for everything needed to support Microsoft development but not thoroughly discussed. Most (if not everything) in this dialect is a candidate for generalization and re-homing.
Operations msft.hlc.linear (::circt::msft::LinearOp) msft.instance.dynamic (::circt::msft::DynamicInstanceOp) msft.instance.hierarchy (::circt::msft::InstanceHierarchyOp) msft.instance.verb_attr (::circt::msft::DynamicInstanceVerbatimAttrOp) msft.output (::circt::msft::OutputOp) msft.pd.location (::circt::msft::PDPhysLocationOp) msft.pd.multicycle (::circt::msft::PDMulticycleOp) msft.pd.physregion (::circt::msft::PDPhysRegionOp) msft.pd.reg_location (::circt::msft::PDRegPhysLocationOp) msft.pe.output (::circt::msft::PEOutputOp) msft.physical_region (::circt::msft::DeclPhysicalRegionOp) msft.systolic.array (::circt::msft::SystolicArrayOp) Attributes LocationVectorAttr PhysLocationAttr PhysicalBoundsAttr Operations msft.hlc.linear (::circt::msft::LinearOp) Model of a linear datapath which can be arbitrarily pipelined</description></item><item><title>'sim' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Sim/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Sim/</guid><description>Types and operations for the sim dialect The sim dialect is intented to model simulator-specific operations.
Operations sim.fatal (::circt::sim::FatalOp) sim.finish (::circt::sim::FinishOp) sim.plusargs.test (::circt::sim::PlusArgsTestOp) sim.plusargs.value (::circt::sim::PlusArgsValueOp) Operations sim.fatal (::circt::sim::FatalOp) Simulation failure condition
Syntax:
operation ::= `sim.fatal` $clk `,` $cond attr-dict Operands: Operand Description clk A type for clock-carrying wires cond 1-bit signless integer sim.finish (::circt::sim::FinishOp) Simulation finish condition
Syntax:
operation ::= `sim.finish` $clk `,` $cond attr-dict Operands: Operand Description clk A type for clock-carrying wires cond 1-bit signless integer sim.</description></item><item><title>'verif' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Verif/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Verif/</guid><description>This dialect provides a collection of operations to express various verification concerns, such as assertions and interacting with a piece of hardware for the sake of verifying its proper functioning.
Operations verif.assert (circt::verif::AssertOp) verif.assume (circt::verif::AssumeOp) verif.cover (circt::verif::CoverOp) verif.format_verilog_string (circt::verif::FormatVerilogStringOp) verif.has_been_reset (circt::verif::HasBeenResetOp) verif.lec (circt::verif::LogicEquivalenceCheckingOp) verif.print (circt::verif::PrintOp) verif.yield (circt::verif::YieldOp) Operations verif.assert (circt::verif::AssertOp) Assert that a property holds.
Syntax:
operation ::= `verif.assert` $property (`label` $label^)? attr-dict `:` type($property) Attributes: AttributeMLIR TypeDescription label::mlir::StringAttrstring attribute Operands: Operand Description property 1-bit signless integer or LTL sequence type or LTL property type verif.</description></item><item><title>`comb` Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/</guid><description>This document describes various design points of the Comb dialect, a common dialect that is typically used in conjunction with the hw and sv dialects. Please see the hw Dialect Rationale for high level insight on how these work together. This follows in the spirit of other MLIR Rationale docs.
comb Dialect Rationale Introduction to the comb Dialect Type System for comb Dialect Zero-bit integer width is not supported Comb Operations Fully associative operations are variadic Operators carry signs instead of types No implicit extensions of operands No &amp;ldquo;Complement&amp;rdquo;, &amp;ldquo;Negate&amp;rdquo;, &amp;ldquo;ZExt&amp;rdquo;, &amp;ldquo;SExt&amp;rdquo;, Operators No multibit mux operations Endianness: operand ordering and internal representation Bitcasts Cost Model Introduction to the comb Dialect The comb dialect provides a collection of operations that define a mid-level compiler IR for combinational logic.</description></item><item><title>`ibis` Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Ibis/RationaleIbis/</guid><description>Lowering flow Containerization: At this level, one may have relative references to ports get_port accesses to !ibis.scoperefs Tunneling: Relative !ibis.scoperef references are defined via ibis.path operations. In this pass, we lower ibis.path operations by tunneling portrefs through the instance hierarchy, based on the get_port operations that were present in the various containers. After this, various portref&amp;lt;in portref&amp;lt;#dir, T&amp;gt;&amp;gt; ports are present in the design, which represents the actual ports that are being passed around.</description></item><item><title>CIRCT Charter</title><link>https://circt.llvm.org/docs/Charter/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Charter/</guid><description>Abstract Recent trends in computer architecture have resulted in two core problems. Firstly, how do we design complex, heterogeneous systems-on-chip mixing general purpose and specialized components? Secondly, how do we program them? We believe that design tools that represent and manipulate a wide variety of abstractions are central to solving these problems. This projects is focused on using LLVM/MLIR to express these abstractions and to build useable open-source flows based on those abstractions to solve the design problems of the next decade.</description></item><item><title>Compiling CIRCT and PyCDE</title><link>https://circt.llvm.org/docs/PyCDE/compiling/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/PyCDE/compiling/</guid><description>PyCDE is compiled as a component of CIRCT which pulls in the LLVM/MLIR project as a submodule. As such, compiling it is complex and takes some time. If you&amp;rsquo;re not a CIRCT or PyCDE developer, use pip.
Cloning the repo If you havent already, you need to clone the CIRCT repo. Unless you already have contributor permissions to the LLVM project, the easiest way to develop (with the ability to create and push branches) is to fork the repo in your GitHub account.</description></item><item><title>DC Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/DC/RationaleDC/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/DC/RationaleDC/</guid><description>Introduction Value (channel) semantics Canonicalization Introduction DC (Dynamic Control) IR describes independent, unsynchronized processes communicating data through First-in First-out (FIFO) communication channels. This can be implemented in many ways, such as using synchronous logic, or with processors.
The intention of DC is to model all operations required to represent such a control flow language. DC aims to be strictly a control flow dialect - as opposed to the Handshake dialect, which assigns control semantics to all SSA values.</description></item><item><title>Debug Dialect</title><link>https://circt.llvm.org/docs/Dialects/Debug/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Debug/</guid><description>This dialect provides operations and types to interleave debug information (DI) with other parts of the IR.
Rationale Representations Representing Source Language Constructs Tracking Inlined Modules Types Overview ArrayType ScopeType StructType Operations dbg.array (circt::debug::ArrayOp) dbg.scope (circt::debug::ScopeOp) dbg.struct (circt::debug::StructOp) dbg.variable (circt::debug::VariableOp) Rationale The main goal of the debug dialect is to provide a mechanism to track the correspondence between values, types, and hierarchy of a source language and the IR being compiled and transformed.</description></item><item><title>EDA Tool Workarounds</title><link>https://circt.llvm.org/docs/ToolsWorkarounds/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/ToolsWorkarounds/</guid><description>This documents various bugs found in EDA tools and their workarounds in circt. Each but will have a brief description, example code, and the mitigation added (with links to the commit when possible).
Automatic Variables Cause Latch Warnings Verilator issues a latch warning for fully-initialized, automatic variables. This precludes using locally scoped variables. https://github.com/verilator/verilator/issues/4022
Example module ALU( input clock, input [4:0] operation, input [63:0] inputs_1, inputs_0, inputs_2, input [16:0] immediate, output [63:0] output_0 ); reg [63:0] casez_tmp_1; always_comb begin automatic logic [63:0] lowHigh; casez (operation) 5&amp;#39;b00011: casez_tmp_1 = inputs_0 &amp;amp; inputs_1; 5&amp;#39;b00100: casez_tmp_1 = inputs_0 | inputs_1; 5&amp;#39;b00101: casez_tmp_1 = inputs_0 ^ inputs_1; 5&amp;#39;b01001: begin automatic logic [16:0] _aluOutput_T_22 = immediate &amp;gt;&amp;gt; {14&amp;#39;h0, inputs_2, inputs_1[0], inputs_0[0]}; casez_tmp_1 = {63&amp;#39;h0, _aluOutput_T_22[0]}; end default: casez_tmp_1 = inputs_0; endcase end endmodule Gives:</description></item><item><title>Emission (Emit) Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Emit/RationaleEmit/</guid><description>This document describes various design points of the emit dialect, why it is the way it is, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction The emit dialects controls the structure and formatting of the files emitted from CIRCT. It captures information about both SystemVerilog output files and generic collateral files. The ops are translated to output files in ExportVerilog. Presently, the dialect is intertwined with SystemVerilog - it can reference items in a design through symbols to emit references to them through SystemVerilog names in the output.</description></item><item><title>ESI cosimulation model</title><link>https://circt.llvm.org/docs/Dialects/ESI/cosim/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/cosim/</guid><description>Elastic Silicon Interfaces provides a feature called cosimulation. Cosim in general allows communication between the simulation and software. In the ESI case, it is typed and can be used to build an application and language specific API which is nearly identical to how the real hardware would interface. This allows users to simulate against the actual target software (or some simplification of it), enabling easier co-design.
ESI cosim uses Cap&amp;rsquo;nProto as a message format and RPC client/server.</description></item><item><title>ESI data types and communication types</title><link>https://circt.llvm.org/docs/Dialects/ESI/types/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/types/</guid><description>ESI has two different classes of MLIR types: ones which represent data on the wires (data types) and ones which specify the type of communication. From a user perspective, communication types aren&amp;rsquo;t really types &amp;ndash; this is just how the communication style is modeled in MLIR and thus an implementation detail.
Data types In addition to the types in the hw dialect, ESI will add few:
Void void translates to &amp;ldquo;no data&amp;rdquo;, meaning just a control signal.</description></item><item><title>ESI Global Services</title><link>https://circt.llvm.org/docs/Dialects/ESI/services/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/services/</guid><description>This section not fully fleshed out and suffers from poor writing.
ESI will provide access to global resource via ESI Services. These &amp;ldquo;buses&amp;rdquo; define a typed interface and instances are instantiated globally &amp;ndash; they should be accessible at all levels of the design hierarchy. ESI services are intended to provide access to truly global resources like PCIe, shared DMA engines, DRAM, network interfaces, etc. They are generic enough to be extended to non-physical interfaces like telemetry &amp;ndash; if you have a centralized telemetry reporting engine, you probably want any module or submodule in the design to be able to access and report to it.</description></item><item><title>ESI Software APIs</title><link>https://circt.llvm.org/docs/Dialects/ESI/software_api/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/software_api/</guid><description>More on this to be written.
Status: unimplemented
Thanks to ESI&amp;rsquo;s strong static typing, typed, design-dependent software APIs can be automatically generated. Said APIs would be mostly independent of the transport mechanism (PCIe, network, etc.) used to communicate with the silicon. The same API could even drive a simulation of the ESI system.
Said APIs would need to ensure that the software is talking to the correct hardware. There are several possible approaches:</description></item><item><title>FIRRTL Annotations</title><link>https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/</guid><description>The Scala FIRRTL Compiler (SFC) provides a mechanism to encode arbitrary metadata and associate it with zero or more &amp;ldquo;things&amp;rdquo; in a FIRRTL circuit. This mechanism is an Annotation and the association is described using one or more Targets. Annotations should be viewed as an extension to the FIRRTL IR specification, and can greatly affect the meaning and interpretation of the IR.
Annotations are represented as a dictionary, with a &amp;ldquo;class&amp;rdquo; field which describes which annotation it is, and a &amp;ldquo;target&amp;rdquo; field which represents the IR object it is attached to.</description></item><item><title>FIRRTL Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/</guid><description>This document describes various design points of the FIRRTL dialect, why it is the way it is, and current status and progress. This follows in the spirit of other MLIR Rationale docs.
Introduction The FIRRTL project is an existing open source compiler infrastructure used by the Chisel framework to lower &amp;ldquo;.fir&amp;rdquo; files to Verilog. It provides a number of useful compiler passes and infrastructure that allows the development of domain specific passes.</description></item><item><title>Formal Verification Tooling</title><link>https://circt.llvm.org/docs/FormalVerification/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/FormalVerification/</guid><description>Formally verifying hardware designs is a crucial step during the development process. Various techniques exist, such as logical equivalence checking, model checking, symbolic execution, etc. The preferred technique depends on the level of abstraction, the kind of properties to be verified, runtime limitations, etc. As a hardware compiler collection, CIRCT provides infrastructure to implement formal verification tooling and already comes with a few tools for common use-cases. This document provides an introduction to those tools and gives and overview over the underlying infrastructure for compiler engineers who want to use CIRCT to implement their custom verification tool.</description></item><item><title>FSM Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/</guid><description>This document describes various design points of the FSM dialect, why they are the way they are, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction Finite-state machine (FSM) is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some inputs; the change from one state to another is called a transition.</description></item><item><title>Getting Started with the CIRCT Project</title><link>https://circt.llvm.org/docs/GettingStarted/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/GettingStarted/</guid><description>Overview Welcome to the CIRCT project!
&amp;ldquo;CIRCT&amp;rdquo; stands for &amp;ldquo;Circuit IR Compilers and Tools&amp;rdquo;. The CIRCT project is an (experimental!) effort looking to apply MLIR and the LLVM development methodology to the domain of hardware design tools.
Take a look at the following diagram, which gives a brief overview of the current dialects and how they interact:
Setting this up These commands can be used to setup CIRCT project:
Install Dependencies of LLVM/MLIR according to the instructions, including cmake and ninja.</description></item><item><title>Handshake Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/</guid><description>Principle Choice of MLIR IR Representation Conventions Talks, Resources and Related Publications Operation definitions Operations handshake.br (::circt::handshake::BranchOp) handshake.buffer (::circt::handshake::BufferOp) handshake.cond_br (::circt::handshake::ConditionalBranchOp) handshake.constant (::circt::handshake::ConstantOp) handshake.control_merge (::circt::handshake::ControlMergeOp) handshake.extmemory (::circt::handshake::ExternalMemoryOp) handshake.fork (::circt::handshake::ForkOp) handshake.func (::circt::handshake::FuncOp) handshake.instance (::circt::handshake::InstanceOp) handshake.join (::circt::handshake::JoinOp) handshake.lazy_fork (::circt::handshake::LazyForkOp) handshake.load (::circt::handshake::LoadOp) handshake.memory (::circt::handshake::MemoryOp) handshake.merge (::circt::handshake::MergeOp) handshake.mux (::circt::handshake::MuxOp) handshake.never (::circt::handshake::NeverOp) handshake.pack (::circt::handshake::PackOp) handshake.return (::circt::handshake::ReturnOp) handshake.sink (::circt::handshake::SinkOp) handshake.source (::circt::handshake::SourceOp) handshake.store (::circt::handshake::StoreOp) handshake.sync (::circt::handshake::SyncOp) handshake.unpack (::circt::handshake::UnpackOp) Attributes BufferTypeEnumAttr This document also explains in a high-level manner how different components are organized, the principles behind them and the conventions we followed.</description></item><item><title>handshake-runner</title><link>https://circt.llvm.org/docs/CommandGuide/handshake-runner/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/CommandGuide/handshake-runner/</guid><description>SYNOPSIS | handshake-runner [options] [filename] [arguments]
DESCRIPTION This application executes a function in the given MLIR module. Arguments to the function are passed on the command line and results are returned on stdout. Memref types are specified as a comma-separated list of values. This particular tool is use to check the validity of Standard-to-Handshake conversion in CIRCT.
Example The following MLIR module first convert to Handshake IR with the circt-opt tool as circt-opt -create-dataflow &amp;lt;file-name&amp;gt;.</description></item><item><title>HLS in CIRCT</title><link>https://circt.llvm.org/docs/HLS/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/HLS/</guid><description>// write a compelling introduction here
hlstool Flows Dynamically scheduled HLS (DHLS) Calyx hlstool hlstool is a tool for driving various CIRCT-based HLS flows. The tool works by defining pass pipelines that string together various MLIR and CIRCT passes to realize an HLS flow.
For new users to MLIR, it is important to recognize the different between such compiler driver tools, and the MLIR opt tools (optimization drivers), such as mlir-opt and circt-opt.</description></item><item><title>HW Arith Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/HWArith/RationaleHWArith/</guid><description>This document describes the various design points of the HWArith dialect, a dialect that is used to represent bitwidth extending arithmetic. This follows in the spirit of other MLIR Rationale docs.
HW Arith Dialect Rationale Introduction Q&amp;amp;A Bit Width Rules Lowering Introduction The hwarith dialect provides a collection of operations that define typical integer arithmetic operations which are bitwidth extending. These semantics are expressed through return type inference rules that, based on the types of an operation and its input operands, infers the type of the result operand.</description></item><item><title>HW Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/HW/RationaleHW/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/HW/RationaleHW/</guid><description>This document describes various design points of the hw dialect as well as global perspective on the hw, comb, and sv dialects, why they are the way they are, and current status. This follows in the spirit of other MLIR Rationale docs. For more information about the other dialects, please see the Comb Dialect Rationale and SV Dialect Rationale.
HW Dialect Rationale General Introduction Introduction to the hw Dialect hw Type System hw.</description></item><item><title>Interoperability Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Interop/RationaleInterop/</guid><description>This document describes the various design points of the Interop dialect, a dialect that is used to represent partially lowered interoperability layers and that provides common interfaces and utilities for automated interop generation. This follows in the spirit of other MLIR Rationale docs.
Interoperability Dialect Rationale Introduction Procedural Interop Representing Partial Lowerings Interop Mechanisms Instance-side Lowering Container-side Lowering Bridging between Interop Mechanisms How to use this dialect Design considerations Introduction The increasing number of CIRCT-based backends as well as the usage of many external tools raises questions about interoperability and composition of those tools.</description></item><item><title>Intrinsics</title><link>https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLIntrinsics/</guid><description>Intrinsics provide an implementation-specific way to extend the FIRRTL language with new operations.
Intrinsics are currently implemented as annotated external modules. We expect that native FIRRTL support for intrinsics will be added to the language.
Motivation Intrinsics provide a way to add functionality to FIRRTL without having to extend the FIRRTL language. This allows a fast path for prototyping new operations to rapidly respond to output requirements. Intrinsics maintain strict definitions and type checking.</description></item><item><title>LoopSchedule Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/LoopSchedule/LoopSchedule/</guid><description>This document describes various design points of the loopschedule dialect, why it is the way it is, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction The loopschedule dialect provides a collection of ops to represent software-like loops after scheduling. There are currently two main kinds of loops that can be represented: pipelined and sequential. Pipelined loops allow multiple iterations of the loop to be in-flight at a time and have an associated initiation interval (II) to specify the number of cycles between the start of successive loop iterations.</description></item><item><title>Miscellaneous Notes</title><link>https://circt.llvm.org/docs/Dialects/ESI/notes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/notes/</guid><description>ABI The ABI specifies how an ESI &amp;ldquo;API&amp;rdquo; is translated to hardware, specifically RTL. This involves both the wire-level signaling between modules and how data is arranged on those wires.
This section is purposely underspecified in this proposal as it should be an implementation detail which only advanced users need know. The main issues discussed here are how lists and data windows are lowered and presented to RTL modules. Lowering of fixed-size, default-presentation semantics ports is mostly straight forward, so is not discussed here.</description></item><item><title>Object Model Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/OM/RationaleOM/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/OM/RationaleOM/</guid><description>This document describes various design points of the om dialect. This follows in the spirit of other MLIR Rationale docs.
Motivation The goal of the om dialect is to develop an IR suitable for domain modeling. It intends to accomplish this by providing constructs for capturing an Object Model (OM). Domain modeling in this context means capturing design intent and supporting tooling related to the creation of CPUs and SoCs. Anything other than RTL level design entry falls under this broad categorization, and must be intimately tied to RTL level design entry in a stable way.</description></item><item><title>Passes</title><link>https://circt.llvm.org/docs/Passes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Passes/</guid><description>This document describes the available CIRCT passes and their contracts.
Conversion Passes -calyx-native -calyx-remove-groups-fsm -convert-affine-to-loopschedule -convert-comb-to-arith -convert-comb-to-smt -convert-fsm-to-sv -convert-hw-to-btor2 -convert-hw-to-llhd -convert-hw-to-llvm -convert-hw-to-smt -convert-hw-to-systemc -convert-llhd-to-llvm -convert-moore-to-core -convert-to-arcs -convert-verif-to-smt -export-chisel-interface -export-split-chisel-interface -export-split-verilog -export-verilog -handshake-remove-block-structure -hw-lower-instance-choices -legalize-anon-enums -lower-arc-to-llvm -lower-calyx-to-fsm -lower-calyx-to-hw -lower-cf-to-handshake -lower-dc-to-hw -lower-firrtl-to-hw -lower-handshake-to-dc -lower-handshake-to-hw -lower-hw-to-sv -lower-hwarith-to-hw -lower-loopschedule-to-calyx -lower-pipeline-to-hw -lower-scf-to-calyx -lower-seq-firmem -lower-seq-to-sv -lower-sim-to-sv -lower-verif-to-sv -materialize-calyx-to-fsm -prepare-for-emission -test-apply-lowering-options Arc Dialect Passes -arc-add-taps -arc-allocate-state -arc-canonicalizer -arc-dedup -arc-group-resets-and-enables -arc-infer-memories -arc-infer-state-properties -arc-inline -arc-inline-modules -arc-isolate-clocks -arc-latency-retiming -arc-legalize-state-update -arc-lower-arcs-to-funcs -arc-lower-clocks-to-funcs -arc-lower-lut -arc-lower-state -arc-lower-vectorizations -arc-make-tables -arc-mux-to-control-flow -arc-simplify-variadic-ops -arc-split-loops -arc-strip-sv Calyx Dialect Passes -calyx-clk-insertion -calyx-compile-control -calyx-gicm -calyx-go-insertion -calyx-remove-comb-groups Example -calyx-remove-groups -calyx-reset-insertion Comb Dialect Passes -lower-comb DC Dialect Passes -dc-dematerialize-forks-sinks -dc-materialize-forks-sinks ESI Dialect Passes -esi-appid-hier -esi-build-manifest -esi-clean-metadata -esi-connect-services -lower-esi-bundles -lower-esi-ports -lower-esi-to-hw -lower-esi-to-physical -lower-esi-types FIRRTL Dialect Passes -firrtl-add-seqmem-ports -firrtl-blackbox-reader -firrtl-check-comb-loops -firrtl-dedup -firrtl-drop-const -firrtl-drop-names -firrtl-emit-metadata -firrtl-emit-omir -firrtl-expand-whens -firrtl-extract-instances -firrtl-finalize-ir -firrtl-flatten-memory -firrtl-grand-central -firrtl-hoist-passthrough -firrtl-imconstprop -firrtl-imdeadcodeelim -firrtl-infer-resets -firrtl-infer-rw -firrtl-infer-widths -firrtl-inject-dut-hier -firrtl-inliner -firrtl-inner-symbol-dce -firrtl-layer-merge -firrtl-layer-sink -firrtl-lint -firrtl-lower-annotations -firrtl-lower-chirrtl -firrtl-lower-classes -firrtl-lower-intmodules -firrtl-lower-intrinsics -firrtl-lower-layers -firrtl-lower-matches -firrtl-lower-memory -firrtl-lower-open-aggs -firrtl-lower-signatures -firrtl-lower-types -firrtl-lower-xmr -firrtl-materialize-debug-info -firrtl-mem-to-reg-of-vec -firrtl-passive-wires -firrtl-prefix-modules -firrtl-print-field-source -firrtl-print-instance-graph -firrtl-print-nla-table -firrtl-probe-dce -firrtl-randomize-register-init -firrtl-register-optimizer -firrtl-remove-unused-ports -firrtl-resolve-paths -firrtl-resolve-traces -firrtl-sfc-compat -firrtl-specialize-option -firrtl-vb-to-bv -merge-connections -vectorization FSM Dialect Passes -fsm-print-graph Handshake Dialect Passes -handshake-add-ids -handshake-dematerialize-forks-sinks -handshake-insert-buffers -handshake-legalize-memrefs -handshake-lock-functions -handshake-lower-extmem-to-hw -handshake-materialize-forks-sinks -handshake-op-count -handshake-print-dot -handshake-remove-buffers HW Dialect Passes -hw-flatten-io -hw-print-instance-graph -hw-print-module-graph -hw-specialize -hw-verify-irn Ibis Dialect Passes -ibis-add-operator-library -ibis-argify-blocks -ibis-call-prep -ibis-clean-selfdrivers -ibis-containerize -ibis-convert-cf-to-handshake -ibis-convert-containers-to-hw -ibis-convert-handshake-to-dc -ibis-convert-methods-to-containers -ibis-inline-sblocks -ibis-lower-portrefs -ibis-prepare-scheduling -ibis-reblock -ibis-tunneling LLHD Dialect Passes -llhd-early-code-motion -llhd-function-elimination -llhd-memory-to-block-argument -llhd-process-lowering MSFT Dialect Passes -msft-export-tcl -msft-lower-constructs -msft-lower-instances OM Dialect Passes -om-freeze-paths -om-link-modules Pipeline Dialect Passes -pipeline-explicit-regs -pipeline-schedule-linear Seq Dialect Passes -externalize-clock-gate -hw-memory-sim -lower-seq-fifo -lower-seq-hlmem -lower-seq-shiftreg SSP Dialect Passes -ssp-print -ssp-roundtrip -ssp-schedule SV Dialect Passes -hw-cleanup -hw-eliminate-inout-ports -hw-export-module-hierarchy -hw-generator-callout -hw-legalize-modules -hw-stub-external-modules -prettify-verilog -sv-extract-test-code -sv-trace-iverilog SystemC Dialect Passes -systemc-lower-instance-interop Conversion Passes -calyx-native Callout to the Calyx native compiler and run a pass pipeline</description></item><item><title>Pipeline Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Pipeline/RationalePipeline/</guid><description>This document describes various design points of the pipeline dialect, why it is the way it is, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction Pipeline Phases A pipeline.pipeline operation can be used in a sequence of phases, each of which incrementally transforms the pipeline from being unscheduled towards being an RTL representation of a pipeline. Each phase is mutually exlusive, meaning that the &amp;ldquo;phase-defining&amp;rdquo; operations (pipeline.</description></item><item><title>PyCDE Basics</title><link>https://circt.llvm.org/docs/PyCDE/basics/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/PyCDE/basics/</guid><description>You know what&amp;rsquo;s more difficult than forcing yourself to write documentation? Maintaining it! We apologize for the inevitable inaccuracies.
Modules, Generators, and Systems from pycde import Input, Output, Module, System from pycde import generator from pycde.types import Bits class OrInts(Module): a = Input(Bits(32)) b = Input(Bits(32)) c = Output(Bits(32)) @generator def construct(self): self.c = self.a | self.b system = System([OrInts], name=&amp;#34;ExampleSystem&amp;#34;, output_directory=&amp;#34;exsys&amp;#34;) system.compile() Hardware modules extend pycde.Module. They define any number of typed inputs and outputs by setting class members.</description></item><item><title>Seq(uential) Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/</guid><description>This document describes various design points of the seq dialect, why it is the way it is, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction Digital logic is generally split into two categories: combinational and sequential. CIRCT contains a comb dialect to model the basic combinational operations and the (future) seq dialect which is discussed here. The intention of the seq dialect is to provide a set of stateful constructs which can be used to model sequential logic, independent of the output method (e.</description></item><item><title>Simulation (Sim) Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Sim/RationaleSim/</guid><description>This document describes various design points of the sim dialect, why it is the way it is, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction The sim dialect provides a high-level representation for simulator-specific operations. The purpose of the dialect is to provide a high-level representation for constructs which interact with simulators (Verilator, VCS, Arc, &amp;hellip;) that are easy to analyze and transform in the compiler.</description></item><item><title>SMT Dialect</title><link>https://circt.llvm.org/docs/Dialects/SMT/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/SMT/</guid><description>This dialect provides types and operations modeling the SMT (Satisfiability Modulo Theories) operations and datatypes commonly found in SMT-LIB and SMT solvers.
Rationale Dialect Structure Optimizations Backends LLVM IR SMT-LIB C/C++ Handling counter-examples Non-Goals Operations smt.and (circt::smt::AndOp) smt.apply_func (circt::smt::ApplyFuncOp) smt.array.broadcast (circt::smt::ArrayBroadcastOp) smt.array.select (circt::smt::ArraySelectOp) smt.array.store (circt::smt::ArrayStoreOp) smt.assert (circt::smt::AssertOp) smt.bv.ashr (circt::smt::BVAShrOp) smt.bv.add (circt::smt::BVAddOp) smt.bv.and (circt::smt::BVAndOp) smt.bv.cmp (circt::smt::BVCmpOp) smt.bv.constant (circt::smt::BVConstantOp) smt.bv.lshr (circt::smt::BVLShrOp) smt.bv.mul (circt::smt::BVMulOp) smt.bv.neg (circt::smt::BVNegOp) smt.bv.not (circt::smt::BVNotOp) smt.bv.or (circt::smt::BVOrOp) smt.bv.sdiv (circt::smt::BVSDivOp) smt.bv.smod (circt::smt::BVSModOp) smt.</description></item><item><title>SSP Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/SSP/RationaleSSP/</guid><description>This document describes various design points of the SSP dialect, why they are the way they are, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction CIRCT&amp;rsquo;s scheduling infrastructure is lightweight and dialect-agnostic, in order to fit into any lowering flow with a need for static scheduling. However, it lacks an import/export format for storing and exchanging problem instances. The SSP (&amp;quot;Static Scheduling Problems&amp;quot;) dialect fills that role by defining an IR that captures problem instances</description></item><item><title>Static scheduling infrastructure</title><link>https://circt.llvm.org/docs/Scheduling/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Scheduling/</guid><description>Scheduling is a common concern in hardware design, for example in high-level synthesis flows targeting an FSM+Datapath execution model (&amp;ldquo;static HLS&amp;rdquo;). This document gives an overview of, and provides rationale for, the infrastructure in the circt::scheduling namespace. At its core, it defines an extensible problem model that acts as an interface between clients (i.e. passes that have a need to schedule a graph-like IR) and reusable algorithm implementations.
This infrastructure aims to provide:</description></item><item><title>SV Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/SV/RationaleSV/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/SV/RationaleSV/</guid><description>This document describes various design points of the sv dialect, a common dialect that is typically used in conjunction with the hw and comb dialects. Please see the HW Dialect Rationale for high level insight on how these work together. This follows in the spirit of other MLIR Rationale docs.
SV Dialect Rationale Introduction to the sv dialect sv Type System Overview of sv dialect operations Statements Declarations Expressions Verbatim op Cost Model SV Dialect Attributes Introduction to the sv dialect The sv dialect is one of the dialects that can be mixed into the HW dialect, providing access to a range of syntactic and behavioral constructs in SystemVerilog.</description></item><item><title>Symbol and Inner Symbol Rationale</title><link>https://circt.llvm.org/docs/RationaleSymbols/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleSymbols/</guid><description>This document describes various design points of the major CIRCT dialects relating to the use of symbols and the introduction of inner symbols and related types. This follows in the spirit of other MLIR Rationale docs.
Introduction Verilog and FIRRTL have, from a software compiler perspective, an unusual number of nameable entities which can be referred to non-locally. These entities have deep nesting in the code structures. The requirements of dealing with these entities and references entails more complexity than provided by MLIR&amp;rsquo;s symbols and symbol tables.</description></item><item><title>SystemC Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/SystemC/RationaleSystemC/</guid><description>This document describes various design points of the SystemC dialect, why they are the way they are, and current status. This follows in the spirit of other MLIR Rationale docs.
SystemC Dialect Rationale Introduction Lowering Q&amp;amp;A Introduction SystemC is a library written in C++ to allow functional modeling of systems. The included event-driven simulation kernel can then be used to simulate a system modeled entirely in SystemC. Additionally, SystemC is a standard (IEEE Std 1666-2011) supported by several tools (e.</description></item><item><title>The Elastic Silicon Interconnect dialect</title><link>https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/</guid><description>Long ago, software function calling conventions were ad-hoc. This led to issues, particularly with register clobbering and stack corruption. This is &amp;ndash; in large part &amp;ndash; the state of FPGA/ASIC design today: wire signaling protocols are often ad-hoc, which also leads to major issues. Though there are efforts to standardize the signaling protocols there are many minor and major variants, both of which lead to confusion which can cause real problems when one is listening to and twiddling the wires manually.</description></item><item><title>Using the Python Bindings</title><link>https://circt.llvm.org/docs/PythonBindings/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/PythonBindings/</guid><description>If you are mainly interested in using CIRCT from Python scripts, you need to compile both LLVM/MLIR and CIRCT with Python bindings enabled. Furthermore, you must use a unified build, where LLVM/MLIR and CIRCT are compiled together in one step.
CIRCT also includes an experimental, opinionated frontend for CIRCT&amp;rsquo;s Python bindings, called PyCDE.
Installing and Building with Wheels CIRCT provides a setup.py script that take care of configuring and building LLVM/MLIR, CIRCT, and CIRCT&amp;rsquo;s Python bindings.</description></item><item><title>Verilog and SystemVerilog Generation</title><link>https://circt.llvm.org/docs/VerilogGeneration/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/VerilogGeneration/</guid><description>Verilog and SystemVerilog are critical components of the hardware design tool ecosystem, but generating syntactically correct Verilog that is acceptable by a wide range of tools is a challenge &amp;ndash; and generating &amp;ldquo;good looking&amp;rdquo; output even more so. This document describes CIRCT&amp;rsquo;s approach and support for generating Verilog and SystemVerilog, some of the features and capabilities provided, and information about the internal layering of the related subsystems.
Why is this hard?</description></item></channel></rss>