<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CIRCT</title><link>https://circt.llvm.org/</link><description>Recent content on CIRCT</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 Oct 2017 15:26:15 +0000</lastBuildDate><atom:link href="https://circt.llvm.org/index.xml" rel="self" type="application/rss+xml"/><item><title>'calyx' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Calyx/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Calyx/</guid><description>Types and operations for the Calyx dialect Calyx is an intermediate language and infrastructure for building compilers that generate custom hardware accelerators. For more information, visit the documentation.
Operation definition calyx.std_add (::circt::calyx::AddLibOp) calyx.std_and (::circt::calyx::AndLibOp) calyx.assign (::circt::calyx::AssignOp) calyx.comb_group (::circt::calyx::CombGroupOp) calyx.component (::circt::calyx::ComponentOp) calyx.control (::circt::calyx::ControlOp) calyx.std_divs_pipe (::circt::calyx::DivSPipeLibOp) calyx.std_divu_pipe (::circt::calyx::DivUPipeLibOp) calyx.enable (::circt::calyx::EnableOp) calyx.std_eq (::circt::calyx::EqLibOp) calyx.std_extsi (::circt::calyx::ExtSILibOp) calyx.std_ge (::circt::calyx::GeLibOp) calyx.group_done (::circt::calyx::GroupDoneOp) calyx.group_go (::circt::calyx::GroupGoOp) calyx.group (::circt::calyx::GroupOp) calyx.std_gt (::circt::calyx::GtLibOp) calyx.if (::circt::calyx::IfOp) calyx.instance (::circt::calyx::InstanceOp) calyx.std_le (::circt::calyx::LeLibOp) calyx.std_lsh (::circt::calyx::LshLibOp) calyx.</description></item><item><title>'chirrtl' Dialect</title><link>https://circt.llvm.org/docs/Dialects/CHIRRTL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/CHIRRTL/</guid><description>Types and operations for the chirrtl dialect This dialect defines the chirrtl dialect, which contains high-level memory defintions which can be lowered to FIRRTL.
Operation definition chirrtl.combmem (::circt::chirrtl::CombMemOp) chirrtl.memoryport.access (::circt::chirrtl::MemoryPortAccessOp) chirrtl.memoryport (::circt::chirrtl::MemoryPortOp) chirrtl.seqmem (::circt::chirrtl::SeqMemOp) Type definition CMemoryPortType CMemoryType Operation definition chirrtl.combmem (::circt::chirrtl::CombMemOp) Define a new combinational memory
Syntax:
operation ::= `chirrtl.combmem` (`sym` $inner_sym^)? custom&amp;lt;NameKind&amp;gt;($nameKind) custom&amp;lt;CombMemOp&amp;gt;(attr-dict) `:` qualified(type($result)) Define a new behavioral combinational memory. Combinational memories have a write latency of 1 and a read latency of 0.</description></item><item><title>'llhd' Dialect</title><link>https://circt.llvm.org/docs/Dialects/LLHD/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/LLHD/</guid><description>A low-level hardware description dialect in MLIR.
Operation definition llhd.con (::circt::llhd::ConnectOp) llhd.constant_time (::circt::llhd::ConstantTimeOp) llhd.drv (::circt::llhd::DrvOp) llhd.entity (::circt::llhd::EntityOp) llhd.halt (::circt::llhd::HaltOp) llhd.inst (::circt::llhd::InstOp) llhd.load (::circt::llhd::LoadOp) llhd.output (::circt::llhd::OutputOp) llhd.prb (::circt::llhd::PrbOp) llhd.proc (::circt::llhd::ProcOp) llhd.ptr.array_get (::circt::llhd::PtrArrayGetOp) llhd.ptr.array_slice (::circt::llhd::PtrArraySliceOp) llhd.ptr.extract (::circt::llhd::PtrExtractOp) llhd.ptr.struct_extract (::circt::llhd::PtrStructExtractOp) llhd.reg (::circt::llhd::RegOp) llhd.shl (::circt::llhd::ShlOp) llhd.shr (::circt::llhd::ShrOp) llhd.sig.array_get (::circt::llhd::SigArrayGetOp) llhd.sig.array_slice (::circt::llhd::SigArraySliceOp) llhd.sig.extract (::circt::llhd::SigExtractOp) llhd.sig (::circt::llhd::SigOp) llhd.sig.struct_extract (::circt::llhd::SigStructExtractOp) llhd.store (::circt::llhd::StoreOp) llhd.var (::circt::llhd::VarOp) llhd.wait (::circt::llhd::WaitOp) Attribute definition TimeAttr Type constraint definition LLHD time type Type definition PtrType SigType TimeType Operation definition llhd.</description></item><item><title>'moore' Dialect</title><link>https://circt.llvm.org/docs/Dialects/Moore/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Moore/</guid><description>Types and operations for Moore dialect This dialect defines the moore dialect, which represents various SystemVerilog-specific constructs without ambiguities and all types resolved.
Operation definition moore.mir.assign (::circt::moore::AssignOp) moore.mir.concat (::circt::moore::ConcatOp) moore.mir.constant (::circt::moore::ConstantOp) moore.mir.shl (::circt::moore::ShlOp) moore.mir.shr (::circt::moore::ShrOp) moore.mir.vardecl (::circt::moore::VariableDeclOp) Type constraint definition an SystemVerilog int packed type simple bit vector type unpacked type Type definition LValueType Operation definition moore.mir.assign (::circt::moore::AssignOp) Continuous assignment
Syntax:
operation ::= `moore.mir.assign` $dest `,` $src attr-dict `:` qualified(type($src)) A SystemVerilog assignment statement &amp;lsquo;x = y;&amp;rsquo;.</description></item><item><title>'msft' Dialect</title><link>https://circt.llvm.org/docs/Dialects/MSFT/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/MSFT/</guid><description>Microsoft internal support dialect Umbrella dialect for everything needed to support Microsoft development but not thoroughly discussed. Most (if not everything) in this dialect is a candidate for generalization and re-homing.
Operation definition msft.constructs.channel (::circt::msft::ChannelOp) msft.physical_region (::circt::msft::DeclPhysicalRegionOp) msft.partition (::circt::msft::DesignPartitionOp) msft.instance.dynamic (::circt::msft::DynamicInstanceOp) msft.instance.verb_attr (::circt::msft::DynamicInstanceVerbatimAttrOp) msft.entity.extern (::circt::msft::EntityExternOp) msft.instance.hierarchy (::circt::msft::InstanceHierarchyOp) msft.instance (::circt::msft::InstanceOp) msft.module.extern (::circt::msft::MSFTModuleExternOp) msft.module (::circt::msft::MSFTModuleOp) msft.output (::circt::msft::OutputOp) msft.pd.location (::circt::msft::PDPhysLocationOp) msft.pd.physregion (::circt::msft::PDPhysRegionOp) msft.pd.reg_location (::circt::msft::PDRegPhysLocationOp) msft.pe.output (::circt::msft::PEOutputOp) msft.systolic.array (::circt::msft::SystolicArrayOp) Attribute definition AppIDAttr LocationVectorAttr PhysLocationAttr PhysicalBoundsAttr Operation definition msft.</description></item><item><title>'staticlogic' Dialect</title><link>https://circt.llvm.org/docs/Dialects/StaticLogic/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/StaticLogic/</guid><description>Operation definition staticlogic.pipeline (::circt::staticlogic::PipelineOp) staticlogic.pipeline.register (::circt::staticlogic::PipelineRegisterOp) staticlogic.pipeline.stage (::circt::staticlogic::PipelineStageOp) staticlogic.pipeline.terminator (::circt::staticlogic::PipelineTerminatorOp) staticlogic.pipeline.while (::circt::staticlogic::PipelineWhileOp) staticlogic.return (::circt::staticlogic::ReturnOp) Operation definition staticlogic.pipeline (::circt::staticlogic::PipelineOp) pipeline operation
The &amp;ldquo;staticlogic.pipeline&amp;rdquo; operation represents a statically scheduled pipeline stucture which contains several MLIR blocks. Each MLIR block is corresponding to a pipeline stage.
Interfaces: NoSideEffect (MemoryEffectOpInterface)
Effects: MemoryEffects::Effect{}
Operands: Operand Description «unnamed» any type Results: Result Description «unnamed» any type staticlogic.pipeline.register (::circt::staticlogic::PipelineRegisterOp) StaticLogic dialect pipeline register.
Syntax:
operation ::= `staticlogic.</description></item><item><title>`comb` Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Comb/RationaleComb/</guid><description>This document describes various design points of the Comb dialect, a common dialect that is typically used in conjunction with the hw and sv dialects. Please see the hw Dialect Rationale for high level insight on how these work together. This follows in the spirit of other MLIR Rationale docs.
comb Dialect Rationale Introduction to the comb Dialect Type System for comb Dialect Zero-bit integer width is not supported Comb Operations Fully associative operations are variadic Operators carry signs instead of types No implicit extensions of operands No &amp;ldquo;Complement&amp;rdquo;, &amp;ldquo;Negate&amp;rdquo;, &amp;ldquo;ZExt&amp;rdquo;, &amp;ldquo;SExt&amp;rdquo;, Operators No multibit mux operations Endianness: operand ordering and internal representation Bitcasts Cost Model Introduction to the comb Dialect The comb dialect provides a collection of operations that define a mid-level compiler IR for combinational logic.</description></item><item><title>CIRCT Charter</title><link>https://circt.llvm.org/docs/Charter/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Charter/</guid><description>Abstract Recent trends in computer architecture have resulted in two core problems. Firstly, how do we design complex, heterogeneous systems-on-chip mixing general purpose and specialized components? Secondly, how do we program them? We believe that design tools that represent and manipulate a wide variety of abstractions are central to solving these problems. This projects is focused on using LLVM/MLIR to express these abstractions and to build useable open-source flows based on those abstractions to solve the design problems of the next decade.</description></item><item><title>ESI cosimulation model</title><link>https://circt.llvm.org/docs/Dialects/ESI/cosim/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/cosim/</guid><description>Elastic Silicon Interfaces provides a feature called cosimulation. Cosim in general allows communication between the simulation and software. In the ESI case, it is typed and can be used to build an application and language specific API which is nearly identical to how the real hardware would interface. This allows users to simulate against the actual target software (or some simplification of it), enabling easier co-design.
ESI cosim uses Cap&amp;rsquo;nProto as a message format and RPC client/server.</description></item><item><title>ESI data types and communication types</title><link>https://circt.llvm.org/docs/Dialects/ESI/types/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/types/</guid><description>ESI has two different classes of MLIR types: ones which represent data on the wires (data types) and ones which specify the type of communication. From a user perspective, communication types aren&amp;rsquo;t really types &amp;ndash; this is just how the communication style is modeled in MLIR and thus an implementation detail.
Data types In addition to the types in the hw dialect, ESI will add few:
Void void translates to &amp;ldquo;no data&amp;rdquo;, meaning just a control signal.</description></item><item><title>ESI Global Services</title><link>https://circt.llvm.org/docs/Dialects/ESI/services/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/services/</guid><description>This section not fully fleshed out and suffers from poor writing.
ESI will provide access to global resource via ESI Services. These &amp;ldquo;buses&amp;rdquo; define a typed interface and instances are instantiated globally &amp;ndash; they should be accessible at all levels of the design hierarchy. ESI services are intended to provide access to truly global resources like PCIe, shared DMA engines, DRAM, network interfaces, etc. They are generic enough to be extended to non-physical interfaces like telemetry &amp;ndash; if you have a centralized telemetry reporting engine, you probably want any module or submodule in the design to be able to access and report to it.</description></item><item><title>ESI Software APIs</title><link>https://circt.llvm.org/docs/Dialects/ESI/software_api/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/software_api/</guid><description>More on this to be written.
Status: unimplemented
Thanks to ESI&amp;rsquo;s strong static typing, typed, design-dependent software APIs can be automatically generated. Said APIs would be mostly independent of the transport mechanism (PCIe, network, etc.) used to communicate with the silicon. The same API could even drive a simulation of the ESI system.
Said APIs would need to ensure that the software is talking to the correct hardware. There are several possible approaches:</description></item><item><title>FIRRTL Annotations</title><link>https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations/</guid><description>The Scala FIRRTL Compiler (SFC) provides a mechanism to encode arbitrary metadata and associate it with zero or more &amp;ldquo;things&amp;rdquo; in a FIRRTL circuit. This mechanism is an Annotation and the association is described using one or more Targets. Annotations should be viewed as an extension to the FIRRTL IR specification, and can greatly affect the meaning and interpretation of the IR.
Annotations are represented as a dictionary, with a &amp;ldquo;class&amp;rdquo; field which describes which annotation it is, and a &amp;ldquo;target&amp;rdquo; field which represents the IR object it is attached to.</description></item><item><title>FIRRTL Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/FIRRTL/RationaleFIRRTL/</guid><description>This document describes various design points of the FIRRTL dialect, why it is the way it is, and current status and progress. This follows in the spirit of other MLIR Rationale docs.
Introduction The FIRRTL project is an existing open source compiler infrastructure used by the Chisel framework to lower &amp;ldquo;.fir&amp;rdquo; files to Verilog. It provides a number of useful compiler passes and infrastructure that allows the development of domain specific passes.</description></item><item><title>FSM Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/FSM/RationaleFSM/</guid><description>This document describes various design points of the FSM dialect, why they are the way they are, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction Finite-state machine (FSM) is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some inputs; the change from one state to another is called a transition.</description></item><item><title>Getting Started with the CIRCT Project</title><link>https://circt.llvm.org/docs/GettingStarted/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/GettingStarted/</guid><description>Overview Welcome to the CIRCT project!
&amp;ldquo;CIRCT&amp;rdquo; stands for &amp;ldquo;Circuit IR Compilers and Tools&amp;rdquo;. The CIRCT project is an (experimental!) effort looking to apply MLIR and the LLVM development methodology to the domain of hardware design tools.
Take a look at the following diagram, which gives a brief overview of the current dialects and how they interact:
Setting this up These commands can be used to setup CIRCT project:
Install Dependencies of LLVM/MLIR according to the instructions, including cmake and ninja.</description></item><item><title>Handshake Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Handshake/RationaleHandshake/</guid><description>Principle Choice of MLIR IR Representation Conventions Resources Operation definitions This document also explains in a high-level manner how different components are organized, the principles behind them and the conventions we followed. The document assume that you have basic understanding of asynchronous digital circuits at the behavioral level of abstraction.
Principle Handshake/dataflow IR describes independent, unsynchronized processes communicating data through First-in First-out (FIFO) communication channels. This can be implemented in many ways, such as using synchronous logic, or with processors.</description></item><item><title>handshake-runner</title><link>https://circt.llvm.org/docs/CommandGuide/handshake-runner/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/CommandGuide/handshake-runner/</guid><description>SYNOPSIS | handshake-runner [options] [filename] [arguments]
DESCRIPTION This application executes a function in the given MLIR module. Arguments to the function are passed on the command line and results are returned on stdout. Memref types are specified as a comma-separated list of values. This particular tool is use to check the validity of Standard-to-Handshake conversion in CIRCT.
Example The following MLIR module first convert to Handshake IR with the circt-opt tool as circt-opt -create-dataflow &amp;lt;file-name&amp;gt;.</description></item><item><title>HW Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/HW/RationaleHW/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/HW/RationaleHW/</guid><description>This document describes various design points of the hw dialect as well as global perspective on the hw, comb, and sv dialects, why they are the way they are, and current status. This follows in the spirit of other MLIR Rationale docs. For more information about the other dialects, please see the Comb Dialect Rationale and SV Dialect Rationale.
HW Dialect Rationale General Introduction Introduction to the hw Dialect hw Type System hw.</description></item><item><title>Miscellaneous Notes</title><link>https://circt.llvm.org/docs/Dialects/ESI/notes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/notes/</guid><description>ABI The ABI specifies how an ESI &amp;ldquo;API&amp;rdquo; is translated to hardware, specifically RTL. This involves both the wire-level signaling between modules and how data is arranged on those wires.
This section is purposely underspecified in this proposal as it should be an implementation detail which only advanced users need know. The main issues discussed here are how lists and data windows are lowered and presented to RTL modules. Lowering of fixed-size, default-presentation semantics ports is mostly straight forward, so is not discussed here.</description></item><item><title>Passes</title><link>https://circt.llvm.org/docs/Passes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Passes/</guid><description>This document describes the available CIRCT passes and their contracts.
Conversion Passes -convert-affine-to-staticlogic: Convert Affine dialect to StaticLogic pipelines -convert-hw-to-llhd: Convert HW to LLHD -convert-llhd-to-llvm: Convert LLHD to LLVM -convert-moore-to-core: Convert Moore to Core -create-pipeline: Create StaticLogic pipeline operations -export-split-verilog: Emit the IR to a (System)Verilog directory of files -export-verilog: Emit the IR to a (System)Verilog file -handshake-remove-block-structure: Remove block structure in Handshake IR -lower-calyx-to-hw: Lower Calyx to HW -lower-firrtl-to-hw: Lower FIRRTL to HW -lower-handshake-to-firrtl: Lower Handshake to FIRRTL -lower-handshake-to-hw: Lower Handshake to ESI/HW/Comb/Seq -lower-scf-to-calyx: Lower SCF/Standard to Calyx -lower-static-logic-to-calyx: Lower StaticLogic to Calyx -lower-std-to-handshake: Lower Standard MLIR into Handshake IR -test-prepare-for-emission: Prepare IR for ExportVerilog Calyx Dialect Passes -calyx-clk-insertion: Inserts assignments from component clock to sub-component clock.</description></item><item><title>PyCDE</title><link>https://circt.llvm.org/docs/PyCDE/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/PyCDE/</guid><description>PyCDE stands for Python circuit design entry. It is an experimental, opinionated, Python-based fronted for CIRCT&amp;rsquo;s Python bindings. The goal is to make the definition of hardware modules using the bindings simple.
Installation via Pip PyCDE is now being released on PyPI: https://pypi.org/project/pycde/
Installing and Building with Wheels The simplest way to get started using PyCDE is to install it with the pip install command:
$ cd circt $ pip install frontends/PyCDE --use-feature=in-tree-build If you just want to build the wheel, use the pip wheel command:</description></item><item><title>Seq(uential) Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/Seq/RationaleSeq/</guid><description>This document describes various design points of the seq dialect, why it is the way it is, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction Digital logic is generally split into two categories: combinational and sequential. CIRCT contains a comb dialect to model the basic combinational operations and the (future) seq dialect which is discussed here. The intention of the seq dialect is to provide a set of stateful constructs which can be used to model sequential logic, independent of the output method (e.</description></item><item><title>Static scheduling infrastructure</title><link>https://circt.llvm.org/docs/Scheduling/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Scheduling/</guid><description>Scheduling is a common concern in hardware design, for example in high-level synthesis flows targeting an FSM+Datapath execution model (&amp;ldquo;static HLS&amp;rdquo;). This document gives an overview of, and provides rationale for, the infrastructure in the circt::scheduling namespace. At its core, it defines an extensible problem model that acts as an interface between clients (i.e. passes that have a need to schedule a graph-like IR) and reusable algorithm implementations.
This infrastructure aims to provide:</description></item><item><title>SV Dialect Rationale</title><link>https://circt.llvm.org/docs/Dialects/SV/RationaleSV/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/SV/RationaleSV/</guid><description>This document describes various design points of the sv dialect, a common dialect that is typically used in conjunction with the hw and comb dialects. Please see the HW Dialect Rationale for high level insight on how these work together. This follows in the spirit of other MLIR Rationale docs.
SV Dialect Rationale Introduction to the sv dialect sv Type System Overview of sv dialect operations Statements Declarations Expressions Verbatim op Cost Model Introduction to the sv dialect The sv dialect is one of the dialects that can be mixed into the HW dialect, providing access to a range of syntactic and behavioral constructs in SystemVerilog.</description></item><item><title>Symbol and Inner Symbol Rationale</title><link>https://circt.llvm.org/docs/RationaleSymbols/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleSymbols/</guid><description>This document describes various design points of the major CIRCT dialects relating to the use of symbols and the introduction of inner symbols and related types. This follows in the spirit of other MLIR Rationale docs.
Introduction Verilog and FIRRTL have, from a software compiler perspective, an unusual number of nameable entities which can be referred to non-locally. These entities have deep nesting in the code structures. The requirements of dealing with these entities and references entails more complexity than provided by MLIR&amp;rsquo;s symbols and symbol tables.</description></item><item><title>The Elastic Silicon Interconnect dialect</title><link>https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Dialects/ESI/RationaleESI/</guid><description>Long ago, software function calling conventions were ad-hoc. This led to issues, particularly with register clobbering and stack corruption. This is &amp;ndash; in large part &amp;ndash; the state of FPGA/ASIC design today: wire signaling protocols are often ad-hoc, which also leads to major issues. Though there are efforts to standardize the signaling protocols there are many minor and major variants, both of which lead to confusion which can cause real problems when one is listening to and twiddling the wires manually.</description></item><item><title>Using the Python Bindings</title><link>https://circt.llvm.org/docs/PythonBindings/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/PythonBindings/</guid><description>If you are mainly interested in using CIRCT from Python scripts, you need to compile both LLVM/MLIR and CIRCT with Python bindings enabled. Furthermore, you must use a unified build, where LLVM/MLIR and CIRCT are compiled together in one step.
CIRCT also includes an experimental, opinionated frontend for CIRCT&amp;rsquo;s Python bindings, called PyCDE.
Installing and Building with Wheels CIRCT provides a setup.py script that take care of configuring and building LLVM/MLIR, CIRCT, and CIRCT&amp;rsquo;s Python bindings.</description></item><item><title>Verilog and SystemVerilog Generation</title><link>https://circt.llvm.org/docs/VerilogGeneration/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/VerilogGeneration/</guid><description>Verilog and SystemVerilog are critical components of the hardware design tool ecosystem, but generating syntactically correct Verilog that is acceptable by a wide range of tools is a challenge &amp;ndash; and generating &amp;ldquo;good looking&amp;rdquo; output even more so. This document describes CIRCT&amp;rsquo;s approach and support for generating Verilog and SystemVerilog, some of the features and capabilities provided, and information about the internal layering of the related subsystems.
Why is this hard?</description></item></channel></rss>